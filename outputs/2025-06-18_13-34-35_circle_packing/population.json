[
  {
    "id": 1,
    "parent_id": null,
    "solution": "import numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct arrangement of 26 circles in unit square to maximize sum of radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n    \n    # Ring of 16 circles\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.4 * np.cos(angle), 0.5 + 0.4 * np.sin(angle)]\n    \n    # One additional circle\n    centers[25] = [0.5, 0.85]\n    \n    # Ensure all circles are well within the unit square\n    centers = np.clip(centers, 0.1, 0.9)\n    \n    # Calculate radii\n    n = centers.shape[0]\n    radii = np.ones(n) * 0.05  # Start with small radii\n    \n    # Limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y, 0.08)\n    \n    # Limit by distance to other circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist * 0.95:  # Leave small gap\n                scale = (dist * 0.95) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {}
    }
  },
  {
    "id": 2,
    "parent_id": 1,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved arrangement: expand circles to use the full square and optimize radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.22 * np.cos(angle), 0.5 + 0.22 * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.40 * np.cos(angle), 0.5 + 0.40 * np.sin(angle)]\n    \n    # One additional circle: place near top edge\n    centers[25] = [0.5, 0.87]\n    \n    # Don't clip centers, but keep them within [r_min, 1-r_min] as needed\n    r_min = 0.008  # to avoid degeneracy\n    \n    # Set initial radii to distance to the closest wall (with a safety margin)\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.98  # 98% to avoid touching border\n    \n    # Limit by distance to other circles: shrink if needed\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.99:  # Leave small gap\n                scale = (dist * 0.99) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    # Attempt one greedy pass to expand each radius as much as possible\n    for i in range(n):\n        # Limit by distance to border\n        max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n        # Limit by distance to any other circle\n        for j in range(n):\n            if j == i:\n                continue\n            d = np.linalg.norm(centers[i] - centers[j])\n            if d > 1e-8:\n                max_r = min(max_r, d - radii[j])\n        radii[i] = max(r_min, min(radii[i], max_r*0.99))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.4063489677219765,
      "additional_data": {
        "sum_radii": "1.406349",
        "target_ratio": "0.533719",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 3,
    "parent_id": 2,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement: tweak ring radii, improved shrinking (only shrink larger of pair), and a second expansion pass.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Slightly expand inner and outer ring radii for fuller packing\n    inner_ring_r = 0.245  # was 0.22\n    outer_ring_r = 0.415  # was 0.40\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # 26th circle: move slightly right from original\n    centers[25] = [0.5, 0.89]  # was 0.87\n\n    r_min = 0.008\n\n    # Set initial radii: maximize each circle's distance to border\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.98  # avoid clipping by border\n    \n    # Improved proximity shrink: shrink only the bigger of a too-close pair\n    for it in range(2):  # Two passes help resolve conflicts\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * 0.99:\n                    # Only shrink the larger radius\n                    if radii[i] > radii[j]:\n                        radii[i] = max(r_min, dist * 0.99 - radii[j])\n                    else:\n                        radii[j] = max(r_min, dist * 0.99 - radii[i])\n\n    # Greedy (and more careful) expansion pass for each circle\n    for iter_expand in range(2):  # Two sweeps\n        for i in range(n):\n            # Distance to wall constraint\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            # Safety margin\n            radii[i] = max(r_min, min(radii[i], max_r * 0.99))\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.7422402077786434,
      "additional_data": {
        "sum_radii": "1.742240",
        "target_ratio": "0.661192",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 4,
    "parent_id": 2,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Slight improvement: move the 26th circle to be symmetric (top and bottom),\n    and perform more greedy expansion passes.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.22 * np.cos(angle), 0.5 + 0.22 * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.40 * np.cos(angle), 0.5 + 0.40 * np.sin(angle)]\n    \n    # Two additional circles: place near top and bottom, symmetric\n    centers[25] = [0.5, 0.87]\n    centers[24] = [0.5, 0.13]\n    \n    # Remove one from outer ring (was at 24), so shift the outer ring assignment one back\n    # So outer ring only gets indices 9 to 23 (15 circles)\n    # Let's fix: Only 15 in outer ring now, so need to adjust outer ring distribution.\n    for i in range(15):\n        angle = 2 * np.pi * i / 15\n        centers[i + 9] = [0.5 + 0.40 * np.cos(angle), 0.5 + 0.40 * np.sin(angle)]\n    \n    # Now: 1 center, 8 inner, 15 outer, 2 extra = 26\n    \n    r_min = 0.008  # to avoid degeneracy\n    \n    # Set initial radii to distance to the closest wall (with a safety margin)\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.985  # slightly less conservative than before\n\n    # Limit by distance to other circles: shrink if needed\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.99:  # Leave small gap\n                scale = (dist * 0.99) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # Perform multiple greedy passes to expand each radius more thoroughly\n    for pass_num in range(3):  # do 3 passes\n        for i in range(n):\n            # Limit by distance to border\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Limit by distance to any other circle\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.99))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.4111291702827813,
      "additional_data": {
        "sum_radii": "1.411129",
        "target_ratio": "0.535533",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 5,
    "parent_id": 3,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement: tweak ring radii, improved outer-ring nudging, better placement of 26th circle,\n    and more expansion/shrink passes.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    inner_ring_r = 0.242  # slightly narrowed\n    outer_ring_r = 0.418  # slightly expanded\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring)\n    # We'll apply a small offset to the two near the top, to free up the 26th circle\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        base = np.array([0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)])\n        \n        # Find circles near the top (for i==2 and i==3 are closest to 90 degrees)\n        if i == 2 or i == 3:\n            # Push these very slightly up and outward\n            delta_theta = np.pi/64\n            angle_nudged = angle + (delta_theta if i==2 else -delta_theta)\n            base = np.array([0.5 + 1.015*outer_ring_r * np.cos(angle_nudged), \n                             0.5 + 1.01*outer_ring_r * np.sin(angle_nudged)])\n        \n        centers[i + 9] = base\n    \n    # 26th circle: place slightly above original, and a bit to the right, to free some space\n    centers[25] = [0.512, 0.912]\n    \n    r_min = 0.008\n\n    # Initial radii: maximize each circle's border distance\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.985  # a touch more aggressive than 0.98\n\n    # Improved proximity shrink: shrink only the bigger of a too-close pair\n    for it in range(3):  # 3 passes\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * 0.99:\n                    if radii[i] > radii[j]:\n                        radii[i] = max(r_min, dist * 0.99 - radii[j])\n                    else:\n                        radii[j] = max(r_min, dist * 0.99 - radii[i])\n\n    # More expansion passes for each circle\n    for iter_expand in range(3):  # Three sweeps\n        for i in range(n):\n            # Distance to wall constraint\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            # Safety margin\n            radii[i] = max(r_min, min(radii[i], max_r * 0.99))\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "invalid",
        "error": "Invalid packing (overlaps or out of bounds)"
      }
    }
  },
  {
    "id": 6,
    "parent_id": 1,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct arrangement of 26 circles in unit square to maximize sum of radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n    \n    # Ring of 16 circles\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.4 * np.cos(angle), 0.5 + 0.4 * np.sin(angle)]\n    \n    # One additional circle\n    centers[25] = [0.5, 0.85]\n    \n    # Allow more leeway toward the edge\n    centers = np.clip(centers, 0.08, 0.92)\n    \n    # Start with reasonable radii\n    radii = np.ones(n) * 0.055\n    \n    # Iteratively resolve overlaps & borders\n    for pass_outer in range(3):\n        # Shrink radii to avoid border\n        for i in range(n):\n            x, y = centers[i]\n            rborder = min(x, y, 1 - x, 1 - y, 0.085)\n            if radii[i] > rborder:\n                radii[i] = rborder\n\n        # Resolve overlaps with a tighter threshold\n        changed = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = (radii[i] + radii[j]) * 0.98\n                if d < min_dist and d > 1e-8:\n                    # shrink both radii, proportional to their current sizes\n                    excess = min_dist - d\n                    total_r = radii[i] + radii[j]\n                    shrink_i = radii[i] / total_r * excess / 0.98\n                    shrink_j = radii[j] / total_r * excess / 0.98\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n                    changed = True\n        # After overlaps, try to regrow radii greedily\n        for i in range(n):\n            # Limit by border\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1], 0.085)\n            # Limit by each other circle\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_ri = (d - radii[j]) / 0.98\n                    if max_ri < max_r:\n                        max_r = max_ri\n            radii[i] = max(0, min(radii[i], max_r))\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "invalid",
        "error": "Invalid packing (overlaps or out of bounds)"
      }
    }
  },
  {
    "id": 7,
    "parent_id": 6,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved arrangement of 26 circles in unit square to maximize sum of radii.\n    Iterative improvement of the initial approach.\n    \"\"\"\n    n = 26\n    r_init = 0.045  # start reasonably small\n    \n    centers = np.zeros((n, 2))\n    # Central circle (center, so safe)\n    centers[0] = [0.5, 0.5]\n    \n    # First ring (8 circles)\n    R1 = 0.23  # slightly reduced radius (from 0.25) to keep away from walls\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + R1 * np.cos(angle), 0.5 + R1 * np.sin(angle)]\n    \n    # Outer ring (16 circles)\n    R2 = 0.39 # slightly reduced (from 0.4)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + R2 * np.cos(angle), 0.5 + R2 * np.sin(angle)]\n    \n    # Extra circle at top, but further from wall\n    centers[25] = [0.5, 0.83] # was 0.85\n    \n    # No clipping! (should be safely in range)\n    \n    radii = np.ones(n) * r_init\n    \n    # Iteratively resolve overlaps & borders\n    for pass_outer in range(5):  # more passes for safety\n        # Border: shrink any radius that pokes outside\n        for i in range(n):\n            x, y = centers[i]\n            r_max = min(x, y, 1 - x, 1 - y)\n            if radii[i] > r_max:\n                radii[i] = r_max\n        \n        # Pairwise overlap: force strict no overlap (or small slack)\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-8:\n                    # shrink both radii, proportional to their size\n                    excess = min_dist - d\n                    total = radii[i] + radii[j]\n                    # Protect divide-by-zero\n                    if total > 1e-10:\n                        shrink_i = radii[i] / total * excess\n                        shrink_j = radii[j] / total * excess\n                        radii[i] -= shrink_i\n                        radii[j] -= shrink_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # Regrow radii greedily (try to maximize each)\n        for i in range(n):\n            # Border first\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    possible = d - radii[j]\n                    if possible < max_r:\n                        max_r = possible\n            radii[i] = max(0, min(radii[i], max_r))\n    \n    # Final validity and no negative radii\n    radii = np.clip(radii, 0, None)\n    # Safety: ensure all circles entirely within [0,1]\n    for i in range(n):\n        x, y = centers[i]\n        if not (radii[i] <= x <= 1 - radii[i] and radii[i] <= y <= 1 - radii[i]):\n            # shrink to fit\n            max_r = min(x, y, 1 - x, 1 - y)\n            radii[i] = max(0, min(radii[i], max_r))\n\n    # Safety: ensure all pairs not overlapping\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-7:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n\n    sum_radii =",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 8,
    "parent_id": 7,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved arrangement of 26 circles in unit square to maximize sum of radii.\n    Iteratively repairs and regrows radii for better packing.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Circle pattern: 1 center, 8 first ring, 17 outer ring\n    centers[0] = [0.5, 0.5]\n    # First ring: radius 0.23\n    R1 = 0.23\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[1 + i] = [0.5 + R1 * np.cos(angle), 0.5 + R1 * np.sin(angle)]\n    # Outer ring: radius 0.39, 17 circles for slight overlap fill\n    R2 = 0.39\n    for i in range(17):\n        angle = 2 * np.pi * i / 17\n        centers[9 + i] = [0.5 + R2 * np.cos(angle), 0.5 + R2 * np.sin(angle)]\n\n    # Basic initialization -- try a larger start\n    radii = np.ones(n) * 0.048\n\n    # Run iterative repair/growth cycles\n    for pass_outer in range(10):\n        # First: shrink any that poke outside the square\n        for i in range(n):\n            x, y = centers[i]\n            r_max = min(x, y, 1 - x, 1 - y)\n            radii[i] = min(radii[i], r_max)\n\n        # Then: shrink pairwise overlaps strictly\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = centers[i] - centers[j]\n                d = np.hypot(dx, dy)\n                sep = radii[i] + radii[j]\n                if d < sep - 1e-12:\n                    excess = sep - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        shrink_i = radii[i] / total * excess\n                        shrink_j = radii[j] / total * excess\n                        radii[i] -= shrink_i\n                        radii[j] -= shrink_j\n                        radii[i] = max(0, radii[i])\n                        radii[j] = max(0, radii[j])\n\n        # Local greedy regrowth: each circle tries to get as large as possible given neighbors\n        for i in range(n):\n            x, y = centers[i]\n            maxr = min(x, y, 1 - x, 1 - y)\n            for j in range(n):\n                if i == j:\n                    continue\n                dx, dy = centers[i] - centers[j]\n                d = np.hypot(dx, dy)\n                if d > radii[j] + 1e-12:\n                    limit = d - radii[j]\n                    maxr = min(maxr, limit)\n            # Regrow to allowed\n            radii[i] = max(0.0, min(radii[i] + 0.002, maxr))  # Small step growth\n\n    # Post-process: one final growth pass (some may have leftover slack)\n    for i in range(n):\n        x, y = centers[i]\n        maxr = min(x, y, 1 - x, 1 - y)\n        for j in range(n):\n            if i == j:\n                continue\n            dx, dy = centers[i] - centers[j]\n            d = np.hypot(dx, dy)\n            if d > radii[j] + 1e-12:\n                limit = d - radii[j]\n                maxr = min(maxr, limit)\n        radii[i] = np.clip(maxr, 0, 1)\n\n    # Ensure all circles contained within square\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        if r > min(x, y, 1 - x, 1 - y):\n            radii[i] = max(0, min(r, x, y, 1-x, 1-y))\n\n    # Final overlap repair (edge cases)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx, dy = centers[i] - centers[j]\n            d = np.hypot(dx, dy)\n            sep = radii[i] + radii[j]\n            if d < sep - 1e-8:\n                excess = sep - d\n                total = radii[i] + radii[j]\n                if total > 1e-12:\n                    shrink_i = radii[i] / total * excess\n                    shrink_j = radii[j] / total * excess\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(0, radii[i])\n                    radii[j] = max(0, radii[j])\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.9205969911753986,
      "additional_data": {
        "sum_radii": "1.920597",
        "target_ratio": "0.728879",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 9,
    "parent_id": 4,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Place the two extra circles slightly above/below the horizontal midline to avoid crowding and utilize border space.\n    - Pull outer ring closer to the edge to free up more room inside (radius grows).\n    - Use more (5) greedy expansion passes for more aggressive radii maximization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Inner ring of 8 circles\n    r_inner = 0.23  # slightly increased from 0.22\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n    \n    # Outer ring of 15 circles\n    r_outer = 0.435  # move closer to border than prior 0.40\n    for i in range(15):\n        angle = 2 * np.pi * i / 15\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n    \n    # Two extra circles (drawn a bit above/below the middle to better fill the space beside center)\n    centers[24] = [0.5, 0.12]\n    centers[25] = [0.5, 0.88]\n    \n    r_min = 0.008  # to avoid degeneracy\n    \n    # Initial radii: use 0.99 buffer of wall proximity\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.99  # allow larger starting radii, but still buffered\n\n    # Initial shrink to handle overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            # Shrink if too close\n            if radii[i] + radii[j] > dist * 0.99:\n                scale = (dist * 0.99) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # Greedy passes - increase for more full packing\n    for pass_num in range(5):  # 5 passes instead of 3\n        for i in range(n):\n            # Limit by distance to border\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Limit by distance to any other circle\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.99))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.6423652507303115,
      "additional_data": {
        "sum_radii": "1.642365",
        "target_ratio": "0.623289",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 10,
    "parent_id": 1,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct arrangement of 26 circles in unit square to maximize sum of radii.\n    Small improvement: iteratively 'inflate' each circle to the largest legal radius at its center,\n    repeating the process several times to fill more space.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n    \n    # Ring of 16 circles\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.4 * np.cos(angle), 0.5 + 0.4 * np.sin(angle)]\n    \n    # One additional circle\n    centers[25] = [0.5, 0.85]\n    \n    # Ensure all circles are within the unit square\n    centers = np.clip(centers, 0.1, 0.9)\n    \n    # Start with small radii\n    radii = np.ones(n) * 0.03\n\n    # Iterative inflation\n    for _ in range(12):  # 12 rounds is usually enough for convergence\n        for i in range(n):\n            x, y = centers[i]\n            # Max by walls\n            max_r = min(x, y, 1-x, 1-y)\n            # No overlap with other circles\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                # May subtract a tiny eps to avoid rounding overlap\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j] - 1e-7)\n            # Prevent negative or excessively small radii\n            radii[i] = max(max_r, 1e-6)\n    \n    # One last check for nonnegativity and in-bounds\n    radii = np.clip(radii, 1e-7, 1.0)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.6585770609032215,
      "additional_data": {
        "sum_radii": "1.658577",
        "target_ratio": "0.629441",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 11,
    "parent_id": 7,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved iterative approach for packing 26 circles in unit square to maximize sum of radii.\n    Conservative initial configuration and controlled inflation/deflation iterations.\n    \"\"\"\n    n = 26\n    # Slightly reduce starting radii to avoid initial overlap\n    r_init = 0.03\n\n    centers = np.zeros((n, 2))\n    # Place 1 central\n    centers[0] = [0.5, 0.5]\n\n    # First shell: 8 circles\n    R1 = 0.22\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [\n            0.5 + R1 * np.cos(angle),\n            0.5 + R1 * np.sin(angle),\n        ]\n\n    # Second shell: 16 circles\n    R2 = 0.39\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [\n            0.5 + R2 * np.cos(angle),\n            0.5 + R2 * np.sin(angle),\n        ]\n\n    # Last circle: locate to a less congested upper region\n    centers[25] = [0.5, 0.80]\n\n    # Initial radii, slightly smaller to allow growth\n    radii = np.ones(n) * r_init\n\n    max_iters = 20\n    for it in range(max_iters):\n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Resolve overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-10:\n                    overlap = min_dist - d\n                    # Shrink both in proportion to their sizes\n                    if radii[i] + radii[j] > 1e-10:\n                        frac_i = radii[i] / (radii[i] + radii[j])\n                        frac_j = radii[j] / (radii[i] + radii[j])\n                        radii[i] -= overlap * frac_i\n                        radii[j] -= overlap * frac_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n        # 3. Greedy regrowth of all radii, by small increment, respecting constraints\n        for i in range(n):\n            # Maximum radius allowed by borders\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Maximum by neighbor avoidance\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-12:\n                    # The new radius must be <= d - r_j\n                    candidate_r = d - radii[j]\n                    if candidate_r < max_r:\n                        max_r = candidate_r\n            # Try to grow a little, but not beyond feasible max\n            grow_amt = 0.015  # Make this (inflation step) small for stability\n            radii[i] = min(max_r, radii[i] + grow_amt)\n            radii[i] = max(radii[i], 0)  # Ensure no negative\n\n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final safety: ensure no overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-8:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n\n    # Final check: valid radii, valid containment\n    radii = np.clip(radii, 0, None)\n    for i in range(n):\n        x, y = centers[i]\n        if not (radii[i] <= x <= 1 - radii[i] and radii[i] <= y <= 1 - radii[i]):\n            max_r = min(x, y, 1 - x, 1 - y)\n            radii[i] = max(0, min(radii[i], max_r))\n    sum_radii = np.sum(radii)\n\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 1.9887159991706185,
      "additional_data": {
        "sum_radii": "1.988716",
        "target_ratio": "0.754731",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 12,
    "parent_id": 4,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Iterative improvement: \n    - Place 2 extra circles in top-left and bottom-right corners (not just top/bottom center)\n    - Expand outer ring slightly for better coverage\n    - Use more aggressive expansion passes (more passes, tighter margin)\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles (inner ring; radius 0.22 as before)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.22 * np.cos(angle), 0.5 + 0.22 * np.sin(angle)]\n    \n    # Slightly larger radius for outer ring than before (was 0.40), now 0.415\n    outer_ring_r = 0.415\n    # 15 circles on outer ring\n    for i in range(15):\n        angle = 2 * np.pi * i / 15\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # Two extra circles: place toward corners\n    margin = 0.125\n    centers[24] = [margin, margin]\n    centers[25] = [1-margin, 1-margin]\n    \n    r_min = 0.008  # avoid degeneracy\n    \n    # Set initial radii to distance to the closest wall, shrink back a little\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.992  # slightly less conservative than before\n\n    # Limit by pairwise distances, shrinking both if needed (tighter margin)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.997:  # Even tighter gap\n                scale = (dist * 0.997) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # Greedy passes to expand each radius more thoroughly (increase num passes/margin)\n    for pass_num in range(5):\n        for i in range(n):\n            # Maximum radius allowed by border\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.997))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.7038419255786055,
      "additional_data": {
        "sum_radii": "1.703842",
        "target_ratio": "0.646619",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 13,
    "parent_id": 9,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement on prior solution:\n    - Increase outer ring radius slightly (fills more corners).\n    - Move 'extra' circles closer to top/bottom, utilize edge space.\n    - Increase greedy maximization to 10 passes.\n    - Use a less conservative 0.995 for boundary/overlap shrinkage.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles\n    r_inner = 0.23\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n\n    # Outer ring of 15 circles\n    r_outer = 0.445  # was 0.435, now more aggressive\n    for i in range(15):\n        angle = 2 * np.pi * i / 15\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n\n    # Two extra circles, pushed slightly further toward corners\n    centers[24] = [0.5, 0.09]\n    centers[25] = [0.5, 0.91]\n\n    r_min = 0.008  # anti-degeneracy\n\n    # Initial radii: start as large as can fit vs wall, less conservative\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.995\n\n    # Initial shrink for overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.995:\n                scale = (dist * 0.995) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # More aggressive greedy maximium: 10 passes and less margin\n    for pass_num in range(10):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.995))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.6587287075097967,
      "additional_data": {
        "sum_radii": "1.658729",
        "target_ratio": "0.629499",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 14,
    "parent_id": 3,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement: finer tuning of ring radii, pass counts, and a tiny reduction\n    of safety margins in shrink/expansion for higher sum of radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Slightly further expand/adjust rings for denser packing\n    inner_ring_r = 0.250  # +0.005 from baseline\n    outer_ring_r = 0.428  # +0.013 from baseline\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # 26th circle: move slightly further up\n    centers[25] = [0.5, 0.91]  # from 0.89\n\n    r_min = 0.008\n\n    # Initial radii: maximize to squares, safety margin\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.985  # slightly less cautious than before (was 0.98)\n    \n    # Improved proximity shrink: shrink only the bigger of a too-close pair\n    for it in range(3):  # More passes ensure better no-overlap\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * 0.9955:  # less margin, tighter packing\n                    # Only shrink the larger radius\n                    if radii[i] > radii[j]:\n                        radii[i] = max(r_min, dist * 0.9955 - radii[j])\n                    else:\n                        radii[j] = max(r_min, dist * 0.9955 - radii[i])\n\n    # More careful expansion pass for each circle\n    for iter_expand in range(3):  # More expansion sweeps\n        for i in range(n):\n            # Distance to wall constraint\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            # Safety margin reduced to .995, improvement\n            radii[i] = max(r_min, min(radii[i], max_r * 0.995))\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.8645885129597575,
      "additional_data": {
        "sum_radii": "1.864589",
        "target_ratio": "0.707624",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 15,
    "parent_id": 3,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement: slightly increase ring radii, start with slightly larger radii,\n    run more passes for radius adjustment, and use a smaller shrink margin.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Slightly expand inner and outer ring radii for fuller packing (small increase)\n    inner_ring_r = 0.255   # Was 0.245\n    outer_ring_r = 0.425   # Was 0.415\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # 26th circle: move upward and slightly right\n    centers[25] = [0.51, 0.91]  # Was [0.5, 0.89]\n\n    r_min = 0.008\n\n    # Set initial radii: maximize each circle's distance to border\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.992  # Start a bit larger than before\n    \n    # Improved proximity shrink: shrink only the bigger of a too-close pair, 3 passes\n    for it in range(3):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * 0.995:  # Smaller margin\n                    # Only shrink the larger radius\n                    if radii[i] > radii[j]:\n                        radii[i] = max(r_min, dist * 0.995 - radii[j])\n                    else:\n                        radii[j] = max(r_min, dist * 0.995 - radii[i])\n\n    # Greedy (and more careful) expansion pass for each circle, 3 passes\n    for iter_expand in range(3):\n        for i in range(n):\n            # Distance to wall constraint\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.995))  # Smaller margin\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.76951983727923,
      "additional_data": {
        "sum_radii": "1.769520",
        "target_ratio": "0.671545",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 16,
    "parent_id": 12,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Iterative improvement on candidate:\n    - Compute the largest possible outer_ring_r for the 15 circle outer ring, so the circles fit just inside the unit square\n    - All else: as before\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    # Central circle\n    centers[0] = [0.5, 0.5]\n    # Inner ring of 8 circles\n    inner_ring_r = 0.22\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    # Dynamically compute maximal possible outer_ring_r for 15 equally spaced outer ring centers\n    outer_ring_angles = [2 * np.pi * i / 15 for i in range(15)]\n    # Find maximum possible r such that all centers at [0.5 + r*cos(a), 0.5 + r*sin(a)] have minimum wall margin >= 0\n    max_r_list = []\n    for angle in outer_ring_angles:\n        x_c = 0.5 + np.cos(angle)\n        y_c = 0.5 + np.sin(angle)\n        # The center is at 0.5,0.5, so scale cosine/sine by r\n        # Find r so x, y in [0,1]: 0.5 + r*cos\u03b8 >= 0 and <=1, same for sin\u03b8\n        rx = 0.5 / abs(np.cos(angle)) if abs(np.cos(angle)) > 1e-12 else np.inf\n        if np.cos(angle) > 0:\n            rx = (1 - 0.5) / np.cos(angle)\n        elif np.cos(angle) < 0:\n            rx = (0 - 0.5) / np.cos(angle)\n        # same for y\n        ry = 0.5 / abs(np.sin(angle)) if abs(np.sin(angle)) > 1e-12 else np.inf\n        if np.sin(angle) > 0:\n            ry = (1 - 0.5)/np.sin(angle)\n        elif np.sin(angle) < 0:\n            ry = (0 - 0.5)/np.sin(angle)\n        max_r = min(rx, ry)\n        # But correct for negative r (shouldn't happen), cap at 0.5\n        if max_r < 0 or max_r > 0.5:\n            max_r = 0.5\n        max_r_list.append(max_r)\n    # Now, subtract a small safety epsilon (~0.01) to avoid edge touch\n    outer_ring_r = min(max_r_list) * 0.99\n    # Place outer ring\n    for idx, angle in enumerate(outer_ring_angles):\n        centers[9 + idx] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    # Keep two extra circles in corners\n    margin = 0.125\n    centers[24] = [margin, margin]\n    centers[25] = [1 - margin, 1 - margin]\n    r_min = 0.008  # avoid degeneracy\n    # Initial radii: distance to closest wall, shrink back a bit\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.993  # slightly less conservative\n    # Tighten by pairwise distances, shrink both if needed\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.997:  # Tight margin\n                scale = (dist * 0.997) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    # Greedy expansion passes: raise passes and margin for tighter packing\n    for pass_num in range(6):\n        for i in range(n):\n            # Maximum radius allowed by border\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.997))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "invalid",
        "error": "Invalid packing (overlaps or out of bounds)"
      }
    }
  },
  {
    "id": 17,
    "parent_id": 16,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved version: handle corner circles more robustly.\n    For each, maximize radius to fit square and avoid overlaps at initialization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    # Central circle\n    centers[0] = [0.5, 0.5]\n    # Inner ring of 8 circles\n    inner_ring_r = 0.22\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    # Outer ring of 15 circles, maximize possible outer_ring_r so all circles' centers stay in bounds\n    outer_ring_angles = [2 * np.pi * i / 15 for i in range(15)]\n    max_r_list = []\n    for angle in outer_ring_angles:\n        cos_a = np.cos(angle)\n        sin_a = np.sin(angle)\n        if abs(cos_a) > 1e-12:\n            if cos_a > 0:\n                rx = (1 - 0.5) / cos_a\n            else:\n                rx = (0 - 0.5) / cos_a\n        else:\n            rx = np.inf\n        if abs(sin_a) > 1e-12:\n            if sin_a > 0:\n                ry = (1 - 0.5) / sin_a\n            else:\n                ry = (0 - 0.5) / sin_a\n        else:\n            ry = np.inf\n        max_r = min(rx, ry)\n        # Should be between 0 and 0.5\n        if max_r < 0 or max_r > 0.5:\n            max_r = 0.5\n        max_r_list.append(max_r)\n    outer_ring_r = min(max_r_list) * 0.983  # take a smaller margin than before, more conservative\n\n    for idx, angle in enumerate(outer_ring_angles):\n        centers[9 + idx] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    # The two corner circles - maximize their radii at placement!\n\n    # Place circle in (margin, margin)\n    cA = np.array([0.125, 0.125])\n    # Place circle in (1 - margin, 1 - margin)\n    cB = np.array([0.875, 0.875])\n\n    centers[24] = cA\n    centers[25] = cB\n\n    r_min = 0.008  # avoid degeneracy\n\n    # Initial radii: distance to closest wall, shrink slightly\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.98  # slightly more conservative for initial pass\n\n    # For each corner, reduce radius if too close to any previous circle\n    for k in [24, 25]:\n        cx, cy = centers[k]\n        max_r = min(cx, cy, 1-cx, 1-cy)\n        for i in range(n):\n            if i == k:\n                continue\n            dij = np.linalg.norm(centers[i] - centers[k])\n            # since initial radii are small, this will trim to available space\n            available = dij - radii[i]\n            if available < max_r:\n                max_r = available * 0.98\n        radii[k] = max(r_min, min(radii[k], max_r * 0.99))\n\n    # Tighten by pairwise distances, possibly shrink both if they're encroaching\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.995:  # more margin for safety\n                scale = (dist * 0.995) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # Greedy expansion passes: expand each circle up to wall/neighbor\n    for pass_num in range(9):  # more passes for better fit\n        for i in range(n):\n            # Maximum radius allowed by border\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-10:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.99))  # a bit tighter\n\n    # Final safety pass: global shrink if any overlap or out of bounds\n    def is_valid(centers, radii):\n        for i in range(n):\n            if (centers[i][0] - radii[i] < -1e-9 or\n                centers[i][1] - radii[i] < -1e-9 or\n                centers[i][0] + radii[i] > 1+1e-9 or\n                centers[i][1] + radii[i] > 1+1e-9 or\n                radii[i] < 0):\n                return False\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > d",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 18,
    "parent_id": 14,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Slightly increase inner/outer ring radii\n    - Place 26th circle a bit higher\n    - One more shrinking pass, slightly smaller safety margin\n    - Minimum radius slightly lower\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Slightly further expand/adjust rings for denser packing\n    inner_ring_r = 0.253  # was 0.250\n    outer_ring_r = 0.431  # was 0.428\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # 26th circle: move slightly further up\n    centers[25] = [0.5, 0.925]  # from 0.91\n\n    r_min = 0.007  # was 0.008\n\n    # Initial radii: maximize to squares, safety margin\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.986  # was 0.985, slightly less margin\n    \n    # Improved proximity shrink: shrink only the bigger of a too-close pair\n    for it in range(4):  # Increased number of passes from 3\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * 0.996:  # margin up from 0.9955\n                    # Only shrink the larger radius\n                    if radii[i] > radii[j]:\n                        radii[i] = max(r_min, dist * 0.996 - radii[j])\n                    else:\n                        radii[j] = max(r_min, dist * 0.996 - radii[i])\n\n    # More careful expansion pass for each circle\n    for iter_expand in range(4):  # Was 3\n        for i in range(n):\n            # Distance to wall constraint\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            # Safety margin very slightly reduced\n            radii[i] = max(r_min, min(radii[i], max_r * 0.996))\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "invalid",
        "error": "Invalid packing (overlaps or out of bounds)"
      }
    }
  },
  {
    "id": 19,
    "parent_id": 2,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Iteratively improved solution by \n    - pushing outer ring centers outward,\n    - moving the 26th circle to a corner,\n    - slightly increasing expansion ratios,\n    - and performing an additional expand pass.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.22 * np.cos(angle), 0.5 + 0.22 * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring) -- push slightly further out\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.41 * np.cos(angle), 0.5 + 0.41 * np.sin(angle)]\n    \n    # Move the 'extra' circle to a corner\n    centers[25] = [0.125, 0.125]\n    \n    r_min = 0.008  # to avoid degeneracy\n\n    # Set initial radii to distance to the closest wall\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.99  # 99% to avoid touching border (slightly less conservative)\n    \n    # Shrink radii for pairs that would overlap, but only shrink the larger one (greedier)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            allowed_sum = dist * 0.99  # tight gap\n            if radii[i] + radii[j] > allowed_sum:\n                # Only shrink the bigger one\n                if radii[i] > radii[j]:\n                    radii[i] = allowed_sum - radii[j]\n                else:\n                    radii[j] = allowed_sum - radii[i]\n                # If either falls below r_min, keep min\n                radii[i] = max(r_min, radii[i])\n                radii[j] = max(r_min, radii[j])\n\n    # Greedy expand: for each, try to push it to maximal possible radius\n    for _ in range(2):  # Do two passes instead of one\n        for i in range(n):\n            # Limit by distance to border\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Limit by distance to any other circle\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.99))\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.7614151786090209,
      "additional_data": {
        "sum_radii": "1.761415",
        "target_ratio": "0.668469",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 20,
    "parent_id": 2,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Slightly improved arrangement and iterative radius maximization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles (inner ring), slightly nudged outward\n    r_inner = 0.25\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring), slightly expanded\n    r_outer = 0.415\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n    \n    # One additional circle: placed near top edge\n    centers[25] = [0.5, 0.89]  # moved a bit closer to border\n    \n    r_min = 0.008\n    \n    # Initial radii: distance to closest wall (no scaling yet)\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.992  # less conservative than 0.98\n    \n    # First overlap resolution pass (more gentle)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < 1e-8:\n                continue\n            if radii[i] + radii[j] > dist * 0.997:  # shrink less aggressively\n                scale = (dist * 0.997) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    # Multiple greedy improvement passes (expand radii)\n    for _ in range(4):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.995))  # expand a little more with 0.995\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.5658759514306702,
      "additional_data": {
        "sum_radii": "1.565876",
        "target_ratio": "0.594260",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 21,
    "parent_id": 12,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    SMALL ITERATIVE IMPROVEMENT:\n    - Use 16 circles on the outer ring (was 15)\n    - Slightly increase outer ring radius\n    - Place three 'corner' circles, not just two, and push even closer to the corners\n    - Add one extra expansion pass for radii\n    - Push centers outward slightly at the end, then rerun last radius optimization\n    - Tighten the allowed pairwise distance further in radii constraints\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Inner ring of 8 circles \n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.22 * np.cos(angle), 0.5 + 0.22 * np.sin(angle)]\n    \n    # Outer ring: 16 circles (was 15), slightly larger radius (was 0.415)\n    outer_ring_r = 0.427  \n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # Three corner-walker circles, pushed closer to corners\n    margin = 0.085\n    centers[25-2] = [margin, margin]\n    centers[25-1] = [1-margin, 1-margin]\n    centers[25]   = [margin, 1-margin]\n    \n    r_min = 0.008  # avoid degeneracy\n\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.990  # shrink less, be more aggressive\n\n    # Pairwise distance pass, even tighter (0.995 instead of 0.997)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.995:\n                scale = (dist * 0.995) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # Greedy expansion, 6 passes (was 5), and tighter wall margin\n    for pass_num in range(6):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.995))\n            \n    # Final push: move all circles slightly outward from center, then do last radius expand\n    center_pt = np.array([0.5, 0.5])\n    for i in range(1, n):  # skip the central circle\n        vec = centers[i] - center_pt\n        norm = np.linalg.norm(vec)\n        if norm > 1e-7:\n            push = 0.003 * (vec / norm)\n            centers[i] += push\n            # Clamp to [0,1]\n            centers[i][0] = min(max(centers[i][0], 0.0), 1.0)\n            centers[i][1] = min(max(centers[i][1], 0.0), 1.0)\n\n    # Repeat one last greedy radius expand to fill any gained margin\n    for i in range(n):\n        max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n        for j in range(n):\n            if i == j:\n                continue\n            d = np.linalg.norm(centers[i] - centers[j])\n            if d > 1e-8:\n                max_r = min(max_r, d - radii[j])\n        radii[i] = max(r_min, min(radii[i], max_r*0.995))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.7594865124702888,
      "additional_data": {
        "sum_radii": "1.759487",
        "target_ratio": "0.667737",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 22,
    "parent_id": 13,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Outer ring radius increased to 0.455\n    - Redistribute extra circles toward (0.09,0.09) and (0.91,0.91)\n    - Use 0.998 for initial boundary/overlap shrinkage\n    - Use 0.997 for greedy maximization\n    - Raise greedy passes to 15\n    - Slightly increase inner ring radius to 0.235\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles\n    r_inner = 0.235\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n\n    # Outer ring of 15 circles\n    r_outer = 0.455\n    for i in range(15):\n        angle = 2 * np.pi * i / 15\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n\n    # Two extra circles, placed near diagonally opposed corners\n    centers[24] = [0.09, 0.09]\n    centers[25] = [0.91, 0.91]\n\n    r_min = 0.008  # Prevent degeneration\n\n    # Initial radii: fit to walls, less conservative\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.998\n\n    # Initial shrink for overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.998:\n                scale = (dist * 0.998) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # More aggressive greedy maximium: 15 passes and finer margin\n    for pass_num in range(15):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.997))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.7125807078048745,
      "additional_data": {
        "sum_radii": "1.712581",
        "target_ratio": "0.649936",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 23,
    "parent_id": 13,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    SMALL ITERATIVE IMPROVEMENT:\n    - Place 4 'extra' circles toward corners, not just top/bottom\n    - Slightly increase inner/outer ring radius\n    - Slightly decrease shrink factor to 0.998\n    - One last tiny greedy maximization at the end (1 pass at 0.997)\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles (slightly increased radius)\n    r_inner = 0.235\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n\n    # Outer ring of 14 circles (slightly increased radius, one less than before)\n    r_outer = 0.455\n    for i in range(14):\n        angle = 2 * np.pi * i / 14\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n    \n    # 4 extra circles, toward each corner (0.16,0.16 ... 0.84,0.84 etc)\n    corner_offset = 0.16\n    centers[23] = [corner_offset, corner_offset]\n    centers[24] = [corner_offset, 1 - corner_offset]\n    centers[25] = [1 - corner_offset, corner_offset]\n    centers[22] = [1 - corner_offset, 1 - corner_offset]\n\n    r_min = 0.008  # anti-degeneracy\n    \n    # Initial radii: as large as can fit vs wall, less conservative\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.998\n\n    # Initial shrink for overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.998:\n                scale = (dist * 0.998) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # More aggressive greedy maximium: 10 passes and less margin\n    for pass_num in range(10):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.998))\n    \n    # Final tight greedy maximization\n    for i in range(n):\n        max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n        for j in range(n):\n            if j == i:\n                continue\n            d = np.linalg.norm(centers[i] - centers[j])\n            if d > 1e-8:\n                max_r = min(max_r, d - radii[j])\n        radii[i] = max(r_min, min(radii[i], max_r*0.997))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.268330795555018,
      "additional_data": {
        "sum_radii": "1.268331",
        "target_ratio": "0.481340",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 24,
    "parent_id": 14,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement: increase ring radii slightly,\n    push the 26th circle even closer to top boundary,\n    and relax overlap margins very slightly.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Increase ring radii just a bit for denser packing\n    inner_ring_r = 0.252  # +0.002 from previous\n    outer_ring_r = 0.430  # +0.002 from previous\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # 26th circle: push slightly closer to top boundary\n    centers[25] = [0.5, 0.916]  # from 0.91\n\n    r_min = 0.008\n\n    # Initial radii: maximize to squares, less safety margin\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.987  # slightly less cautious than before (was 0.985)\n    \n    # Improved proximity shrink: shrink only the bigger of a too-close pair\n    for it in range(4):  # more passes\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * 0.996:  # even less margin\n                    # Only shrink the larger radius\n                    if radii[i] > radii[j]:\n                        radii[i] = max(r_min, dist * 0.996 - radii[j])\n                    else:\n                        radii[j] = max(r_min, dist * 0.996 - radii[i])\n\n    # More careful expansion pass for each circle\n    for iter_expand in range(4):  # More expansion sweeps\n        for i in range(n):\n            # Distance to wall constraint\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            # Even less safety margin\n            radii[i] = max(r_min, min(radii[i], max_r * 0.996))\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "invalid",
        "error": "Invalid packing (overlaps or out of bounds)"
      }
    }
  },
  {
    "id": 25,
    "parent_id": 11,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    # Slightly larger initial radius than before\n    r_init = 0.035  \n    \n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n    \n    # First shell: 8\n    R1 = 0.21\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n        \n    # Second shell: 12\n    R2 = 0.41\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/12)  # Break symmetry for more efficient coverage\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 5 circles close-ish to corners, each sitting in a gap of the previous shell, but not too close.\n    corners = np.array([\n        [0.07, 0.07],\n        [0.93, 0.07],\n        [0.93, 0.93],\n        [0.07, 0.93],\n        [0.5, 0.93]\n    ])\n    for i in range(5):\n        centers[idx] = corners[i]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n    \n    max_iters = 53\n    grow_amt = 0.03\n    for it in range(max_iters):\n        # Shrink inflation step slowly as system settles\n        inflation = grow_amt * (1 - it / max_iters) * 0.9 + 0.004\n        \n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation (random ordering for more local max escape)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n    \n    # Border enforcement\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        if radii[i] > max_r:\n            radii[i] = max(0, max_r)\n\n    radii = np.clip(radii, 0, None)\n    sum_radii = np.sum(radii)\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 2.212694512852617,
      "additional_data": {
        "sum_radii": "2.212695",
        "target_ratio": "0.839732",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 26,
    "parent_id": 13,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Increase outer ring radius to 0.455 (pushes circles toward corners).\n    - Move the 2 'extra' circles near (0.12,0.12) and (0.88,0.88) (better corner usage).\n    - Use greedy maximization for 15 passes (finer tuning).\n    - Use 0.996 for overlap/boundary margin (less conservative).\n    - Lower r_min slightly to 0.006 to allow smaller circles if needed.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles\n    r_inner = 0.23\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n\n    # Outer ring of 15 circles\n    r_outer = 0.455  # previously 0.445\n    for i in range(15):\n        angle = 2 * np.pi * i / 15\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n\n    # Two extra circles, moved to better use the corners\n    centers[24] = [0.12, 0.12]\n    centers[25] = [0.88, 0.88]\n\n    r_min = 0.006  # anti-degeneracy, slightly smaller\n\n    # Initial radii: start as large as can fit vs wall, use more aggressive margin\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.996\n\n    # Initial shrink for overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.996:\n                scale = (dist * 0.996) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # Increase greedy maximum passes and use less margin\n    for pass_num in range(15):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.996))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.6199117857202636,
      "additional_data": {
        "sum_radii": "1.619912",
        "target_ratio": "0.614767",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 27,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    r_init = 0.033   # Slightly smaller, to allow tighter initial fit\n\n    centers = np.zeros((n, 2))\n    idx = 0\n    # Center\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n\n    # First shell: 8, slightly farther out\n    R1 = 0.218\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n\n    # Second shell: 12, farther out and slightly offset\n    R2 = 0.425\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi / 12)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: \"cornerish\"/edge-filling, nudge closer to edges but not exactly at them\n    # (This allows their radii to grow slightly more before hitting the boundary.)\n    # Positions spaced outside the shells, avoid exact corners.\n    corners = np.array([\n        [0.10, 0.081],\n        [0.91, 0.081],\n        [0.91, 0.91],\n        [0.081, 0.91],\n        [0.50, 0.94],\n    ])\n    for i in range(5):\n        centers[idx] = corners[i]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n\n    max_iters = 65     # slightly more growth/inflation iters\n    grow_amt = 0.028   # slighter smaller, for less overshoot\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.95 + 0.0035\n\n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n        # 3. Inflation (random order)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n\n    # Final clean-up: shrink any outside bounds and overlap cull, 2 passes.\n    for repeat in range(2):\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-10:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-11:\n                        shrink_i = radii[i] / total * overlap\n                        shrink_j = radii[j] / total * overlap\n                        radii[i] -= shrink_i\n                        radii[j] -= shrink_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n    # Enforce border again\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        if radii",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 28,
    "parent_id": 24,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Use a slightly larger margin in shrink passes (from 0.996 \u2192 0.993)\n    - When two circles overlap, shrink both, not just the larger\n    - After expansion, apply a final conservative shrink to all radii\n    - Move the 26th circle a bit lower (from 0.916 \u2192 0.89)\n    \"\"\"\n\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    inner_ring_r = 0.252\n    outer_ring_r = 0.430\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # 26th circle moved slightly lower\n    centers[25] = [0.5, 0.89]\n\n    r_min = 0.008\n\n    # Initial radii: maximize to box with very small initial margin\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.985\n\n    # Improved shrink pass: shrink both circles if they're too close, use slightly more margin\n    for it in range(6):  # more iterations for stability\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                margin = 0.993\n                if radii[i] + radii[j] > dist * margin:\n                    over = (radii[i] + radii[j] - dist * margin)\n                    # Shrink both radii proportionally\n                    sum_rij = radii[i] + radii[j]\n                    if sum_rij > 0:\n                        frac_i = radii[i] / sum_rij\n                        frac_j = radii[j] / sum_rij\n                        radii[i] = max(r_min, radii[i] - over * frac_i)\n                        radii[j] = max(r_min, radii[j] - over * frac_j)\n                    else:\n                        radii[i] = r_min\n                        radii[j] = r_min\n\n    # Expansion with careful margin, but not exceeding wall nor neighbor\n    for iter_expand in range(5):\n        for i in range(n):\n            # Max allowed radius due to wall\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            # More conservative margin\n            radii[i] = max(r_min, min(radii[i], max_r * 0.993))\n\n    # Final conservative shrink for all (guarantee margin, account for all numerical issues)\n    radii *= 0.990\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.6544095586449665,
      "additional_data": {
        "sum_radii": "1.654410",
        "target_ratio": "0.627859",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 29,
    "parent_id": 17,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved version: Robust corner radii, no destructive shrinking.\n    Only expand, then do careful global adjustment at the end.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    # Central circle\n    centers[0] = [0.5, 0.5]\n    # Inner ring of 8 circles\n    inner_ring_r = 0.22\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    # Outer ring of 15 circles, maximize possible outer_ring_r so all circles' centers stay in bounds\n    outer_ring_angles = [2 * np.pi * i / 15 for i in range(15)]\n    max_r_list = []\n    for angle in outer_ring_angles:\n        cos_a = np.cos(angle)\n        sin_a = np.sin(angle)\n        if abs(cos_a) > 1e-12:\n            if cos_a > 0:\n                rx = (1 - 0.5) / cos_a\n            else:\n                rx = (0 - 0.5) / cos_a\n        else:\n            rx = np.inf\n        if abs(sin_a) > 1e-12:\n            if sin_a > 0:\n                ry = (1 - 0.5) / sin_a\n            else:\n                ry = (0 - 0.5) / sin_a\n        else:\n            ry = np.inf\n        max_r = min(rx, ry)\n        # Should be between 0 and 0.5\n        if max_r < 0 or max_r > 0.5:\n            max_r = 0.5\n        max_r_list.append(max_r)\n    outer_ring_r = min(max_r_list) * 0.983  # as before\n\n    for idx, angle in enumerate(outer_ring_angles):\n        centers[9 + idx] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    # The two corner circles - maximize their radii at placement!\n\n    # Place circle in (margin, margin)\n    cA = np.array([0.125, 0.125])\n    # Place circle in (1 - margin, 1 - margin)\n    cB = np.array([0.875, 0.875])\n\n    centers[24] = cA\n    centers[25] = cB\n\n    r_min = 0.008  # avoid degeneracy\n\n    # **Key improvement:** start with small radii for expansion (no initial maximal attempt)\n    radii = np.full(n, 0.035)\n\n    # Greedy expansion passes: expand each circle up to wall/neighbor\n    for pass_num in range(13):  # more passes for tighter packing\n        for i in range(n):\n            # Maximum radius allowed by border\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-10:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.99))\n\n    # Global \"final pass\": fix any overlaps or out-of-bounds in a few conservative passes\n    for fin_pass in range(5):\n        for i in range(n):\n            # stay in bounds\n            radii[i] = min(radii[i], centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n        # fix pairwise overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > d - 1e-12:\n                    # Equitably shrink both\n                    excess = (radii[i] + radii[j]) - d\n                    cut = 0.52*excess\n                    radii[i] = max(r_min, radii[i] - cut)\n                    radii[j] = max(r_min, radii[j] - cut)\n\n    # Safety check: set invalid radii to r_min\n    for i in range(n):\n        if radii[i] < r_min or np.isnan(radii[i]) or np.isinf(radii[i]):\n            radii[i] = r_min\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 0.7749217597327528,
      "additional_data": {
        "sum_radii": "0.774922",
        "target_ratio": "0.294088",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 30,
    "parent_id": 3,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small improvement: tweak ring counts, make outer ring elliptical toward corners, more expansion, squeeze margins.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # 1 center\n    centers[0] = [0.5, 0.5]\n    \n    # Arrange: 10-inner, 15-outer\n    inner_count = 10\n    outer_count = 15\n    assert 1 + inner_count + outer_count == n\n    \n    # Slightly larger rings than before\n    inner_ring_r = 0.247\n    outer_ring_rx = 0.415   # horizontal outer radius\n    outer_ring_ry = 0.423   # vertical outer radius (slight ellipse)\n    \n    # Inner ring (centered, circular)\n    for i in range(inner_count):\n        angle = 2 * np.pi * i / inner_count\n        centers[1 + i] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Outer ring (elliptical stretching to corners)\n    for i in range(outer_count):\n        angle = 2 * np.pi * i / outer_count\n        cx = 0.5 + outer_ring_rx * np.cos(angle)\n        cy = 0.5 + outer_ring_ry * np.sin(angle)\n        centers[1 + inner_count + i] = [cx, cy]\n\n    r_min = 0.008\n\n    # Squeeze wall factor a little tighter\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.995  # Reduce border margin\n\n    # Improved proximity shrink: shrink only the bigger of a too-close pair (3 passes, tighter threshold)\n    for it in range(3):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * 0.995:\n                    # Only shrink the larger radius\n                    if radii[i] > radii[j]:\n                        radii[i] = max(r_min, dist * 0.995 - radii[j])\n                    else:\n                        radii[j] = max(r_min, dist * 0.995 - radii[i])\n\n    # Expansion pass for each circle (3 times for more even fill)\n    for iter_expand in range(3):\n        for i in range(n):\n            # Distance to wall constraint\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            # Safety margin\n            radii[i] = max(r_min, min(radii[i], max_r * 0.995))\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.6508264663181946,
      "additional_data": {
        "sum_radii": "1.650826",
        "target_ratio": "0.626500",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 31,
    "parent_id": 22,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Further iterative improvement:\n    - Outer ring radius to 0.465\n    - r_inner slightly increased to 0.237\n    - Initial boundary/overlap shrinkage to 0.9992\n    - Greedy margin to 0.998\n    - Raise greedy passes to 25\n    - Corner circles pushed closer to (0.07,0.07) and (0.93,0.93)\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles\n    r_inner = 0.237\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n\n    # Outer ring of 15 circles\n    r_outer = 0.465\n    for i in range(15):\n        angle = 2 * np.pi * i / 15\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n\n    # Two extra circles, slightly nearer to corners now\n    centers[24] = [0.07, 0.07]\n    centers[25] = [0.93, 0.93]\n\n    r_min = 0.008  # Prevent degeneration\n\n    # Initial radii: fit to walls, less conservative\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.9992\n\n    # Initial shrink for overlaps (more generous scaling)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.9992:\n                scale = (dist * 0.9992) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # More aggressive greedy maximium: 25 passes, less conservative margin\n    for pass_num in range(25):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.998))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.7054229448391682,
      "additional_data": {
        "sum_radii": "1.705423",
        "target_ratio": "0.647219",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 32,
    "parent_id": 16,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Parameters\n    r_min = 0.008\n    eps = 1e-5\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    # Inner ring of 8 circles\n    inner_ring_r = 0.22\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Outer ring for 15 circles: Make sure each center is strictly within [0,1]\n    outer_ring_angles = [2 * np.pi * i / 15 for i in range(15)]\n    # For safety, let's use a slightly smaller ring than geometric max\n    wall_margin = 0.035  # slightly bigger than before\n    outer_ring_r = 0.5 - wall_margin - r_min  # safe value\n    for idx, angle in enumerate(outer_ring_angles):\n        cx = 0.5 + outer_ring_r * np.cos(angle)\n        cy = 0.5 + outer_ring_r * np.sin(angle)\n        centers[9 + idx] = [cx, cy]\n    \n    # Place 2 extra circles in opposite corners (not at margin, but at maximal)\n    corner_r = 0.5 - wall_margin - r_min*2\n    centers[24] = [corner_r, corner_r]\n    centers[25] = [1 - corner_r, 1 - corner_r]\n    \n    # Compute initial radii: the minimum of distance to border (leave gap for safety)\n    # calculate for each circle\n    radii = np.zeros(n)\n    safety = 0.97  # shrink for safety vs wall\n    for i in range(n):\n        x, y = centers[i]\n        wall_d = min(x, y, 1-x, 1-y)\n        radii[i] = max(r_min, wall_d * safety)\n    \n    # Make sure no radius is zero\n    for i in range(n):\n        if radii[i] <= r_min:\n            # try shifting center towards the middle\n            if i < 24:\n                centers[i] = 0.5 + 0.45 * (centers[i] - 0.5)\n                x, y = centers[i]\n                wall_d = min(x, y, 1-x, 1-y)\n                radii[i] = max(r_min, wall_d * safety)\n            else:\n                # Corners: move closer in\n                centers[i] = 0.5 + 0.40 * (centers[i] - 0.5)\n                x, y = centers[i]\n                wall_d = min(x, y, 1-x, 1-y)\n                radii[i] = max(r_min, wall_d * safety)\n    \n    # Pairwise shrinking for overlap avoidance (only if really needed)\n    shrink_margin = 0.995\n    for _ in range(5):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < 1e-10:\n                    continue\n                if radii[i] + radii[j] > dist * shrink_margin:\n                    excess = (radii[i] + radii[j]) - dist * shrink_margin\n                    # Shrink both proportionally, but never below r_min\n                    share = excess / 2\n                    if radii[i] - share >= r_min and radii[j] - share >= r_min:\n                        radii[i] -= share\n                        radii[j] -= share\n                    else:\n                        # if one is at minimum, shrink from the other\n                        if radii[i] > radii[j]:\n                            shrink_i = min(radii[i] - r_min, excess)\n                            radii[i] -= shrink_i\n                            radii[j] -= (excess - shrink_i)\n                        else:\n                            shrink_j = min(radii[j] - r_min, excess)\n                            radii[j] -= shrink_j\n                            radii[i] -= (excess - shrink_j)\n                    # Re-guard against r_min\n                    radii[i] = max(r_min, radii[i])\n                    radii[j] = max(r_min, radii[j])\n    \n    # Final pass: greedily expand circles to wall & neighbors\n    for _ in range(4):\n        for i in range(n):\n            # Max allowable by wall\n            maxr = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1]) * safety\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 33,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    centers = np.zeros((n, 2))\n    idx = 0\n    # Center\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n    \n    # First shell: 8\n    R1 = 0.21\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n\n    # Second shell: 12, slightly further out\n    R2 = 0.43\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi / 12)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 5 (corners and closer to mid-edge)\n    # Move corners a bit inward for slightly larger allowed radii\n    corners = np.array([\n        [0.09, 0.09],\n        [0.91, 0.09],\n        [0.91, 0.91],\n        [0.09, 0.91],\n        [0.5, 0.92]\n    ])\n    for i in range(5):\n        centers[idx] = corners[i]\n        idx += 1\n\n    # Variable initial radii: central/shell1 = 0.033, shell2/corners=0.038\n    radii = np.zeros(n)\n    radii[0] = 0.033 # center\n    radii[1:9] = 0.033 # 8 in first shell\n    radii[9:21] = 0.038 # 12 in second shell\n    radii[21:] = 0.038 # 5 last, corners\n\n    max_iters = 70\n    grow_amt = 0.03\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.9 + 0.004\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # Inflation, random order\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final gentle inflation steps, 2 more times at lower rate to \"polish\"\n    for polish_iter in range(2):\n        inflation = 0.006 / (polish_iter+1)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n        # Final overlap resolution pass\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-11:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        shrink_i = radii[i] / total * overlap\n                        shrink_j = radii[j] / total",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 34,
    "parent_id": 12,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Move corner circles slightly closer to corners (margin=0.09)\n    - Use 7 greedy passes to expand radii instead of 5\n    - After expansion, one last final pass: for each circle (random order), expand to maximum possible given other circles\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.22 * np.cos(angle), 0.5 + 0.22 * np.sin(angle)]\n    \n    # Slightly larger radius for outer ring (0.415)\n    outer_ring_r = 0.415\n    for i in range(15):\n        angle = 2 * np.pi * i / 15\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # Two extra circles: place toward (but closer to) corners\n    margin = 0.09\n    centers[24] = [margin, margin]\n    centers[25] = [1 - margin, 1 - margin]\n    \n    r_min = 0.008  # avoid degeneracy\n    \n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.992\n\n    # Limit by pairwise distances, shrinking both if needed\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.997:\n                scale = (dist * 0.997) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # More greedy passes to expand each radius more thoroughly\n    for pass_num in range(7):  # increased from 5 to 7\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.997))\n    \n    # Final pass: try to grow each circle as far as possible in a random order\n    order = np.random.permutation(n)\n    for idx in order:\n        max_r = min(centers[idx][0], centers[idx][1], 1 - centers[idx][0], 1 - centers[idx][1])\n        for j in range(n):\n            if idx == j:\n                continue\n            d = np.linalg.norm(centers[idx] - centers[j])\n            if d > 1e-8:\n                max_r = min(max_r, d - radii[j])\n        radii[idx] = max(r_min, min(radii[idx], max_r * 0.997))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.7886087045347596,
      "additional_data": {
        "sum_radii": "1.788609",
        "target_ratio": "0.678789",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 35,
    "parent_id": 22,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvements:\n    - Outer ring radius increased to 0.458\n    - Corner circles nudged further to (0.085,0.085) and (0.915,0.915)\n    - Initial overlap shrink uses 0.999\n    - Greedy maximization factor to 0.998\n    - Passes increased from 15 to 18\n    - Lower r_min to 0.006\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles\n    r_inner = 0.235\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n\n    # Outer ring of 15 circles\n    r_outer = 0.458\n    for i in range(15):\n        angle = 2 * np.pi * i / 15\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n\n    # Two extra circles, placed near diagonally opposed corners, nudged\n    centers[24] = [0.085, 0.085]\n    centers[25] = [0.915, 0.915]\n\n    r_min = 0.006  # Prevent degeneration\n\n    # Initial radii: fit to walls, less conservative\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.998\n\n    # Initial shrink for overlaps - less conservative\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.999:\n                scale = (dist * 0.999) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # More greedy maximium: 18 passes and slightly finer margin\n    for pass_num in range(18):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.998))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.7076091126879087,
      "additional_data": {
        "sum_radii": "1.707609",
        "target_ratio": "0.648049",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 36,
    "parent_id": 10,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # 1 center\n    centers[0] = [0.5, 0.5]\n\n    # 8 in inner ring (radius 0.24)\n    for i in range(8):\n        angle = 2*np.pi*i/8\n        centers[1+i] = [0.5+0.24*np.cos(angle), 0.5+0.24*np.sin(angle)]\n    \n    # 12 in middle ring (radius 0.415)\n    for i in range(12):\n        angle = 2*np.pi*i/12\n        centers[9+i] = [0.5+0.415*np.cos(angle), 0.5+0.415*np.sin(angle)]\n    \n    # 5 at corners (pushed in a bit from the literal corner; spreads better)\n    corner_offsets = np.array([\n        [0.08, 0.08],    # near (0,0)\n        [0.92, 0.08],    # near (1,0)\n        [0.92, 0.92],    # near (1,1)\n        [0.08, 0.92],    # near (0,1)\n        [0.5, 0.05]      # bottom edge center-ish\n    ])\n    centers[21:26] = corner_offsets\n\n    # Expand allowed \"hugging\" to borders\n    centers = np.clip(centers, 0.07, 0.93)\n\n    # Start with slightly larger radii, as now near edges there's more room\n    radii = np.ones(n) * 0.041\n\n    # More inflation rounds; shuffle the order each time for greedy bias reduction\n    for _ in range(18):\n        idxs = np.random.permutation(n)\n        for i in idxs:\n            x, y = centers[i]\n            max_r = min(x, y, 1-x, 1-y)\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j] - 1e-7)\n            radii[i] = max(max_r, 1e-6)\n    radii = np.clip(radii, 1e-7, 1.0)\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.159187806492713,
      "additional_data": {
        "sum_radii": "2.159188",
        "target_ratio": "0.819426",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 37,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    # Slightly larger initial radius\n    r_init = 0.038\n    \n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n    \n    # First shell: 8\n    R1 = 0.214\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n        \n    # Second shell: 12, bring a bit closer in\n    R2 = 0.385\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/12)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 5 circles, place 2 on side centers, 3 in corners\n    border_pts = np.array([\n        [0.07, 0.07],\n        [0.93, 0.07],\n        [0.93, 0.93],\n        [0.07, 0.93],\n        [0.5, 0.95], # center-top\n    ])\n    for i in range(5):\n        centers[idx] = border_pts[i]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n    \n    max_iters = 64\n    grow_amt = 0.032\n    for it in range(max_iters):\n        # Shrink inflation step slowly as system settles\n        inflation = grow_amt * (1 - it / max_iters) * 0.9 + 0.0045\n        \n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation (random ordering for more local max escape)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n    \n    # Border enforcement\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        if radii[i] > max_r:\n            radii[i] = max(0, max_r)\n\n    radii = np.clip(radii, 0, None)\n    sum_radii = np.sum(radii)\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 2.184259128862296,
      "additional_data": {
        "sum_radii": "2.184259",
        "target_ratio": "0.828941",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 38,
    "parent_id": 8,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Iteratively improved arrangement of 26 circles in unit square to maximize sum of radii.\n    Small improvement: perturbs outer ring to corners, seeds radii non-uniformly,\n    increases regrowth rate and number of passes.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Circle pattern: 1 center, 8 first ring, 17 outer ring\n    centers[0] = [0.5, 0.5]\n    # First ring (radius from center): radius 0.23\n    R1 = 0.23\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[1 + i] = [0.5 + R1 * np.cos(angle), 0.5 + R1 * np.sin(angle)]\n    # Outer ring: radius 0.39, 17 circles for slight overlap fill\n    R2 = 0.39\n    for i in range(17):\n        # Small perturbations for corner packing\n        angle = 2 * np.pi * i / 17\n        # For 4 outer-ring circles closest to each corner, nudge toward corner\n        corner_boost = 0.02 if (i % (17//4) == 0 or (i+1) % (17//4) == 0) else 0\n        # Slight \"squaring\" to push some closer to corners\n        stretch_x = 1 + 0.08 * np.cos(angle)**4\n        stretch_y = 1 + 0.08 * np.sin(angle)**4\n        x = 0.5 + (R2 + corner_boost) * np.cos(angle) * stretch_x\n        y = 0.5 + (R2 + corner_boost) * np.sin(angle) * stretch_y\n        # Clamp within square if nudged outside\n        x = np.clip(x, 0.01, 0.99)\n        y = np.clip(y, 0.01, 0.99)\n        centers[9 + i] = [x, y]\n\n    # Non-uniform initial radii: larger on outer cells, less at center\n    radii = np.ones(n) * 0.047\n    radii[0] = 0.045  # center, slightly smaller, to allow better regrowth\n    radii[1:9] = 0.049  # first ring\n    radii[9:] = 0.052   # outer ring circles start larger\n\n    # Run more repair/growth cycles, larger growth step\n    for pass_outer in range(16):\n        # Shrink out-of-bounds\n        for i in range(n):\n            x, y = centers[i]\n            r_max = min(x, y, 1 - x, 1 - y)\n            radii[i] = min(radii[i], r_max)\n\n        # Overlap shrink\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = centers[i] - centers[j]\n                d = np.hypot(dx, dy)\n                sep = radii[i] + radii[j]\n                if d < sep - 1e-12:\n                    excess = sep - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        shrink_i = radii[i] / total * excess\n                        shrink_j = radii[j] / total * excess\n                        radii[i] -= shrink_i\n                        radii[j] -= shrink_j\n                        radii[i] = max(0, radii[i])\n                        radii[j] = max(0, radii[j])\n\n        # Local greedy regrowth with slightly bigger step\n        for i in range(n):\n            x, y = centers[i]\n            maxr = min(x, y, 1 - x, 1 - y)\n            for j in range(n):\n                if i == j:\n                    continue\n                dx, dy = centers[i] - centers[j]\n                d = np.hypot(dx, dy)\n                # Watch out for tiny d causing negative limit\n                if d > radii[j] + 1e-12:\n                    limit = d - radii[j]\n                    maxr = min(maxr, limit)\n            radii[i] = max(0.0, min(radii[i] + 0.004, maxr))  # Larger step than before\n\n    # Final regrowth for any last slack\n    for i in range(n):\n        x, y = centers[i]\n        maxr = min(x, y, 1 - x, 1 - y)\n        for j in range(n):\n            if i == j:\n                continue\n            dx, dy = centers[i] - centers[j]\n            d = np.hypot(dx, dy)\n            if d > radii[j] + 1e-12:\n                limit = d - radii[j]\n                maxr = min(maxr, limit)\n        radii[i] = np.clip(maxr, 0, 1)\n\n    # Correct any boundary violations\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        if r > min(x, y, 1 - x, 1 - y):\n            radii[i] = max(0, min(r, x, y, 1-x, 1-y))\n\n    # Final overlap repair\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx, dy = centers[i] - centers[j]\n            d = np.hypot(dx, dy)\n            sep = radii[i] + radii[j]\n            if d < sep - 1e-8:\n                excess = sep - d\n                total = radii[i] + radii[j]\n                if total",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 39,
    "parent_id": 33,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    centers = np.zeros((n, 2))\n    idx = 0\n    # Center\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n    \n    # First shell: 8\n    R1 = 0.21\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n\n    # Second shell: 12, slightly further out\n    R2 = 0.43\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi / 12)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 5 (corners and closer to mid-edge)\n    corners = np.array([\n        [0.09, 0.09],\n        [0.91, 0.09],\n        [0.91, 0.91],\n        [0.09, 0.91],\n        [0.5, 0.92]\n    ])\n    for i in range(5):\n        centers[idx] = corners[i]\n        idx += 1\n\n    # Variable initial radii: central/shell1 = 0.033, shell2/corners=0.038\n    radii = np.zeros(n)\n    radii[0] = 0.033 # center\n    radii[1:9] = 0.033 # 8 in first shell\n    radii[9:21] = 0.038 # 12 in second shell\n    radii[21:] = 0.038 # 5 last, corners\n\n    max_iters = 70\n    grow_amt = 0.03\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.9 + 0.004\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # Inflation, random order\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final gentle inflation steps, 2 more times at lower rate to \"polish\"\n    for polish_iter in range(2):\n        inflation = 0.006 / (polish_iter+1)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n        # Final overlap resolution pass\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-11:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        shrink_i = radii[i] / total * overlap\n                        shrink_j = radii[j] / total * overlap\n                        radii[i] -= shrink_i\n                        radii[j] -= shrink_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n    # Clamp final radii to domain constraints\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1-x, 1-y)\n        radii[i] = max(radii[i], 0)\n    # Make sure types are correct, output is valid\n    centers = np.asarray(centers)\n    radii = np.asarray(radii)\n    sum_radii = np.sum(radii)\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 1.9907926994530358,
      "additional_data": {
        "sum_radii": "1.990793",
        "target_ratio": "0.755519",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 40,
    "parent_id": 12,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement over previous solution:\n    - Outer ring: 16 circles, radius 0.425\n    - Corner margin: 0.11\n    - No initial conservative contraction of radii\n    - More greedy passes (8)\n    - Increased pairwise battle margin (0.999)\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Center\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring: 8 circles radius 0.22 as before\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.22 * np.cos(angle), 0.5 + 0.22 * np.sin(angle)]\n\n    # Outer ring: 16 circles on a slightly larger ring (0.425)\n    outer_ring_r = 0.425\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # Two extra circles toward the corners, with reduced margin\n    margin = 0.11\n    centers[25 - 1] = [margin, margin]\n    centers[25] = [1 - margin, 1 - margin]\n\n    r_min = 0.008  # avoid degeneracy\n\n    # Set initial radii just to touch closest wall\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n\n    # Limit by pairwise distances, shrinking both if needed (now with tighter safety)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.999:\n                scale = (dist * 0.999) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # More greedy passes to try to reclaim slack\n    for pass_num in range(8):\n        for i in range(n):\n            # Max by border\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.999))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.6592645455953434,
      "additional_data": {
        "sum_radii": "1.659265",
        "target_ratio": "0.629702",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 41,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    r_init = 0.037 # Slightly increased initial radius\n    \n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n    \n    # First shell: 8 circles at a slightly larger radius\n    R1 = 0.22\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n        \n    # Second shell: 12 circles, R2 tweaked to be slightly closer (more compact but not too close)\n    R2 = 0.395\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/12)  # As before: break symmetry\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 5 circles, slightly shifted closer to edges, add jitter to avoid perfect symmetry\n    rng = np.random.default_rng(42)  # fixed seed for reproducibility\n    corners = np.array([\n        [0.09, 0.09],\n        [0.91, 0.08],\n        [0.91, 0.925],\n        [0.1, 0.92],\n        [0.5 + 0.02*rng.uniform(-1,1), 0.94],\n    ])\n    # Add small jitter to positions (break symmetry)\n    corners += rng.uniform(-0.012, 0.012, corners.shape)\n    for i in range(5):\n        centers[idx] = corners[i]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n    \n    max_iters = 75\n    grow_amt = 0.025\n    for it in range(max_iters):\n        # Shrink inflation step slowly as system settles\n        inflation = grow_amt * (1 - it / max_iters) * 0.95 + 0.0035\n        \n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation (random ordering for more local max escape)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n    \n    # Border enforcement\n    for i in range(n):\n        x,",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 42,
    "parent_id": 28,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Slightly increase initial scale for radii: 0.985 \u2192 0.989\n    - More passes: increase shrink and expand loops (6\u21928)\n    - Shrink/expand margin: expansion now at 0.995\n    - Inner ring nudged wider (0.252\u21920.256), outer ring in (0.430\u21920.425)\n    - Move 26th circle up slightly: y=0.89 \u2192 0.90\n    \"\"\"\n\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    inner_ring_r = 0.256  # nudged wider\n    outer_ring_r = 0.425  # nudged in a bit\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # 26th circle moved slightly up\n    centers[25] = [0.5, 0.90]\n\n    r_min = 0.008\n\n    # Initial radii: maximize to box with very small initial margin\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.989  # slightly more aggressive use of initial space\n\n    # Improved shrink pass: shrink both circles if they're too close, use slightly more margin\n    for it in range(8):  # more shrink iterations for stability\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                margin = 0.993\n                if radii[i] + radii[j] > dist * margin:\n                    over = (radii[i] + radii[j] - dist * margin)\n                    # Shrink both radii proportionally\n                    sum_rij = radii[i] + radii[j]\n                    if sum_rij > 0:\n                        frac_i = radii[i] / sum_rij\n                        frac_j = radii[j] / sum_rij\n                        radii[i] = max(r_min, radii[i] - over * frac_i)\n                        radii[j] = max(r_min, radii[j] - over * frac_j)\n                    else:\n                        radii[i] = r_min\n                        radii[j] = r_min\n\n    # Expansion with careful margin, but not exceeding wall nor neighbor\n    for iter_expand in range(8):  # more expand iterations\n        for i in range(n):\n            # Max allowed radius due to wall\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            # Slightly bolder expansion margin\n            radii[i] = max(r_min, min(radii[i], max_r * 0.995))\n\n    # Final conservative shrink for all (guarantee margin, account for all numerical issues)\n    radii *= 0.990\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.6301459846616728,
      "additional_data": {
        "sum_radii": "1.630146",
        "target_ratio": "0.618651",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 43,
    "parent_id": 1,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved arrangement of 26 circles in unit square to maximize sum of radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    # Parameters for shell construction\n    # Bring outer shell closer to boundary for larger radii\n    r1 = 0.24  # inner ring radius\n    r2 = 0.42  # outer ring radius, close to border\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # 8 circles: inner ring, start from top (less collision with outer ring)\n    for i in range(8):\n        angle = np.pi/8 + 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r1 * np.cos(angle), 0.5 + r1 * np.sin(angle)]\n\n    # 16 circles: outer ring\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + r2 * np.cos(angle), 0.5 + r2 * np.sin(angle)]\n\n    # One more: near top center, expanded a bit\n    centers[25] = [0.5, 0.91]\n\n    # Don't unnecessarily restrict circle centers; allow within [r_min,1-r_min]\n    # Use starting radii\n    start_rad = 0.069\n    r_min = 0.01\n    centers = np.clip(centers, r_min, 1 - r_min)\n    radii = np.full(n, start_rad)\n\n    # Iterative correcting for border and overlap constraints\n    for iter_ in range(7):\n        # Limit by distance to square borders\n        for i in range(n):\n            x, y = centers[i]\n            max_r = min(x, y, 1 - x, 1 - y)\n            radii[i] = min(radii[i], max_r)\n\n        # Limit by distance to other circles\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.hypot(centers[i,0] - centers[j,0], centers[i,1] - centers[j,1])\n                if d < 1e-8:\n                    # Overlapping centers; resolve\n                    radii[i] = min(radii[i], 0.01)\n                    radii[j] = min(radii[j], 0.01)\n                elif radii[i] + radii[j] > d * 0.999:\n                    # Only reduce the larger radius (or both if equal)\n                    excess = radii[i] + radii[j] - d * 0.999\n                    if radii[i] > radii[j]:\n                        radii[i] -= excess\n                        if radii[i] < 0:\n                            radii[i] = 0.01\n                    elif radii[j] > radii[i]:\n                        radii[j] -= excess\n                        if radii[j] < 0:\n                            radii[j] = 0.01\n                    else:\n                        # Same radii\n                        radii[i] -= excess/2\n                        radii[j] -= excess/2\n                        if radii[i] < 0:\n                            radii[i] = 0.01\n                        if radii[j] < 0:\n                            radii[j] = 0.01\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.6659899999999999,
      "additional_data": {
        "sum_radii": "1.665990",
        "target_ratio": "0.632254",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 44,
    "parent_id": 23,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Slight iterative improvements:\n    - Stagger outer ring's phase by pi/28 to better offset vs inner ring (reduces overlaps).\n    - Increase r_inner/outer very slightly.\n    - Place corner circles even closer to the actual corners (offset=0.13 vs 0.16).\n    - More tightening greedy passes, shrink factor 0.996 at the end.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles, slightly larger radius\n    r_inner = 0.238\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n\n    # Outer ring of 14 circles, slightly increased radius and angular offset\n    r_outer = 0.463\n    angle_offset = np.pi / 28  # Small phase shift to stagger against inner ring\n    for i in range(14):\n        angle = 2 * np.pi * i / 14 + angle_offset\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n\n    # 4 corner circles, pull closer to the corners\n    corner_offset = 0.13\n    centers[23] = [corner_offset, corner_offset]\n    centers[24] = [corner_offset, 1 - corner_offset]\n    centers[25] = [1 - corner_offset, corner_offset]\n    centers[22] = [1 - corner_offset, 1 - corner_offset]\n\n    r_min = 0.008  # anti-degeneracy\n\n    # Initial radii: as large as can fit against wall\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.9985  # ever so slightly less aggressive shrink\n\n    # Initial shrink for overlaps (pre-pass with more generous margin)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.9985:\n                scale = (dist * 0.9985) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # Greedy maximization: more passes, shrink less at each pass\n    for pass_num in range(16):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.998))\n\n    # Final tighter greedy maximization pass\n    for i in range(n):\n        max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n        for j in range(n):\n            if j == i:\n                continue\n            d = np.linalg.norm(centers[i] - centers[j])\n            if d > 1e-8:\n                max_r = min(max_r, d - radii[j])\n        radii[i] = max(r_min, min(radii[i], max_r * 0.996))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.3592209697486044,
      "additional_data": {
        "sum_radii": "1.359221",
        "target_ratio": "0.515833",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 45,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    # Start with a slightly larger radius\n    r_init = 0.038\n\n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n\n    # First shell: 8 circles, slightly larger radius\n    R1 = 0.212\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n\n    # Second shell: 12 circles, offset phase a bit more\n    R2 = 0.415\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/16)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # 5 corners/mid-edge points, push into corners and one mid-edge (top/mid/bottom/left/right)\n    edge_r = 0.045\n    corners = np.array([\n        [edge_r, edge_r],\n        [1-edge_r, edge_r],\n        [1-edge_r, 1-edge_r],\n        [edge_r, 1-edge_r],\n        [0.5, 1-edge_r]\n    ])\n    # Move the non-corner to better edge spots for tight packing\n    edges_extra = np.array([\n        [0.5, edge_r],      # bottom middle\n        [edge_r, 0.5],      # mid left\n        [1-edge_r, 0.5],    # mid right\n        [0.5, 1-edge_r]     # top middle (already in corners, skip when already set)\n    ])\n    for i in range(4):\n        centers[idx] = corners[i]\n        idx += 1\n    # Place three edge-center circles (mid-left, mid-right, bottom middle)\n    for i in range(3):\n        centers[idx] = edges_extra[i]\n        idx += 1\n    # Last circle: between top-right/mid-top\n    centers[idx] = [0.77, 1-edge_r]\n    idx += 1\n\n    radii = np.ones(n) * r_init\n\n    max_iters = 62   # more inflation steps\n    grow_amt = 0.034 # slightly more aggressive\n\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.9 + 0.0045\n\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n        # Inflation step, random order\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n\n    # Final cleanup: ensure all radii are valid and no overlap\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        radii[i] = min(radii[i], max(0, max_r))\n\n    radii = np.clip(radii, 0, None)\n    sum_radii = np.sum(radii)\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: index 26 is out of bounds for axis 0 with size 26"
      }
    }
  },
  {
    "id": 46,
    "parent_id": 42,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement on provided solution:\n    - Increase initial radii scale: 0.989 \u2192 0.992\n    - Outer ring nudged outward: 0.425 \u2192 0.435\n    - Inner ring nudged outward: 0.256 \u2192 0.263\n    - 26th circle moved further up: y=0.90 \u2192 y=0.9325\n    - Expansion margin to 0.997 (from 0.995)\n    - Run 10 shrink/expand iterations (from 8)\n    - Final conservative shrink reduced: 0.990 \u2192 0.992\n    \"\"\"\n\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    inner_ring_r = 0.263  # nudge outward\n    outer_ring_r = 0.435  # nudge outward\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # 26th circle moved further up\n    centers[25] = [0.5, 0.9325]  # increasing y for maximal space\n\n    r_min = 0.008\n\n    # Initial radii: maximize to box with very small initial margin\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.992  # more aggressive\n\n    # Improved shrink pass: shrink both circles if they're too close, use slightly more margin\n    for it in range(10):  # more shrink iterations for stability\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                margin = 0.993\n                if radii[i] + radii[j] > dist * margin:\n                    over = (radii[i] + radii[j] - dist * margin)\n                    # Shrink both radii proportionally\n                    sum_rij = radii[i] + radii[j]\n                    if sum_rij > 0:\n                        frac_i = radii[i] / sum_rij\n                        frac_j = radii[j] / sum_rij\n                        radii[i] = max(r_min, radii[i] - over * frac_i)\n                        radii[j] = max(r_min, radii[j] - over * frac_j)\n                    else:\n                        radii[i] = r_min\n                        radii[j] = r_min\n\n    # Expansion with careful margin, but not exceeding wall nor neighbor\n    for iter_expand in range(10):  # more expand iterations\n        for i in range(n):\n            # Max allowed radius due to wall\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            # Slightly bolder expansion margin\n            radii[i] = max(r_min, min(radii[i], max_r * 0.997))\n\n    # Final conservative shrink for all (guarantee margin, account for all numerical issues)\n    radii *= 0.992\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "invalid",
        "error": "Invalid packing (overlaps or out of bounds)"
      }
    }
  },
  {
    "id": 47,
    "parent_id": 4,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Make the outermost two circles sit just a touch closer to top/bottom.\n    - Use slightly less conservative scale factor in overlaps\n    - More greedy passes (increase to 5)\n    - After each pass, attempt greedy expansion on each radius.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.22 * np.cos(angle), 0.5 + 0.22 * np.sin(angle)]\n\n    # Ring of 15 circles (outer ring)\n    for i in range(15):\n        angle = 2 * np.pi * i / 15\n        centers[i + 9] = [0.5 + 0.40 * np.cos(angle), 0.5 + 0.40 * np.sin(angle)]\n\n    # Two additional circles: a little closer to the boundaries\n    centers[24] = [0.5, 0.095]  # slightly closer to bottom than before (was 0.13)\n    centers[25] = [0.5, 0.905]  # slightly closer to top (was 0.87)\n\n    r_min = 0.008\n\n    # Set initial radii as before, but include safety margin at ~98.5%\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.985\n\n    # Limit by distance to other circles, with looser scale (0.997)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.997:  # smaller gap than before\n                scale = (dist * 0.997) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    N_PASSES = 5  # increase greedy passes\n\n    for pass_num in range(N_PASSES):\n        for i in range(n):\n            # Limit by distance to border\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Limit by distance to any other circle\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.997))\n        # After shrink, try greedy \"grow\": for each, attempt incremental expansion\n        for i in range(n):\n            # Try increasing by a small factor if space allows\n            grow_r = radii[i]\n            # Distance to border\n            grow_max = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to others\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    grow_max = min(grow_max, d - radii[j])\n            # Expand radius a little, stop if increase would overrun\n            if grow_max > radii[i]:\n                radii[i] = min(radii[i]*1.002, grow_max * 0.997)  # ultra small expansion factor\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.457094149703941,
      "additional_data": {
        "sum_radii": "1.457094",
        "target_ratio": "0.552977",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 48,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    r_init = 0.0352  # Slightly larger initial radius\n\n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n\n    # First shell: 8\n    R1 = 0.212\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle), 0.5 + R1 * np.sin(angle)]\n        idx += 1\n\n    # Second shell: 12\n    R2 = 0.413\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/12)\n        centers[idx] = [0.5 + R2 * np.cos(angle), 0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Edge/corner coverage: increase coverage at the top/bottom sides\n    corners = np.array([\n        [0.085, 0.085],\n        [0.915, 0.085],\n        [0.085, 0.915],\n        [0.915, 0.915],\n        [0.25, 0.93],\n        [0.75, 0.93]\n    ])\n    for i in range(6):\n        centers[idx] = corners[i]\n        idx += 1\n\n    assert idx == n\n\n    radii = np.ones(n) * r_init\n\n    max_iters = 55\n    for it in range(max_iters):\n        # Inflation step decays, but start larger for first 10 iters\n        if it < 10:\n            inflation = 0.045\n        else:\n            inflation = 0.03 * (1 - it / max_iters) * 0.96 + 0.004\n        # 1. Keep in bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n        # 2. Overlap resolve\n        for _ in range(2):\n            for i in range(n):\n                for j in range(i+1, n):\n                    d = np.linalg.norm(centers[i] - centers[j])\n                    min_dist = radii[i] + radii[j]\n                    if d < min_dist - 1e-12:\n                        overlap = min_dist - d\n                        total = radii[i] + radii[j]\n                        if total > 1e-12:\n                            f_i = radii[i] / total\n                            f_j = radii[j] / total\n                            radii[i] -= overlap * f_i\n                            radii[j] -= overlap * f_j\n                            radii[i] = max(radii[i], 0)\n                            radii[j] = max(radii[j], 0)\n        # 3. Inflation\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n\n    # Final clean-up: shrink any poking out of bounds and resolve overlaps (multiple passes)\n    for _ in range(2):\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-10:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-10:\n                        shrink_i = radii[i] / total * overlap\n                        shrink_j = radii[j] / total * overlap\n                        radii[i] -= shrink_i\n                        radii[j] -= shrink_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n    # Tiny final inflation (won't introduce overlaps)\n    for i in range(n):\n        max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n        for j in range(n):\n            if i == j:\n                continue\n            d = np.linalg.norm(centers[i] - centers[j])\n            if d > 1e-12:\n                candidate = d - radii[j]\n                if candidate < max_r:\n                    max_r = candidate\n        radii[i] = min(max_r, radii[i] + 0.001)\n        radii[i] = max(radii[i], 0)\n\n    radii = np.clip(radii, 0, None)\n    sum_radii = np.sum(radii)\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: index 26 is out of bounds for axis 0 with size 26"
      }
    }
  },
  {
    "id": 49,
    "parent_id": 28,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Use slightly less conservative margin in shrink pass (0.993 \u2192 0.995)\n    - Use slightly larger initial radius scaling (0.985 \u2192 0.988)\n    - Final conservative shrink: 0.990 \u2192 0.992\n    - Move 26th circle slightly lower (0.89 \u2192 0.87)\n    - Increase expansion iterations from 5 to 7\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    inner_ring_r = 0.252\n    outer_ring_r = 0.430\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # 26th circle moved slightly lower\n    centers[25] = [0.5, 0.87]\n\n    r_min = 0.008\n\n    # Slightly larger initial radii\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.988\n\n    # Improved shrink pass: shrink both circles if they're too close, loosen margin a bit\n    for it in range(6):  # more iterations for stability\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                margin = 0.995\n                if radii[i] + radii[j] > dist * margin:\n                    over = (radii[i] + radii[j] - dist * margin)\n                    sum_rij = radii[i] + radii[j]\n                    if sum_rij > 0:\n                        frac_i = radii[i] / sum_rij\n                        frac_j = radii[j] / sum_rij\n                        radii[i] = max(r_min, radii[i] - over * frac_i)\n                        radii[j] = max(r_min, radii[j] - over * frac_j)\n                    else:\n                        radii[i] = r_min\n                        radii[j] = r_min\n\n    # Expansion with careful margin, but not exceeding wall nor neighbor\n    for iter_expand in range(7):\n        for i in range(n):\n            # Max allowed radius due to wall\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            # More conservative margin\n            radii[i] = max(r_min, min(radii[i], max_r * 0.995))\n\n    # Final conservative shrink for all (guarantee margin, account for all numerical issues)\n    radii *= 0.992\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.6720957575479796,
      "additional_data": {
        "sum_radii": "1.672096",
        "target_ratio": "0.634571",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 50,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    r_init = 0.030  # slightly smaller start to reduce initial overlap\n\n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n\n    # First shell: 8\n    R1 = 0.222  # slightly increased\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle), 0.5 + R1 * np.sin(angle)]\n        idx += 1\n\n    # Second shell: 12\n    R2 = 0.429  # slightly increased\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi / 12)\n        centers[idx] = [0.5 + R2 * np.cos(angle), 0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 5 circles, 4 at/near corners, 1 on top edge center (hug boundary)\n    eps = 0.036  # smaller for closer corner placement\n    corners = np.array([\n        [eps, eps],\n        [1 - eps, eps],\n        [1 - eps, 1 - eps],\n        [eps, 1 - eps],\n        [0.5, 1 - eps]\n    ])\n    for i in range(5):\n        centers[idx] = corners[i]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n\n    max_iters = 65  # more inflation steps\n    grow_amt = 0.035\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.9 + 0.003\n\n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n        # 3. Inflation\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n\n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n\n    # Border enforcement\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        if radii[i] > max_r:\n            radii[i] = max(0, max_r)\n\n    radii = np.clip(radii, 0, None)\n\n    # One more greedy inflation pass: for each circle in random order, greedily increase its radius as much as possible\n    for idx_i in np.random.permutation(n):\n        max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n        for j in range(n):\n            if idx_i == j:\n                continue\n            d",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 51,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n\n    # Slightly tuned initial radius\n    r_init = 0.037\n\n    centers = np.zeros((n, 2))\n    idx = 0\n\n    centers[idx] = [0.5, 0.5]  # center\n    idx += 1\n\n    # First shell: 8\n    R1 = 0.208\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n\n    # Second shell: 12\n    R2 = 0.407\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi / 12)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 6, placed at corners and edge midpoints for better edge packing\n    last_shell = np.array([\n        [0.07, 0.07],\n        [0.93, 0.07],\n        [0.93, 0.93],\n        [0.07, 0.93],\n        [0.5, 0.07],\n        [0.5, 0.93]\n    ])\n    for i in range(6):\n        centers[idx] = last_shell[i]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n\n    max_iters = 80\n    grow_amt = 0.022\n    for it in range(max_iters):\n        # Shrink inflation step slowly as system settles\n        inflation = grow_amt * (1 - it / max_iters) * 0.91 + 0.004\n\n        # 1. In-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n        # 3. Inflation (random order)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n\n    # Final clean-up: shrink any that poke out of bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n\n    # Border enforcement\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        if radii[i] > max_r:\n            radii[i] = max(0, max_r)\n\n    # Post-processing: greedily inflate each radius as much as possible\n    for idx_i in range(n):\n        max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n        for j in range(n):\n            if idx_i == j:\n                continue\n            d = np.linalg.norm(centers[idx_i] - centers[j])\n            if d > 1e-12:\n                max_r = min(max_r, d - radii[j])\n        radii[idx_i] = max(min(radii[idx_i], max_r), 0)\n\n    radii = np.clip(radii, 0, None)\n    sum_radii = np.sum(radii)\n    return centers,",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: index 26 is out of bounds for axis 0 with size 26"
      }
    }
  },
  {
    "id": 52,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    r_init = 0.037  # Slightly larger initial radius\n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n    \n    # First shell: 8\n    R1 = 0.22  # Slightly larger\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n        \n    # Second shell: 12\n    R2 = 0.43  # Slightly larger\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/12)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 8 circles, corners and edge-middles (to replace former final shell)\n    corners = np.array([\n        [0.07, 0.07],\n        [0.93, 0.07],\n        [0.93, 0.93],\n        [0.07, 0.93],\n        [0.5, 0.07],\n        [0.93, 0.5],\n        [0.5, 0.93],\n        [0.07, 0.5]\n    ])\n    for i in range(8):\n        centers[idx] = corners[i]\n        idx += 1\n\n    # Greedy local repulsion: Slightly randomize these shell points to achieve less symmetry\n    noise = np.random.uniform(-0.015, 0.015, size=(8,2))\n    centers[-8:] += noise\n    centers[-8:] = np.clip(centers[-8:], 0.04, 0.96)\n    \n    radii = np.ones(n) * r_init\n    \n    max_iters = 55\n    grow_amt = 0.031  # Slightly more aggressive\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.97 + 0.004\n\n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation (random ordering for more local max escape)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radi",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: index 26 is out of bounds for axis 0 with size 26"
      }
    }
  },
  {
    "id": 53,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    # Tiny increase to r_init\n    r_init = 0.037\n    \n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n    \n    # First shell: 8\n    R1 = 0.217\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n        \n    # Second shell: 12\n    R2 = 0.413\n    for i in range(12):\n        # slight random shuffle to break symmetry more\n        random_shift = (np.random.rand() - 0.5) * (np.pi / 26)\n        angle = 2 * np.pi * i / 12 + (np.pi / 12) + random_shift  \n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 5 circles, 4 at corners, 1 bottom edge (was top edge)\n    corners = np.array([\n        [0.07, 0.07],\n        [0.93, 0.07],\n        [0.93, 0.93],\n        [0.07, 0.93],\n        [0.5, 0.07],  # moved to bottom\n    ])\n    for i in range(5):\n        centers[idx] = corners[i]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n    \n    max_iters = 56  # add a few more inflation steps\n    grow_amt = 0.031  # slightly more aggressive\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.91 + 0.0042\n        \n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution -- split shrink equally not by radii ratio\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    radii[i] -= 0.5 * overlap\n                    radii[j] -= 0.5 * overlap\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation (random ordering)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Extra inflation pass for very small circles\n    for idx_i in np.argsort(radii):\n        max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n        for j in range(n):\n            if idx_i == j:\n                continue\n            d = np.linalg.norm(centers[idx_i] - centers[j])\n            if d > 1e-14:\n                candidate = d - radii[j]\n                if candidate < max_r:\n                    max_r = candidate\n        radii[idx_i] = min(max_r, radii[idx_i] + 0.0042)\n        radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull (twice for safety)\n    for loop in range(2):\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-9:\n                    overlap = min_dist - d\n                    radii[i] -= 0.5 * overlap\n                    radii[j] -= 0.5 * overlap\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n    \n    # Border enforcement again\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        if radii[i] > max_r:\n            radii[i] = max(0, max_r)\n\n    radii = np.clip(radii, 0, None)\n    sum_radii = np.sum(radii)\n    return centers,",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: not enough values to unpack (expected 3, got 1)"
      }
    }
  },
  {
    "id": 54,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n\n    # Improved: slightly larger start for corners, otherwise as before\n    r_init_inner = 0.035\n    r_init_corners = 0.042\n\n    centers = np.zeros((n, 2))\n    radii = np.ones(n) * r_init_inner\n\n    idx = 0\n    # Center\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n\n    # First shell: 8 (tweak R1 a little outward)\n    R1 = 0.23\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n\n    # Second shell: 12 (tweak R2 outward to use more edge/corner room)\n    R2 = 0.426\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/18)  # Break symmetry for coverage\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 5, place in/near corners, optimize corner positions\n    corners = np.array([\n        [0.065, 0.065], # closer to (0,0)\n        [0.935, 0.065], # closer to (1,0)\n        [0.935, 0.935], # closer to (1,1)\n        [0.065, 0.935], # closer to (0,1)\n        [0.5, 0.96],    # top edge, slightly shifted up\n    ])\n    for i in range(5):\n        centers[idx] = corners[i]\n        radii[idx] = r_init_corners\n        idx += 1\n\n    # Iterative inflation\n    max_iters = 65\n    grow_amt = 0.034\n    for it in range(max_iters):\n        # Improved: nonlinear decay schedule for inflation\n        inflation = grow_amt * (1 - (it / max_iters)**1.18) * 0.94 + 0.004\n\n        # 1. Boundaries\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n        # 3. Inflating (random order, as before)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n\n    # Final clean: shrink if poking out of bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n\n    # Border enforcement\n    for i in range(n):\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 55,
    "parent_id": 15,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Slightly decrease inner ring radius and increase outer ring\n    - Tweak 26th circle position\n    - More shrink/expand passes\n    - Slightly looser safety margin (0.997)\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Slightly tightened inner ring and expanded outer ring for denser packing\n    inner_ring_r = 0.251   # Was 0.255, try slightly tighter\n    outer_ring_r = 0.430   # Was 0.425, try slightly further out\n    \n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # 26th circle: push further into upper region and slightly left\n    centers[25] = [0.48, 0.92]  # Was [0.51, 0.91]\n\n    r_min = 0.008\n\n    # Set initial radii: maximize each circle's distance to border\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.994  # Start a bit closer to max wall limit but safer\n    \n    # Proximity shrink: shrink only the larger radius for too-close pairs, more passes, tighter margin\n    for it in range(5):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * 0.997:  # Tighter margin\n                    # Only shrink the larger radius\n                    if radii[i] > radii[j]:\n                        radii[i] = max(r_min, dist * 0.997 - radii[j])\n                    else:\n                        radii[j] = max(r_min, dist * 0.997 - radii[i])\n\n    # Greedy expansion pass for each circle, more passes, looser margin\n    for iter_expand in range(5):\n        for i in range(n):\n            # Distance to wall constraint\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.997))  # Tighter margin\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.9101904698701295,
      "additional_data": {
        "sum_radii": "1.910190",
        "target_ratio": "0.724930",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 56,
    "parent_id": 52,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    np.random.seed(1234)\n    n = 26\n    r_init = 0.037  # Slightly larger initial radius\n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n    \n    # First shell: 8\n    R1 = 0.22\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n        \n    # Second shell: 12\n    R2 = 0.43\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/12)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Only 5 slots left: pick the 5 best from the 8 corners/edge-midpoints (those farthest from others)\n    candidates = np.array([\n        [0.07, 0.07],\n        [0.93, 0.07],\n        [0.93, 0.93],\n        [0.07, 0.93],\n        [0.5, 0.07],\n        [0.93, 0.5],\n        [0.5, 0.93],\n        [0.07, 0.5]\n    ])\n    # Score candidate points by their minimal distance to existing centers (prefer least crowded)\n    dists = np.array([\n        np.min([np.linalg.norm(c - centers[:idx], axis=1) for c in candidates])\n    ])\n    chosen_indices = []\n    # Greedily select 5 farthest-from-packed\n    available = set(range(8))\n    for _ in range(n - idx):\n        max_dist = -1\n        best_j = -1\n        for j in available:\n            d = np.min(np.linalg.norm(candidates[j] - centers[:idx], axis=1))\n            if d > max_dist:\n                max_dist = d\n                best_j = j\n        chosen_indices.append(best_j)\n        available.remove(best_j)\n        centers[idx] = candidates[best_j]\n        idx += 1\n\n    # Greedy local repulsion: Slightly randomize these shell points to achieve less symmetry\n    noise = np.random.uniform(-0.015, 0.015, size=(n-21,2))\n    centers[21:] += noise\n    centers[21:] = np.clip(centers[21:], 0.04, 0.96)\n    \n    radii = np.ones(n) * r_init\n    \n    max_iters = 55\n    grow_amt = 0.031\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.97 + 0.004\n\n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation (random ordering for more local max escape)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final clean-up: ensure all circles inside square\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull (missing code restored)\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 57,
    "parent_id": 55,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    SMALL ITERATIVE IMPROVEMENT OVER PREVIOUS:\n    - Expand outer ring radius a bit further.\n    - Tweak 26th circle position towards the most open upper left region ([0.46,0.93]).\n    - More shrink/expand passes (7 instead of 5).\n    - Tighter margin: 0.9965 shrink, 0.996 expand.\n    - Slightly smaller r_min for flexibility.\n    - When two circles overlap, shrink both (evenly distant).\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Small improvement: expand inner and outer rings slightly\n    inner_ring_r = 0.2515\n    outer_ring_r = 0.438  # Increased from 0.430\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # 26th circle: push further into upper left region (fit in northeast corner, gently nudge left)\n    centers[25] = [0.46, 0.93]  # Shifted a bit further up/left\n\n    r_min = 0.0065  # Reduced minimum, so if needed a \"sacrificial\" circle can shrink\n\n    # Set initial radii: each is at most the distance to closest wall\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.9942  # Small tweak\n\n    # Proximity shrink: shrink both radii (evenly), more passes, slightly looser margin\n    shrink_margin = 0.9965\n    for it in range(7):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required = (radii[i] + radii[j])\n                if required > dist * shrink_margin:\n                    excess = required - dist * shrink_margin\n                    # Shrink both, weighted by current radius size\n                    total = radii[i] + radii[j]\n                    if total > 0:\n                        frac_i = radii[i] / total\n                        frac_j = radii[j] / total\n                        radii[i] = max(r_min, radii[i] - excess * frac_i)\n                        radii[j] = max(r_min, radii[j] - excess * frac_j)\n                    else:\n                        radii[i] = radii[j] = r_min\n\n    # Greedy expansion: more passes, slightly looser margin\n    expand_margin = 0.996\n    for iter_expand in range(7):\n        for i in range(n):\n            # Distance to wall\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * expand_margin))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.6937140812045297,
      "additional_data": {
        "sum_radii": "1.693714",
        "target_ratio": "0.642776",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 58,
    "parent_id": 23,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    SMALL ITERATIVE IMPROVEMENT:\n    - Outer ring up to 16 circles (was 14)\n    - Outer ring is angularly offset wrt inner ring\n    - 4 extra circles on sides as well as 4 corners (total 8 extras)\n    - Slightly tuned r_inner, r_outer, corner/side offsets for more area\n    - More and tighter greedy maximization passes (20 at 0.999, final at 0.9975)\n    - Small random jitter in outer ring to further break symmetry\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles at tuned radius\n    r_inner = 0.2365\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n\n    # Outer ring of 16 circles (up from 14), slight positive angle offset\n    r_outer = 0.454\n    theta_offset = np.pi / 16\n    # Small jitter amount\n    np.random.seed(42)\n    outer_jitter = np.random.uniform(-0.01, 0.01, size=16)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16 + theta_offset + outer_jitter[i]\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n\n    # 4 extra circles toward corners (offset tuned down a bit)\n    corner_offset = 0.135\n    centers[25-3] = [corner_offset, corner_offset]\n    centers[25-2] = [corner_offset, 1 - corner_offset]\n    centers[25-1] = [1 - corner_offset, corner_offset]\n    centers[25-0] = [1 - corner_offset, 1 - corner_offset]\n\n    # 4 extra circles near midpoints of each side (offset tuned)\n    side_offset = 0.13\n    centers[25-7] = [side_offset, 0.5]\n    centers[25-6] = [1-side_offset, 0.5]\n    centers[25-5] = [0.5, side_offset]\n    centers[25-4] = [0.5, 1-side_offset]\n\n    r_min = 0.008  # safety\n\n    # Initial radii (room to square wall)\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.999\n\n    # Initial shrink for overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.999:\n                scale = (dist * 0.999) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # Greedy maximization: 20 passes, less shrinking\n    for pass_num in range(20):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.999))\n\n    # Final very tight greedy maximization\n    for i in range(n):\n        max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n        for j in range(n):\n            if j == i:\n                continue\n            d = np.linalg.norm(centers[i] - centers[j])\n            if d > 1e-8:\n                max_r = min(max_r, d - radii[j])\n        radii[i] = max(r_min, min(radii[i], max_r * 0.9975))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.5742989821653555,
      "additional_data": {
        "sum_radii": "1.574299",
        "target_ratio": "0.597457",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 59,
    "parent_id": 17,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Stricter protection against negative radii during greedy expansion\n    - Shrink outer ring margin less aggressively\n    - Smoother last squeeze until all circles are valid\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    # Central circle\n    centers[0] = [0.5, 0.5]\n    # Inner ring of 8 circles\n    inner_ring_r = 0.22\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    # Outer ring of 15 circles, maximize possible outer_ring_r so all circles' centers stay in bounds\n    outer_ring_angles = [2 * np.pi * i / 15 for i in range(15)]\n    max_r_list = []\n    for angle in outer_ring_angles:\n        cos_a = np.cos(angle)\n        sin_a = np.sin(angle)\n        rx = np.inf\n        ry = np.inf\n        # Protect division by zero\n        if abs(cos_a) > 1e-12:\n            if cos_a > 0:\n                rx = (1 - 0.5) / cos_a\n            else:\n                rx = (0 - 0.5) / cos_a\n        if abs(sin_a) > 1e-12:\n            if sin_a > 0:\n                ry = (1 - 0.5) / sin_a\n            else:\n                ry = (0 - 0.5) / sin_a\n        max_r = min(rx, ry)\n        if max_r < 0 or max_r > 0.5:\n            max_r = 0.5\n        max_r_list.append(max_r)\n    # Less aggressive margin\n    outer_ring_r = min(max_r_list) * 0.99\n\n    for idx, angle in enumerate(outer_ring_angles):\n        centers[9 + idx] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    # The two corner circles - maximize their radii at placement!\n    cA = np.array([0.13, 0.13])  # slightly farther from corner for more margin (was 0.125)\n    cB = np.array([0.87, 0.87])  # symmetrical\n    centers[24] = cA\n    centers[25] = cB\n\n    r_min = 0.008  # avoid degeneracy\n\n    # Initial radii: distance to closest wall, shrink slightly\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.99  # slightly less aggressive shrink\n\n    # For each corner, reduce radius if too close to any previous circle\n    for k in [24, 25]:\n        cx, cy = centers[k]\n        max_r = min(cx, cy, 1-cx, 1-cy)\n        for i in range(n):\n            if i == k:\n                continue\n            dij = np.linalg.norm(centers[i] - centers[k])\n            available = dij - radii[i]\n            if available < max_r:\n                max_r = available * 0.98\n        radii[k] = max(r_min, min(radii[k], max_r * 0.99))\n\n    # Tighten by pairwise distances\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.995:\n                scale = (dist * 0.995) / (radii[i] + radii[j])\n                # Only shrink, never expand\n                if scale < 1:\n                    radii[i] *= scale\n                    radii[j] *= scale\n\n    # Greedy expansion passes: expand each circle up to wall/neighbor\n    for pass_num in range(10):  # more passes for better fit\n        for i in range(n):\n            # Maximum radius allowed by border\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                cap = d - (radii[j] if radii[j] > 0 else 0)\n                if cap < max_r:\n                    max_r = cap\n            # Extra safety\n            radii[i] = max(r_min, min(radii[i], max_r * 0.99))\n\n    # Final safety pass: if not valid, shrink all and try again (up to 10 times)\n    def is_valid(centers, radii):\n        for i in range(n):\n            if (centers[i][0] - radii[i] < -1e-9 or\n                centers[i][1] - radii[i] < -1e-9 or\n                centers[i][0] + radii[i] > 1+1e-9 or\n                centers[i][1] + radii[i] > 1+1e-9 or\n                radii[i] < 0):\n                return False\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > d + 1e-9:\n                    return False\n        return True\n\n    valid = is_valid(centers, radii)\n    # If not valid, shrink radii globally until valid, up to 10 times\n    squeeze_factor = 0.99\n    tries = 10\n   ",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 60,
    "parent_id": 57,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    SMALL ITERATIVE IMPROVEMENT:\n    - Outer ring radius increased very slightly (0.440).\n    - 26th circle nudged further into northeast corner ([0.455, 0.9475]).\n    - More passes (9) for both shrink and expand.\n    - Slightly higher margins: shrink_margin=0.9975, expand_margin=0.997.\n    - r_min reduced to 0.0060 for flexibility.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Rings\n    inner_ring_r = 0.2515\n    outer_ring_r = 0.440  # Slightly increased\n\n    # Inner ring: 8 circles\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Outer ring: 16 circles\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # 26th circle: slide nearer to northeast boundary\n    centers[25] = [0.455, 0.9475]\n\n    r_min = 0.0060\n\n    # Set initial radii: each is at most the distance to closest wall\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.9942  # Small tweak as before\n\n    # More passes, slightly less aggressive shrinking/expansion\n    shrink_margin = 0.9975\n    for it in range(9):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required = (radii[i] + radii[j])\n                if required > dist * shrink_margin:\n                    excess = required - dist * shrink_margin\n                    total = radii[i] + radii[j]\n                    if total > 0:\n                        frac_i = radii[i] / total\n                        frac_j = radii[j] / total\n                        radii[i] = max(r_min, radii[i] - excess * frac_i)\n                        radii[j] = max(r_min, radii[j] - excess * frac_j)\n                    else:\n                        radii[i] = radii[j] = r_min\n\n    expand_margin = 0.997\n    for iter_expand in range(9):\n        for i in range(n):\n            # Distance to wall\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * expand_margin))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.697550144543868,
      "additional_data": {
        "sum_radii": "1.697550",
        "target_ratio": "0.644232",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 61,
    "parent_id": 60,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    SMALL ITERATIVE IMPROVEMENT on prior method:\n    - Outer ring radius increased further (0.445)\n    - Inner ring radius slightly increased (0.253)\n    - 26th circle nudged closer to northeast ([0.46, 0.954])\n    - More expand passes (10), with a slightly tighter expand margin (0.9975)\n    - Fewer shrink passes (8), but tighter margin (0.998)\n    - Slightly larger initial global radii factor (0.995)\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Rings\n    inner_ring_r = 0.253\n    outer_ring_r = 0.445  # Slightly increased\n\n    # Inner ring: 8 circles\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Outer ring: 16 circles\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # 26th circle: push further into the northeast boundary\n    centers[25] = [0.46, 0.954]\n\n    r_min = 0.0060\n\n    # Set initial radii: at most the distance to closest wall\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.995  # Slightly less aggressive shrink on start\n\n    # Shrink to prevent overlaps\n    shrink_margin = 0.998\n    for it in range(8):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required = (radii[i] + radii[j])\n                if required > dist * shrink_margin:\n                    excess = required - dist * shrink_margin\n                    total = radii[i] + radii[j]\n                    if total > 0:\n                        frac_i = radii[i] / total\n                        frac_j = radii[j] / total\n                        radii[i] = max(r_min, radii[i] - excess * frac_i)\n                        radii[j] = max(r_min, radii[j] - excess * frac_j)\n                    else:\n                        radii[i] = radii[j] = r_min\n\n    # Expand radii greedily to wall/neighbor, but not to overlap\n    expand_margin = 0.9975\n    for iter_expand in range(10):\n        for i in range(n):\n            # Distance to wall\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * expand_margin))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.690891289595584,
      "additional_data": {
        "sum_radii": "1.690891",
        "target_ratio": "0.641704",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 62,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    r_init = 0.0355  # slightly increased initial guess (was 0.035)\n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]  # center\n    idx += 1\n\n    # First shell: 8 (widened slightly)\n    R1 = 0.233  # increased vs before\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n\n    # Second shell: 12 (also stretched)\n    R2 = 0.435\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi / 12)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Place 4 at the true corners (tight to the border)\n    eps = 1e-6\n    corner_pad = r_init + 0.004\n    corner_pts = np.array([\n        [corner_pad, corner_pad],  # SW\n        [1 - corner_pad, corner_pad],  # SE\n        [1 - corner_pad, 1 - corner_pad],  # NE\n        [corner_pad, 1 - corner_pad],  # NW\n    ])\n    # 1 more on one edge midpoint \u2013 the last spot\n    extra = np.array([[0.5, 1 - corner_pad]])\n\n    for i in range(4):\n        centers[idx] = corner_pts[i]\n        idx += 1\n    centers[idx] = extra[0]\n    idx += 1\n\n    assert idx == n\n\n    radii = np.full(n, r_init)\n\n    max_iters = 60  # increase iterations for more time to inflate\n    grow_amt = 0.033  # similar, but will decay more slowly\n\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.9 + 0.005\n\n        # Keep circles inside box\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # Resolve overlaps\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n        # Inflate radii\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n\n    # Final cleanup: shrink to fit box\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Remove any overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j]",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 63,
    "parent_id": 60,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    SMALL ITERATIVE IMPROVEMENT:\n    - inner_ring_r increased to 0.257\n    - outer_ring_r increased to 0.445\n    - 26th circle in NE corner at [0.457, 0.950]\n    - Initial radii factor up to 0.995\n    - expand_margin increased to 0.9973\n    - expansion passes up to 12\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Rings\n    inner_ring_r = 0.257   # Slight increase\n    outer_ring_r = 0.445   # Slight increase\n\n    # Inner ring: 8 circles\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Outer ring: 16 circles\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # 26th circle (index 25): slide slightly more into NE boundary\n    centers[25] = [0.457, 0.950]\n\n    r_min = 0.0060\n\n    # Slightly bigger initial radii factor\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.995  # Tweak up slightly from 0.9942\n\n    shrink_margin = 0.9975\n    for it in range(9):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required = (radii[i] + radii[j])\n                if required > dist * shrink_margin:\n                    excess = required - dist * shrink_margin\n                    total = radii[i] + radii[j]\n                    if total > 0:\n                        frac_i = radii[i] / total\n                        frac_j = radii[j] / total\n                        radii[i] = max(r_min, radii[i] - excess * frac_i)\n                        radii[j] = max(r_min, radii[j] - excess * frac_j)\n                    else:\n                        radii[i] = radii[j] = r_min\n\n    expand_margin = 0.9973  # Loosened from 0.997\n    for iter_expand in range(12):  # More passes to converge\n        for i in range(n):\n            # Distance to wall\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * expand_margin))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.702951720441709,
      "additional_data": {
        "sum_radii": "1.702952",
        "target_ratio": "0.646281",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 64,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    r_init = 0.041  # slightly larger initial radii\n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n    \n    # First shell: 8\n    R1 = 0.21\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n    \n    # Second shell: 12\n    R2 = 0.41\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/12)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Placement of last 5 circles: greedy farthest from all existing centers and boundaries\n    grid_res = 30\n    search_points = np.stack(np.meshgrid(\n        np.linspace(0.09,0.91,grid_res),\n        np.linspace(0.09,0.91,grid_res)\n    ), axis=-1).reshape(-1,2)\n    used_mask = np.zeros(len(search_points), dtype=bool)\n    for i in range(5):\n        dists = []\n        for pt in search_points:\n            # Min distance to all already placed centers\n            m = np.min(np.linalg.norm(centers[:idx] - pt, axis=1))\n            # Also distance to edge\n            m = min(m, pt[0], pt[1], 1-pt[0], 1-pt[1])\n            dists.append(m)\n        best_idx = np.argmax(dists)\n        while used_mask[best_idx]:\n            dists[best_idx] = -1e6\n            best_idx = np.argmax(dists)\n        centers[idx] = search_points[best_idx]\n        used_mask[best_idx] = True\n        idx += 1\n\n    assert idx == n\n    \n    radii = np.ones(n) * r_init\n    \n    max_iters = 58\n    grow_amt = 0.0305\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.9 + 0.004\n        \n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    # EQUAL shrinkage instead of prop to radius\n                    radii[i] -= overlap/2\n                    radii[j] -= overlap/2\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation (random order)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final clean up: boundary enforcement\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                radii[i] -= overlap/2\n                radii[j] -= overlap/2\n                radii[i] = max(radii[i], 0)\n                radii[j] = max(radii[j], 0)\n    \n    # Border enforcement again\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        if radii[i] > max_r:\n            radii[i] = max(0, max_r)\n\n    radii = np.clip(radii, 0, None)\n    sum_radii = np.sum(radii)\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 2.129460367396956,
      "additional_data": {
        "sum_radii": "2.129460",
        "target_ratio": "0.808144",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 65,
    "parent_id": 5,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement: safer radii shrinking & expansion margins, more proximity shrink passes,\n    gentler ring circle nudging, slightly less aggressive initial radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    inner_ring_r = 0.242\n    outer_ring_r = 0.418\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        base = np.array([0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)])\n        if i == 2 or i == 3:\n            # Push these slightly up and outward, less aggressively than before\n            delta_theta = np.pi/128\n            angle_nudged = angle + (delta_theta if i==2 else -delta_theta)\n            base = np.array([0.5 + 1.008*outer_ring_r * np.cos(angle_nudged), \n                             0.5 + 1.005*outer_ring_r * np.sin(angle_nudged)])\n        centers[i + 9] = base\n    \n    # 26th circle: place slightly above the previous, being careful not to clip the upper boundary\n    centers[25] = [0.512, 0.91]\n    \n    r_min = 0.008\n\n    # Initial radii: maximize each circle's border distance, then take *0.97 for safety\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.97\n\n    # Proximity shrink: 6 passes, margin 0.98\n    for it in range(6):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * 0.98:\n                    # Shrink only the bigger of the pair\n                    if radii[i] > radii[j]:\n                        radii[i] = max(r_min, dist * 0.98 - radii[j])\n                    else:\n                        radii[j] = max(r_min, dist * 0.98 - radii[i])\n\n    # Expansion passes for each circle, 3 sweeps, margin 0.98\n    for iter_expand in range(3):\n        for i in range(n):\n            # Distance to wall constraint\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            # Safety margin\n            radii[i] = max(r_min, min(radii[i], max_r * 0.98))\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "invalid",
        "error": "Invalid packing (overlaps or out of bounds)"
      }
    }
  },
  {
    "id": 66,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    r_init = 0.035   # base initial radius\n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n\n    # First shell: 8\n    R1 = 0.21\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n\n    # Second shell: 12\n    R2 = 0.41\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/12)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Improved: Last shell, true square corners, last at top center\n    corners = np.array([\n        [0.0, 0.0],\n        [1.0, 0.0],\n        [1.0, 1.0],\n        [0.0, 1.0],\n        [0.5, 1.0]\n    ])\n    for i in range(5):\n        centers[idx] = corners[i]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n\n    # Give corners a little more initial radius\u2014they can use it!\n    for i in range(21,25):\n        radii[i] = 0.045\n    radii[25] = 0.040  # top center a bit less\n    radii[0] = 0.034  # core circle a tad smaller\n\n    max_iters = 63  # slightly more\n    grow_amt = 0.032\n    eps = 1e-10\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.92 + 0.003\n\n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - eps:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > eps:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n        # 3. Inflation (random ordering)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            x, y = centers[idx_i]\n            max_r = min(x, y, 1 - x, 1 - y)\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > eps:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            # Only inflate if not nearly at max possible\n            if radii[idx_i] < max_r - 1.3e-3:\n                radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            else:\n                radii[idx_i] = min(radii[idx_i], max_r)\n            radii[idx_i] = max(radii[idx_i], 0)\n\n    # Final clean-up: ensure entirely inside bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n\n    # Border check\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        if radii[i] > max_r:\n            radii[i] = max(0, max_r)\n\n    radii = np.clip(radii, 0, None)\n    sum_radii = np.sum(radii)\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 2.0182362481785185,
      "additional_data": {
        "sum_radii": "2.018236",
        "target_ratio": "0.765934",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 67,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    # Improved: start with more concentric shells, nudge shells, adjust radii per shell\n    r_init_c = 0.045   # center\n    r_init_1 = 0.038   # inner shell\n    r_init_2 = 0.032   # middle shell\n    r_init_3 = 0.028   # outer shell\n\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    idx = 0\n\n    # Center\n    centers[idx] = [0.5, 0.5]\n    radii[idx] = r_init_c\n    idx += 1\n\n    # First shell: 8 (slightly closer in)\n    R1 = 0.20\n    for i in range(8):\n        angle = 2 * np.pi * i / 8 + 0.07  # subtle phase\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        radii[idx] = r_init_1\n        idx += 1\n\n    # Second shell: 12 (a bit farther out, phase shifted)\n    R2 = 0.393\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/18)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        radii[idx] = r_init_2\n        idx += 1\n\n    # Outer: remaining 5 in better positions: 4 corners, 1 on middle of top edge\n    corners = np.array([\n        [0.06, 0.06],\n        [0.94, 0.06],\n        [0.94, 0.94],\n        [0.06, 0.94],\n        [0.5, 0.96]\n    ])\n    for i in range(5):\n        centers[idx] = corners[i]\n        radii[idx] = r_init_3\n        idx += 1\n\n    # Small random jitter to help packing avoid symmetry local minima\n    centers += 0.003 * np.random.uniform(-1, 1, centers.shape)\n\n    # Packing iterations\n    max_iters = 65  # slightly more iterations\n    grow_amt = 0.033\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.92 + 0.0032\n\n        # Bound enforcement\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # Overlap resolution, stricter correction\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d + 1e-6\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n        # Inflation\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1-centers[idx_i][0], 1-centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n\n    # Final cleanup: enforce boundaries and remove overlaps more strictly\n    for _ in range(4):\n        for i in range(n):\n            x, y = centers[i]\n            max_r = min(x, y, 1 - x, 1 - y)\n            if radii[i] > max_r:\n                radii[i] = max(0, max_r)\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 2e-9:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-11:\n                        shrink_i = radii[i] / total * overlap\n                        shrink_j = radii[j] / total * overlap\n                        radii[i] -= shrink_i\n                        radii[j] -= shrink_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n    radii = np.clip(radii, 0, None)\n    sum_radii = np.sum(radii)\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 2.1575458166356736,
      "additional_data": {
        "sum_radii": "2.157546",
        "target_ratio": "0.818803",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 68,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    r_init = 0.035\n\n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n\n    # First shell: 8\n    R1 = 0.21\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n\n    # Second shell: 12\n    R2 = 0.41\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/12)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 6 circles (corners and edge-middles), allow more edge coverage\n    outer_points = np.array([\n        [0.08, 0.08],    # lower left corner\n        [0.92, 0.08],    # lower right corner\n        [0.92, 0.92],    # upper right corner\n        [0.08, 0.92],    # upper left corner\n        [0.5, 0.97],     # top edge center\n        [0.5, 0.03],     # bottom edge center\n    ])\n    for i in range(6):\n        centers[idx] = outer_points[i]\n        idx += 1\n\n    # Slightly larger initial radii for edge/corner points\n    radii = np.ones(n) * r_init\n    for i in range(n-6, n):\n        radii[i] = r_init * 1.04\n\n    max_iters = 56\n    grow_amt = 0.031\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.93 + 0.0038\n\n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n        # 3. Inflation (random ordering for more local max escape)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n\n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n\n    # Border enforcement\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        if radii[i] > max_r:\n            radii[i] = max(0, max_r)\n\n    radii = np.clip(radii, 0, None)\n    sum_radii = np.sum(radii)\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: index 26 is out of bounds for axis 0 with size 26"
      }
    }
  },
  {
    "id": 69,
    "parent_id": 7,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Iterative improvement of 26-circle packing in unit square.\n    - Improved initial radii.\n    - Slightly offset angles to better fill gaps.\n    - Place circle 26 near the least crowded corner.\n    - Final local greedy grow for each circle.\n    - More border/overlap iterations.\n    \"\"\"\n    n = 26\n    # Start with a larger radius, will shrink as needed\n    r_init = 0.0525   \n    \n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # First ring (8 circles)\n    R1 = 0.226\n    phi1 = 2 * np.pi * 0.07  # phase offset to break symmetry\n    for i in range(8):\n        angle = phi1 + 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + R1 * np.cos(angle), 0.5 + R1 * np.sin(angle)]\n    \n    # Outer ring (16 circles)\n    R2 = 0.402\n    phi2 = 2 * np.pi * 0.18\n    for i in range(16):\n        angle = phi2 + 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + R2 * np.cos(angle), 0.5 + R2 * np.sin(angle)]\n    \n    # 26th circle: place near bottom left (well-separated)\n    centers[25] = [0.145, 0.145]\n    \n    radii = np.ones(n) * r_init\n    \n    for pass_outer in range(10):  # increased passes\n        # Shrink radii to fit within square\n        for i in range(n):\n            x, y = centers[i]\n            r_max = min(x, y, 1 - x, 1 - y)\n            if radii[i] > r_max:\n                radii[i] = r_max\n\n        # Overlap resolution\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-9:\n                    excess = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        shrink_i = radii[i] / total * excess\n                        shrink_j = radii[j] / total * excess\n                        radii[i] -= shrink_i\n                        radii[j] -= shrink_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # Greedy growing\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-10:\n                    possible = d - radii[j]\n                    if possible < max_r:\n                        max_r = possible\n            radii[i] = max(0, min(radii[i], max_r))\n\n    # Final validity cleanup\n    radii = np.clip(radii, 0, None)\n    for i in range(n):\n        x, y = centers[i]\n        if not (radii[i] <= x <= 1 - radii[i] and radii[i] <= y <= 1 - y):\n            max_r = min(x, y, 1 - x, 1 - y)\n            radii[i] = max(0, min(radii[i], max_r))\n\n    # Safety: ensure all pairs not overlapping (last fix)\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-7:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-12:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n    # Mini local greedy grow for the last polish\n    for i in range(n):\n        # Maximum allowable radius based on borders\n        max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n        # and every other circle\n        for j in range(n):\n            if i == j: continue\n            d = np.linalg.norm(centers[i] - centers[j])\n            if d > 1e-10:\n                possible = d - radii[j]\n                if possible < max_r:\n                    max_r = possible\n        radii[i] = max(0, min(radii[i], max_r))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.362260751343053,
      "additional_data": {
        "sum_radii": "1.362261",
        "target_ratio": "0.516987",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 70,
    "parent_id": 57,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Slightly expand both ring radii and nudge 26th circle a bit more into the corner.\n    - r_min now even smaller to enable possible 'sacrifice' for crowded corner.\n    - Use tighter shrink/expand margins, more shrink/expand passes.\n    - Slight increase of radii scale after initialization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Ring radii nudged up\n    inner_ring_r = 0.2543  # was 0.2515\n    outer_ring_r = 0.441   # was 0.438\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # Nudge 26th circle even further to the open upper left, slightly more diagonal\n    centers[25] = [0.444, 0.944]\n\n    # Slightly smaller minimum radius for flexibility\n    r_min = 0.006\n\n    # Init radii: at most distance to closest wall, then scale up a touch more at start\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.9947  # nudge up\n\n    # Tighter shrink/expand margins, more passes\n    shrink_margin = 0.9973  # up from 0.9965\n    expand_margin = 0.997   # up from 0.996\n    for it in range(8):  # up from 7\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required = (radii[i] + radii[j])\n                if required > dist * shrink_margin:\n                    excess = required - dist * shrink_margin\n                    # Shrink both, weighted by current radius size\n                    total = radii[i] + radii[j]\n                    if total > 0:\n                        frac_i = radii[i] / total\n                        frac_j = radii[j] / total\n                        radii[i] = max(r_min, radii[i] - excess * frac_i)\n                        radii[j] = max(r_min, radii[j] - excess * frac_j)\n                    else:\n                        radii[i] = radii[j] = r_min\n\n    # Expansion passes, also increased by 1\n    for iter_expand in range(8):\n        for i in range(n):\n            # Distance to wall\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * expand_margin))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.7136340408948696,
      "additional_data": {
        "sum_radii": "1.713634",
        "target_ratio": "0.650335",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 71,
    "parent_id": 69,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement: \n    - Redistribute circles: 1 center, 7 inner, 18 outer (hex-style)\n    - Tweak initial radii slightly up\n    - Squeeze outer ring closer to center\n    - Place last circle by greedy farthest-empty-spot search (very rough grid)\n    - Small improvements to greedy grows\n    \"\"\"\n    n = 26\n    r_init = 0.0530  # Slightly larger initial\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # First ring: 7 circles (hexagonal, tighter)\n    R1 = 0.202\n    phi1 = np.pi / 8  # minor symmetry break\n    for i in range(7):\n        angle = phi1 + 2 * np.pi * i / 7\n        centers[1 + i] = [0.5 + R1 * np.cos(angle), 0.5 + R1 * np.sin(angle)]\n    \n    # Outer ring: 18 circles (denser than previous 16)\n    R2 = 0.385\n    phi2 = 2 * np.pi * 0.17  # symmetry break\n    for i in range(18):\n        angle = phi2 + 2 * np.pi * i / 18\n        centers[8 + i] = [0.5 + R2 * np.cos(angle), 0.5 + R2 * np.sin(angle)]\n    \n    # Place last circle in least crowded region: scan grid, take max min-distance to all existing\n    grid = np.linspace(0.13, 0.87, 8)\n    max_min_dist = None\n    best_pos = None\n    for x in grid:\n        for y in grid:\n            trial = np.array([x, y])\n            dists = np.linalg.norm(centers[:25] - trial, axis=1)\n            min_dist = np.min(dists)\n            edge_dist = min(x, y, 1-x, 1-y)\n            # Seek large free space but keep away from border\n            score = min(min_dist, edge_dist*1.25)\n            if max_min_dist is None or score > max_min_dist:\n                max_min_dist = score\n                best_pos = trial\n    centers[25] = best_pos\n\n    radii = np.ones(n) * r_init\n\n    for pass_outer in range(13):  # up from 10\n        # Shrink radii to fit within square\n        for i in range(n):\n            x, y = centers[i]\n            r_max = min(x, y, 1 - x, 1 - y)\n            if radii[i] > r_max:\n                radii[i] = r_max\n\n        # Overlap resolution\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-9:\n                    excess = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        shrink_i = radii[i] / total * excess\n                        shrink_j = radii[j] / total * excess\n                        radii[i] -= shrink_i\n                        radii[j] -= shrink_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # Greedy growing\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-10:\n                    possible = d - radii[j]\n                    if possible < max_r:\n                        max_r = possible\n            radii[i] = max(0, min(radii[i], max_r))\n\n    # Final validity cleanup\n    radii = np.clip(radii, 0, None)\n    for i in range(n):\n        x, y = centers[i]\n        if not (radii[i] <= x <= 1 - radii[i] and radii[i] <= y <= 1 - y):\n            max_r = min(x, y, 1 - x, 1 - y)\n            radii[i] = max(0, min(radii[i], max_r))\n\n    # Final overlap fix (as before)\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-7:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-12:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n    # Mini local greedy grow for the last polish\n    for i in range(n):\n        max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n        for j in range(n):\n            if i == j: continue\n            d = np.linalg.norm(centers[i] - centers[j])\n            if d > 1",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 72,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    # Slightly larger initial radius\n    r_init = 0.037  # was 0.035\n    \n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n    \n    # First shell: 8\n    R1 = 0.185  # slightly closer-in, allows outer shell to move in\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n        \n    # Second shell: 12\n    R2 = 0.39  # slightly smaller, so shells are tighter\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/12)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 5 circles near corners but slightly inset and rotated (use an angle so they sit out of the way)\n    corner_distance = 0.93  # but bring them in by 0.02\n    offset = 0.05\n    corner_angles = [\n        np.arctan2(0.5 - 0, 0.5 - 0),\n        np.arctan2(0.5 - 0, 1 - 0.5),\n        np.arctan2(1 - 0.5, 1 - 0.5),\n        np.arctan2(1 - 0.5, 0.5 - 0),\n        np.pi / 2 # top center\n    ]\n    corner_positions = [\n        [offset, offset],\n        [1.0 - offset, offset],\n        [1.0 - offset, 1.0 - offset],\n        [offset, 1.0 - offset],\n        [0.5, 1.0 - offset]\n    ]\n    for i in range(5):\n        centers[idx] = corner_positions[i]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n    \n    max_iters = 70  # was 53\n    grow_amt = 0.031  # just a touch less inflation for more steps\n    for it in range(max_iters):\n        # Shrink inflation step slowly as system settles\n        inflation = grow_amt * (1 - it / max_iters) * 0.85 + 0.0037\n        \n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation (random ordering for more local max escape)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radi",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 73,
    "parent_id": 18,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved iterative version, focusing on:\n    - Stricter overlap and wall constraints.\n    - After shrinking/expanding, assert all circles are valid/non-overlapping.\n    - Slight experimental relocation of the 26th circle.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Expanded rings\n    inner_ring_r = 0.2535\n    outer_ring_r = 0.432\n    \n    # Inner ring (8)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i+1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Outer ring (16)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i+9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # Place 26th circle at an empty location: directly at top edge, offset from corners\n    centers[25] = [0.5, 0.956]\n    \n    r_min = 0.0075\n\n    # Initial radii: maximize to squares with margin\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.9855  # slightly increased safety margin\n\n    # Proximity shrink pass, more aggressive for safety\n    for it in range(5):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * 0.993:  # Harsher\n                    # Shrink the *larger* radius in the pair only\n                    if radii[i] > radii[j]:\n                        radii[i] = max(r_min, dist * 0.993 - radii[j])\n                    else:\n                        radii[j] = max(r_min, dist * 0.993 - radii[i])\n        # Clamp to wall constraint after each pass\n        for i in range(n):\n            rx, ry = centers[i]\n            radii[i] = min(radii[i], rx, ry, 1 - rx, 1 - ry)\n            radii[i] = max(radii[i], r_min)\n\n    # Expansion refinement: for each circle, maximize radius (with margin)\n    for iter_expand in range(6):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            # Use margin again\n            radii[i] = max(r_min, min(radii[i], max_r * 0.993))\n        # Clamp \n        for i in range(n):\n            rx, ry = centers[i]\n            radii[i] = min(radii[i], rx, ry, 1 - rx, 1 - ry)\n            radii[i] = max(radii[i], r_min)\n    \n    # Final legality check: shrink ALL radii by a minuscule final margin if *any* overlap or out of bounds\n    def valid(centers, radii):\n        for i in range(n):\n            x, y = centers[i]\n            r = radii[i]\n            if r < r_min - 1e-9 or x - r < -1e-9 or y - r < -1e-9 or x + r > 1 + 1e-9 or y + r > 1 + 1e-9:\n                return False\n            for j in range(i+1, n):\n                if np.linalg.norm(centers[i] - centers[j]) < radii[i] + radii[j] - 1e-9:\n                    return False\n        return True\n\n    safety_down = 1.0\n    while not valid(centers, radii):\n        safety_down *= 0.999\n        radii *= safety_down\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.8990033407023716,
      "additional_data": {
        "sum_radii": "1.899003",
        "target_ratio": "0.720684",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 74,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    r_init = 0.037  # Slightly larger initial radius\n    \n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n    \n    # First shell: 8\n    R1 = 0.22  # Slightly farther out than before\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n        \n    # Second shell: 10 (not 12)\n    R2 = 0.415\n    for i in range(10):\n        angle = 2 * np.pi * i / 10 + (np.pi/10)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # 7 edge/corner-based circles\n    # Four corners, and three on edges between corners\n    extra = np.array([\n        [0.07, 0.07],\n        [0.93, 0.07],\n        [0.93, 0.93],\n        [0.07, 0.93],\n        [0.5, 0.065],  # Top edge\n        [0.5, 0.935],  # Bottom edge\n        [0.065, 0.5],  # Left edge\n        [0.935, 0.5],  # Right edge\n    ])\n    for i in range(n - idx):\n        centers[idx] = extra[i]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n    \n    max_iters = 63  # Slightly more iterations\n    grow_amt = 0.028 # Slightly gentler inflation\n    for it in range(max_iters):\n        # Shrink inflation step slowly as system settles\n        inflation = grow_amt * (1 - it / max_iters) * 0.9 + 0.0035\n        \n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation (random ordering for more local max escape)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n    \n    # Border enforcement\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        if radii[i] > max_r:\n            radii[i] = max(0, max_r)\n\n    radii = np.clip(radii, 0, None)\n    sum_radii = np.sum(radii)\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 2.039206708041321,
      "additional_data": {
        "sum_radii": "2.039207",
        "target_ratio": "0.773892",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 75,
    "parent_id": 50,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    r_init = 0.035  # Start slightly larger for aggressive fill\n\n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n\n    # First shell: 8 (arranged in a regular octagon)\n    R1 = 0.220\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle), 0.5 + R1 * np.sin(angle)]\n        idx += 1\n\n    # Second shell: 12 (with phase shift)\n    R2 = 0.425\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi / 24)\n        centers[idx] = [0.5 + R2 * np.cos(angle), 0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 5 circles, near corners and one at top edge midpoint\n    eps = 0.035  # closer to the edge now\n    corners = np.array([\n        [eps, eps],\n        [1-eps, eps],\n        [1-eps, 1-eps],\n        [eps, 1-eps],\n        [0.5, 1-eps]\n    ])\n    for i in range(5):\n        centers[idx] = corners[i]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n\n    max_iters = 65\n    grow_amt = 0.037\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.85 + 0.003\n\n        # Keep all circles inside bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # Resolve overlaps by shrinking both circles involved\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n        # Uniform inflation (shuffle for randomness)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n\n    # Final border clean-up\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap resolve\n    for i in range(n):\n        for j in range(i+1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        if radii[i] > max_r:\n            radii[i] = max(0, max_r)\n    radii = np.clip(radii, 0, None)\n\n    # Final \"greedy inflation\": for each circle, quickly grow until you hit a boundary or a neighbor\n    for idx_i in np.random.permutation(n):\n        x, y = centers[idx_i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        for j in range(n):\n            if idx_i == j:\n                continue\n            d = np.linalg.norm(centers[idx_i] - centers[j])\n            if d - radii[j] < max_r:\n                max_r = max(0, d - radii[j])\n        radii[idx_i] = max_r\n\n    sum_r",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: name 'sum_r' is not defined"
      }
    }
  },
  {
    "id": 76,
    "parent_id": 63,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    SMALL ITERATIVE IMPROVEMENT ON PREVIOUS SOLUTION:\n    - inner_ring_r increased to 0.258\n    - outer_ring_r increased to 0.447\n    - 26th circle in NE corner at [0.456, 0.954]\n    - Initial radii factor up to 0.996\n    - expand_margin increased to 0.9976\n    - expansion passes up to 20\n    - shrink_margin to 0.997\n    - r_min lowered to 0.0055\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Rings\n    inner_ring_r = 0.258\n    outer_ring_r = 0.447\n\n    # Inner ring: 8 circles\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Outer ring: 16 circles\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # 26th circle (index 25): move it further into NE corner\n    centers[25] = [0.456, 0.954]\n\n    r_min = 0.0055\n\n    # Slightly bigger initial radii factor\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.996  # Slight increase\n\n    shrink_margin = 0.997\n    for it in range(10):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required = (radii[i] + radii[j])\n                if required > dist * shrink_margin:\n                    excess = required - dist * shrink_margin\n                    total = radii[i] + radii[j]\n                    if total > 0:\n                        frac_i = radii[i] / total\n                        frac_j = radii[j] / total\n                        radii[i] = max(r_min, radii[i] - excess * frac_i)\n                        radii[j] = max(r_min, radii[j] - excess * frac_j)\n                    else:\n                        radii[i] = radii[j] = r_min\n\n    expand_margin = 0.9976  # More aggressive\n    for iter_expand in range(20):  # More passes to converge\n        for i in range(n):\n            # Distance to wall\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * expand_margin))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.7031955128282057,
      "additional_data": {
        "sum_radii": "1.703196",
        "target_ratio": "0.646374",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 77,
    "parent_id": 40,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Outer ring: 16 circles, radius 0.436 (more aggressive)\n    - Inner ring: radius 0.227 (was 0.22)\n    - Corner margin: 0.098 (was 0.11)\n    - Tighter pairwise repulsion: 0.9995\n    - More greedy passes (12, was 8)\n    \"\"\"\n\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Center\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring: 8 circles\n    inner_ring_r = 0.227\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Outer ring: 16 circles\n    outer_ring_r = 0.436\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # Two more: corners, tighter in\n    margin = 0.098\n    centers[25 - 1] = [margin, margin]\n    centers[25] = [1 - margin, 1 - margin]\n\n    r_min = 0.008\n\n    # Initial radii: reach to nearest wall\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n\n    # Pairwise shrinkage (almost touching allowed, 0.9995)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.9995:\n                scale = (dist * 0.9995) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # More greedy repasses (12 instead of 8)\n    for pass_num in range(12):\n        for i in range(n):\n            # Max possible by border\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.9995))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.686153489169165,
      "additional_data": {
        "sum_radii": "1.686153",
        "target_ratio": "0.639906",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 78,
    "parent_id": 61,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    SMALL ITERATIVE IMPROVEMENT on prior method:\n    - Central circle radius slightly increased.\n    - Inner ring radius increased to 0.254.\n    - Outer ring radius increased to 0.446.\n    - 26th circle moved to [0.459, 0.958].\n    - Slightly less conservative initial shrink (0.997).\n    - More expand passes (12), more shrink passes (10).\n    - Margins tightened: shrink_margin=0.999, expand_margin=0.998.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    inner_ring_r = 0.254\n    outer_ring_r = 0.446\n\n    # Inner ring: 8 circles\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Outer ring: 16 circles\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # 26th circle: nudge further to the NE boundary\n    centers[25] = [0.459, 0.958]\n\n    r_min = 0.0060\n\n    # Set initial radii\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.997  # Slightly less aggressive shrink on start\n\n    # Shrink to prevent overlaps\n    shrink_margin = 0.999\n    for it in range(10):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required = (radii[i] + radii[j])\n                if required > dist * shrink_margin:\n                    excess = required - dist * shrink_margin\n                    total = radii[i] + radii[j]\n                    if total > 0:\n                        frac_i = radii[i] / total\n                        frac_j = radii[j] / total\n                        radii[i] = max(r_min, radii[i] - excess * frac_i)\n                        radii[j] = max(r_min, radii[j] - excess * frac_j)\n                    else:\n                        radii[i] = radii[j] = r_min\n\n    # Expand radii greedily to wall/neighbor, but not to overlap\n    expand_margin = 0.998\n    for iter_expand in range(12):\n        for i in range(n):\n            # Distance to wall\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * expand_margin))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.6954460624418646,
      "additional_data": {
        "sum_radii": "1.695446",
        "target_ratio": "0.643433",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 79,
    "parent_id": 70,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Finer-tuned ring radii and positions for the 26th circle placement.\n    - Slightly lower r_min for more flexibility.\n    - Margins and number of shrink/expand steps tuned for slightly more aggressive radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Very slightly increased inner/outer ring radii\n    inner_ring_r = 0.2558  # up from 0.2543\n    outer_ring_r = 0.4422  # up from 0.441\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # 26th circle, shifted diagonally toward corner but closer to vertical edge\u2014empirically better\n    centers[25] = [0.412, 0.950]\n\n    # Even smaller r_min for extra flexibility\n    r_min = 0.0045\n\n    # Tweak initial radii up just a bit more\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.9956  # up from 0.9947\n\n    # Slightly tighter shrink margin, one more pass\n    shrink_margin = 0.9976  # up from 0.9973\n    expand_margin = 0.9973  # up from 0.997\n    for it in range(9):  # up from 8\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                required = (radii[i] + radii[j])\n                if required > dist * shrink_margin:\n                    excess = required - dist * shrink_margin\n                    # Shrink both, weighted by current radius size\n                    total = radii[i] + radii[j]\n                    if total > 0:\n                        frac_i = radii[i] / total\n                        frac_j = radii[j] / total\n                        radii[i] = max(r_min, radii[i] - excess * frac_i)\n                        radii[j] = max(r_min, radii[j] - excess * frac_j)\n                    else:\n                        radii[i] = radii[j] = r_min\n\n    # Expansion passes: more aggressive, more passes at the end\n    for iter_expand in range(10):  # up from 8\n        for i in range(n):\n            # Distance to wall\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * expand_margin))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.729161460401545,
      "additional_data": {
        "sum_radii": "1.729161",
        "target_ratio": "0.656228",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 80,
    "parent_id": 77,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved iterative placement and radii adjustment:\n    - Outer ring: 16 circles, radius increased to 0.443\n    - Inner ring: radius increased to 0.232\n    - Corner margin: moved further out (0.08, was 0.098)\n    - Pairwise repulsion factor: 0.9997 (was 0.9995)\n    - More greedy optimization passes (16, was 12)\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Center\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring: 8 circles\n    inner_ring_r = 0.232\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Outer ring: 16 circles\n    outer_ring_r = 0.443\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # Two more: slightly in from corners, further than in original\n    margin = 0.08\n    centers[24] = [margin, margin]\n    centers[25] = [1 - margin, 1 - margin]\n\n    r_min = 0.012  # small bump\n\n    # Initial radii: limited by nearest wall\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n\n    # Pairwise shrinkage (slightly looser)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.9997:\n                scale = (dist * 0.9997) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # More greedy radii optimization passes\n    for pass_num in range(16):\n        for i in range(n):\n            # Max possible by border\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-10:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.9997))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.709990474099339,
      "additional_data": {
        "sum_radii": "1.709990",
        "target_ratio": "0.648953",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 81,
    "parent_id": 31,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Further small iterative improvement:\n    - Move two extra circles closer to corners: (0.055, 0.055) & (0.945, 0.945)\n    - r_inner up slightly to 0.239\n    - r_outer up slightly to 0.467\n    - Initial wall/overlap shrinkage to 0.9994 (less conservative)\n    - Greedy margin to 0.9985\n    - 32 greedy passes\n    - r_min down to 0.006\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles\n    r_inner = 0.239\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n\n    # Outer ring of 15 circles\n    r_outer = 0.467\n    for i in range(15):\n        angle = 2 * np.pi * i / 15\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n\n    # Two extra circles, even closer to the true corners\n    centers[24] = [0.055, 0.055]\n    centers[25] = [0.945, 0.945]\n\n    r_min = 0.006  # Allow for marginal corners\n\n    # Initial wall fitting: as large as possible until wall clipped\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.9994\n\n    # Initial shrink for overlaps (less conservative scaling)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.9994:\n                scale = (dist * 0.9994) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # Aggressive greedy maximizing: 32 passes, tight margin 0.9985\n    for pass_num in range(32):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.9985))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.718309614149747,
      "additional_data": {
        "sum_radii": "1.718310",
        "target_ratio": "0.652110",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 82,
    "parent_id": 68,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    r_init = 0.035\n\n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n\n    # First shell: 8\n    R1 = 0.21\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n\n    # Second shell: 12\n    R2 = 0.41\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/12)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # 5 outermost points: choose strategic spaced placement along edges/corners (removed one corner vs sample)\n    outer_points = np.array([\n        [0.08, 0.08],    # lower left corner\n        [0.92, 0.08],    # lower right corner\n        [0.92, 0.92],    # upper right corner\n        [0.08, 0.92],    # upper left corner\n        [0.5, 0.97],     # top edge center\n        # [0.5, 0.03],   # Remove this to have only 5 and get n=26 total\n    ])\n    for i in range(5):\n        centers[idx] = outer_points[i]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n    for i in range(n-5, n):\n        radii[i] = r_init * 1.07  # slightly larger for close-to-corner/edge points\n\n    max_iters = 56\n    grow_amt = 0.031\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.93 + 0.0038\n\n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n        # 3. Inflation (random ordering for more local max escape)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n\n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap\n                    shrink_j = radii[j] / total * overlap\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], ",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 83,
    "parent_id": 31,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Outer ring radius increased very slightly to 0.468\n    - Corner circles moved nearer to the corners (0.055, 0.055) and (0.945, 0.945)\n    - Greedy expansion margin slightly less conservative (0.9985)\n    - One extra greedy pass (now 26)\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles\n    r_inner = 0.237\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n\n    # Outer ring of 15 circles (now slightly bigger)\n    r_outer = 0.468\n    for i in range(15):\n        angle = 2 * np.pi * i / 15\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n\n    # Two extra circles, even closer to corners\n    centers[24] = [0.055, 0.055]\n    centers[25] = [0.945, 0.945]\n\n    r_min = 0.008  # Prevent degeneration\n\n    # Initial radii: fit to walls\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.9992\n\n    # Shrink for overlaps (conservative step as before)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.9992:\n                scale = (dist * 0.9992) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # Slightly less conservative, and 26 passes\n    for pass_num in range(26):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.9985))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.7068792942485078,
      "additional_data": {
        "sum_radii": "1.706879",
        "target_ratio": "0.647772",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 84,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    # Slightly increased initial radius\n    r_init = 0.042  \n    \n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n    \n    # First shell: 8\n    R1 = 0.22\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n        \n    # Second shell: 12, with larger radius and larger offset\n    R2 = 0.42\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/8)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 6, distribute hexagonally near/beyond corners, staggered to fill gaps\n    corner_angles = np.linspace(0, 2*np.pi, 7)[:-1] + np.pi/12\n    R3 = 0.495\n    for i in range(6):\n        x = 0.5 + R3 * np.cos(corner_angles[i])\n        y = 0.5 + R3 * np.sin(corner_angles[i])\n        # Clamp to the unit square\n        x = np.clip(x, 0.07, 0.93)\n        y = np.clip(y, 0.07, 0.93)\n        centers[idx] = [x, y]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n    \n    max_iters = 60  # more inflation steps\n    grow_amt = 0.035  # initial inflation a bit larger\n    for it in range(max_iters):\n        # Shrink inflation step slowly as system settles\n        inflation = grow_amt * (1 - it / max_iters) * 0.85 + 0.006\n        \n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution (soften correction, distribute overlap less aggressively)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        # Soften shrink factor: only shrink 95% of the required amount\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= 0.95 * overlap * f_i\n                        radii[j] -= 0.95 * overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation (random ordering for more local max escape)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull (again, soften the shrink)\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap * 0.97\n                    shrink_j = radii[j] / total * overlap * 0.97\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n    \n    # Border enforcement\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, ",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 85,
    "parent_id": 83,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Iterative improvement:\n    - Outer ring radius increased to 0.472\n    - Extra circles at (0.045, 0.955) and (0.955, 0.045) (opposite corners)\n    - Inner ring radius slightly reduced to 0.235\n    - 30 iterative passes in radius adjustment\n    - Safety margin slightly less conservative (0.9980)\n    - In overlap step, only shrink the larger of overlapping pair\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles\n    r_inner = 0.235\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n\n    # Outer ring of 15 circles (now slightly bigger)\n    r_outer = 0.472\n    for i in range(15):\n        angle = 2 * np.pi * i / 15\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n\n    # Two extra circles, near opposite corners, slightly nearer to corners\n    centers[24] = [0.045, 0.955]\n    centers[25] = [0.955, 0.045]\n\n    r_min = 0.008  # Prevent degeneration\n\n    # Initial radii: fit to walls\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.9992\n\n    # Overlap shrink: only shrink the larger radius\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.9992:\n                scale = (dist * 0.9992) / (radii[i] + radii[j])\n                if radii[i] > radii[j]:\n                    radii[i] *= scale\n                else:\n                    radii[j] *= scale\n\n    # Slightly less conservative margin, and 30 passes\n    for pass_num in range(30):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.9980))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.8283364107258704,
      "additional_data": {
        "sum_radii": "1.828336",
        "target_ratio": "0.693866",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 86,
    "parent_id": 52,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    r_init = 0.037  # Initial radius\n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n    \n    # First shell: 8\n    R1 = 0.22\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n        \n    # Second shell: 12\n    R2 = 0.43\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/12)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: pick only 5 from \"corners and edge middles\" to make up 26\n    corners = np.array([\n        [0.07, 0.07],\n        [0.93, 0.07],\n        [0.93, 0.93],\n        [0.07, 0.93],\n        [0.5, 0.07],\n        [0.93, 0.5],\n        [0.5, 0.93],\n        [0.07, 0.5]\n    ])\n    # Pick 5 at random (add jitter to break symmetry)\n    rng = np.random.default_rng()\n    pick_idx = rng.choice(8, 5, replace=False)\n    noise = rng.uniform(-0.015, 0.015, size=(5,2))\n    for i in range(5):\n        centers[idx] = np.clip(corners[pick_idx[i]] + noise[i], 0.04, 0.96)\n        idx += 1\n    \n    radii = np.ones(n) * r_init\n    \n    max_iters = 55\n    grow_amt = 0.031\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.97 + 0.004\n\n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total if total > 0 else 0.5\n                        f_j = radii[j] / total if total > 0 else 0.5\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation (random ordering for more local max escape)\n        order = np.arange(n)\n        rng.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total\n                    shrink_j = radii[j] / total\n                    radii[i] -= overlap * shrink_i\n                    radii[j] -= overlap * shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.086707882648736,
      "additional_data": {
        "sum_radii": "2.086708",
        "target_ratio": "0.791920",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 87,
    "parent_id": 84,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    # Increase initial radius a bit more\n    r_init = 0.048\n    \n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n    \n    # First shell: 8\n    R1 = 0.22\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n        \n    # Second shell: 12\n    R2 = 0.415\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/8)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 6 near corners, allow closer to edge\n    corner_angles = np.linspace(0, 2*np.pi, 7)[:-1] + np.pi/12\n    R3 = 0.493\n    for i in range(6):\n        x = 0.5 + R3 * np.cos(corner_angles[i])\n        y = 0.5 + R3 * np.sin(corner_angles[i])\n        # Wider clamp\n        x = np.clip(x, 0.065, 0.935)\n        y = np.clip(y, 0.065, 0.935)\n        centers[idx] = [x, y]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n    \n    max_iters = 80  # more inflation steps\n    grow_amt = 0.036  # slightly larger\n    for it in range(max_iters):\n        # Shrink inflation step slowly as system settles\n        inflation = grow_amt * (1 - it / max_iters) * 0.85 + 0.007\n        \n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution (remove soften, use 1.0)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-13:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= 1.0 * overlap * f_i\n                        radii[j] -= 1.0 * overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation (random ordering for more local max escape)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull (remove soften, use 1.0)\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-10:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i] / total * overlap * 1.0\n                    shrink_j = radii[j] / total * overlap * 1.0\n                    radii[i] -= shrink_i\n                    radii[j] -= shrink_j\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n\n    # Final border enforcement\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 88,
    "parent_id": 43,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved arrangement of 26 circles in unit square to maximize sum of radii (small iterative improvement).\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    # Parameters for shell construction\n    r1 = 0.241  # slightly larger inner ring radius\n    r2 = 0.424  # slightly larger outer ring radius\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # 8 circles: inner ring, start from top\n    for i in range(8):\n        angle = np.pi/8 + 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r1 * np.cos(angle), 0.5 + r1 * np.sin(angle)]\n\n    # 16 circles: outer ring\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + r2 * np.cos(angle), 0.5 + r2 * np.sin(angle)]\n\n    # One more: near top, but less directly above to reduce overlap\n    centers[25] = [0.5, 0.91 - 0.008]\n\n    # Give each shell a slightly different starting radius\n    radii = np.full(n, 0.070)\n    radii[0] = 0.073  # central circle a bit larger\n    radii[1:9] = 0.070  # inner ring\n    radii[9:25] = 0.067  # outer ring\n    radii[25] = 0.066  # \"cap\" circle\n    r_min = 0.01\n\n    # Iterative correction and expansion\n    for iter_ in range(13):  # a few more iterations\n        # Step 1: Shrink if necessary to avoid square border\n        for i in range(n):\n            x, y = centers[i]\n            max_r = min(x, y, 1 - x, 1 - y)\n            radii[i] = min(radii[i], max_r)\n\n        # Step 2: Shrink to resolve overlaps\n        for i in range(n):\n            for j in range(i+1, n):\n                dx = centers[i,0] - centers[j,0]\n                dy = centers[i,1] - centers[j,1]\n                d = np.hypot(dx, dy)\n                if d < 1e-8:\n                    # Overlapping centers; resolve\n                    radii[i] = min(radii[i], 0.01)\n                    radii[j] = min(radii[j], 0.01)\n                elif radii[i] + radii[j] > d * 0.999:\n                    # Only reduce the larger radius (or both if equal)\n                    excess = radii[i] + radii[j] - d * 0.999\n                    if radii[i] > radii[j]:\n                        radii[i] = max(r_min, radii[i] - excess)\n                    elif radii[j] > radii[i]:\n                        radii[j] = max(r_min, radii[j] - excess)\n                    else:\n                        # Same radii\n                        delta = excess/2\n                        radii[i] = max(r_min, radii[i] - delta)\n                        radii[j] = max(r_min, radii[j] - delta)\n        # Step 3: Try to expand each circle gently in available space (greedy local expansion)\n        for i in range(n):\n            # Nearest border\n            x, y = centers[i]\n            max_r = min(x, y, 1 - x, 1 - y)\n            # Nearest neighbor\n            min_gap = max_r\n            for j in range(n):\n                if i != j:\n                    d = np.hypot(centers[i,0] - centers[j,0], centers[i,1] - centers[j,1])\n                    gap = d - radii[j]\n                    if gap < min_gap:\n                        min_gap = gap\n            # Give some safety margin\n            max_possible = max(r_min, min_gap*0.99)\n            radii[i] = min(radii[i] + 0.002, max_possible)\n            radii[i] = max(r_min, min(radii[i], max_r))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.0708330421465377,
      "additional_data": {
        "sum_radii": "2.070833",
        "target_ratio": "0.785895",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 89,
    "parent_id": 3,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement: \n    - Slightly larger rings\n    - Optimize last circle (move into corner/edge if fits)\n    - More careful expansion\n    - Outer ring nudged toward corners\n    - 3 expansion passes\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Slightly expand inner and outer ring radii for fuller packing\n    inner_ring_r = 0.247  # up from 0.245\n    outer_ring_r = 0.426  # up from 0.415 (test up to edge)\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        # Nudge toward corners if near diagonals\n        offset = 0.012 if (i % 4 == 0) else 0.0\n        r = outer_ring_r + offset\n        centers[i + 9] = [0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)]\n        # Ensure they're inside the square\n        centers[i + 9] = np.clip(centers[i + 9], 0.02, 0.98)\n    \n    # 26th circle - try locations near top and corners, slightly right shifted\n    # Instead of fixed top, try just off top edge, right of center\n    centers[25] = [0.53, 0.915]  # up from 0.5, 0.89; now closer to top edge\n\n    r_min = 0.008\n\n    # Set initial radii: maximize each circle's distance to border\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    # Do not bulk shrink! Instead, do shrinking below.\n\n    # Improved proximity shrink: shrink only the larger of a too-close pair\n    for it in range(2):  # Two passes help resolve conflicts\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * 0.995:  # previously 0.99, now less aggressive\n                    # Only shrink the larger radius\n                    if radii[i] > radii[j]:\n                        radii[i] = max(r_min, dist * 0.995 - radii[j])\n                    else:\n                        radii[j] = max(r_min, dist * 0.995 - radii[i])\n\n    # Greedy and more careful expansion pass for each circle: 3 sweeps\n    for iter_expand in range(3):\n        for i in range(n):\n            # Distance to wall constraint\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            # Safety margin\n            radii[i] = max(r_min, min(radii[i], max_r * 0.997))  # looser than before, 0.997\n\n    # Nudge outermost circles toward their nearest edge if they are not flush (to add a smidge of room)\n    for i in range(9, 25):\n        # Find direction to closest wall\n        x, y = centers[i]\n        closest_x = 0 if x < 0.5 else 1\n        closest_y = 0 if y < 0.5 else 1\n        dx = closest_x - x\n        dy = closest_y - y\n        norm = np.sqrt(dx*dx + dy*dy)\n        if norm > 1e-8:\n            shift = 0.004  # bump slightly outward\n            nx, ny = dx / norm, dy / norm\n            newx = np.clip(x + shift * nx, 0+r_min, 1-r_min)\n            newy = np.clip(y + shift * ny, 0+r_min, 1-r_min)\n            # Only nudge if it doesn't worsen distance to other centers\n            conflict = False\n            for j in range(n):\n                if j == i:\n                    continue\n                if np.linalg.norm([newx - centers[j][0], newy - centers[j][1]]) < radii[i] + radii[j] + 1e-4:\n                    conflict = True\n                    break\n            if not conflict:\n                centers[i,0] = newx\n                centers[i,1] = newy\n\n    # Final small expansion step, as above\n    for iter_expand in range(1):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1],",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 90,
    "parent_id": 81,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Move two extra circles even closer to corners: (0.045, 0.045) & (0.952, 0.952)\n    - r_inner up to 0.241\n    - r_outer up to 0.470\n    - Initial wall/overlap shrinkage lifted to 0.9996 (less conservative)\n    - Greedy margin loosened to 0.9987\n    - 36 greedy passes\n    - r_min down to 0.0055\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles\n    r_inner = 0.241\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n\n    # Outer ring of 15 circles\n    r_outer = 0.470\n    for i in range(15):\n        angle = 2 * np.pi * i / 15\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n\n    # Two extra circles, even closer to the true corners (slightly asymmetric)\n    centers[24] = [0.045, 0.045]\n    centers[25] = [0.952, 0.952]\n\n    r_min = 0.0055  # Allow for marginal corners\n\n    # Initial wall fitting: as large as possible until wall clipped\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.9996\n\n    # Initial shrink for overlaps (less conservative scaling)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.9996:\n                scale = (dist * 0.9996) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # Aggressive greedy maximizing: 36 passes, tight margin 0.9987\n    for pass_num in range(36):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.9987))\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.7052646465492916,
      "additional_data": {
        "sum_radii": "1.705265",
        "target_ratio": "0.647159",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 91,
    "parent_id": 55,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Move inner and outer ring slightly further from center for denser border use\n    - Adjust the 26th circle upward and further left\n    - Reduce initial safety margin for border & expansion steps\n    - Extra greedy expansion pass at full margin to maximize radii\n    - Slightly lower minimal radius\n    - Tiny nudge to central circle's y-location (for edge matching)\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle, slightly nudged up for tighter row packing above\n    centers[0] = [0.5, 0.507]\n\n    # Slightly wider inner ring, outer ring pushed out\n    inner_ring_r = 0.259  # was 0.251\n    outer_ring_r = 0.442  # was 0.430\n\n    # Ring of 8 circles (inner ring)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.507 + inner_ring_r * np.sin(angle)]\n\n    # Ring of 16 circles (outer ring)\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.507 + outer_ring_r * np.sin(angle)]\n\n    # 26th circle: push further upward and left, to the border, for a larger radius\n    centers[25] = [0.45, 0.955]\n\n    r_min = 0.0068  # allow a touch smaller circle if needed\n\n    # Set initial radii: maximize each circle's distance to border\n    margin_wall = 0.993  # slightly looser margin to the wall\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= margin_wall\n\n    # Proximity shrink: shrink only the larger radius for too-close pairs; more passes\n    for it in range(7):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * 0.995:  # slightly looser margin\n                    # Only shrink the larger radius\n                    if radii[i] > radii[j]:\n                        radii[i] = max(r_min, dist * 0.995 - radii[j])\n                    else:\n                        radii[j] = max(r_min, dist * 0.995 - radii[i])\n\n    # Greedy expansion pass for each circle, more passes, looser margin\n    for iter_expand in range(9):\n        for i in range(n):\n            # Distance to wall constraint\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.995))  # slightly looser margin\n\n    # One more MAXIMAL expansion pass at tighter margin for last greedy gain\n    for i in range(n):\n        max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n        for j in range(n):\n            if j == i:\n                continue\n            d = np.linalg.norm(centers[i] - centers[j])\n            if d > 1e-8:\n                max_r = min(max_r, d - radii[j])\n        radii[i] = max(r_min, min(radii[i], max_r * 0.9982))  # push to tighter limit\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.8051132092920499,
      "additional_data": {
        "sum_radii": "1.805113",
        "target_ratio": "0.685052",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 92,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    # Slightly larger initial radius than before to encourage edge crowding\n    r_init = 0.0355\n\n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n\n    # First shell: 8 around center, radius ~0.211 is good\n    R1 = 0.211\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle), 0.5 + R1 * np.sin(angle)]\n        idx += 1\n    \n    # Second shell: 12, radius a touch smaller so they fit slightly in from the boundary\n    R2 = 0.398\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi / 16)  # Slight rotation for tighter fit\n        centers[idx] = [0.5 + R2 * np.cos(angle), 0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Last shell: 5, try better corner/edge utilization\n    corners = np.array([\n        [0.075, 0.075],      # bottom-left, closer to the true corner\n        [0.925, 0.075],      # bottom-right\n        [0.925, 0.925],      # top-right\n        [0.075, 0.925],      # top-left\n        [0.5,   0.96 ]       # top edge center, almost at the wall\n    ])\n    for i in range(5):\n        centers[idx] = corners[i]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n    \n    max_iters = 65       # More refinement steps\n    grow_amt = 0.03\n    for it in range(max_iters):\n        # Shrink inflation step slowly as system settles\n        inflation = grow_amt * (1 - it / max_iters) * 0.86 + 0.003\n\n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation: \n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            cx, cy = centers[idx_i]\n            # Compute spatial factor: if circle is near the wall (<5%), let it expand slightly more\n            wall_dist = min(cx, cy, 1-cx, 1-cy)\n            edge_boost = 1.0\n            if wall_dist < 0.09:\n                edge_boost = 1.13     # modest bonus for edge/corner\n            # Try to grow as far as allowed w.r.t. walls and neighbor overlaps\n            max_r = min(cx, cy, 1 - cx, 1 - cy)\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            # inflation\n            candidate_r = min(max_r, radii[idx_i] + inflation * edge_boost)\n            radii[idx_i] = max(candidate_r, 0)\n    \n    # Final pass to maximize each radius fully given neighbor radii\n    for i in range(n):\n        cx, cy = centers[i]\n        max_r = min(cx, cy, 1 - cx, 1 - cy)\n        for j in range(n):\n            if i == j:\n                continue\n            d = np.linalg.norm(centers[i] - centers[j])\n            if d > 1e-14:\n                candidate = d - radii[j]\n                if candidate < max_r:\n                    max_r = candidate\n        radii[i] = max(0, min(max_r, radii[i]))\n\n    # Final clean-up: in-bounds and overlap\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 93,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    # Slightly larger initial radius\n    r_init = 0.038  \n\n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n\n    # Slight randomization of shell radii (helps break symmetry)\n    rng = np.random.default_rng(seed=1)\n    R1 = 0.21 + rng.uniform(-0.012, 0.012)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        # Slight \"offset\" on each so not perfectly symmetric shell\n        r_offset = rng.uniform(-0.012, 0.012)\n        radius = R1 + r_offset\n        centers[idx] = [0.5 + radius * np.cos(angle),\n                        0.5 + radius * np.sin(angle)]\n        idx += 1\n            \n    R2 = 0.41 + rng.uniform(-0.012, 0.012)\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/12)  # break symmetry\n        r_offset = rng.uniform(-0.011, 0.011)\n        radius = R2 + r_offset\n        centers[idx] = [0.5 + radius * np.cos(angle),\n                        0.5 + radius * np.sin(angle)]\n        idx += 1\n\n    # Four corners, and one at the bottom center\n    corners = np.array([\n        [0.06, 0.06],\n        [0.94, 0.06],\n        [0.94, 0.94],\n        [0.06, 0.94],\n        [0.5, 0.06]\n    ])\n    for i in range(5):\n        centers[idx] = corners[i]\n        idx += 1\n\n    radii = np.ones(n) * r_init\n\n    max_iters = 61  # slightly more inflation steps\n    grow_amt = 0.032\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.92 + 0.004\n\n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation (random ordering for more local max escape)\n        order = np.arange(n)\n        rng.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n        \n        # 4. Micro center \"jiggle\" away from closest non-overlapping neighbor (once every 4 steps)\n        if it % 4 == 1:\n            for i in range(n):\n                closest_dist = np.inf\n                closest_j = -1\n                for j in range(n):\n                    if i == j:\n                        continue\n                    d = np.linalg.norm(centers[i] - centers[j])\n                    if d < closest_dist and d > radii[i] + radii[j] + 0.001:\n                        closest_dist = d\n                        closest_j = j\n                if closest_j >= 0:\n                    v = centers[i] - centers[closest_j]\n                    norm = np.linalg.norm(v)\n                    if norm > 1e-7:\n                        v = v / norm\n                        # push away by a tiny amount if not violating square or overlaps\n                        trial = centers[i] + 0.0015 * v\n                        x, y = trial\n                        if 0 <= x <= 1 and 0 <= y <= 1:\n                            min_r = min(x, y, 1 - x, 1 - y)\n                            # Only shift if does not shrink radius too much\n                            if min_r > radii[i] - 0.003:\n                                centers[i] = trial\n\n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x,",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 94,
    "parent_id": 21,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    ITERATIVE IMPROVEMENT:\n    - Outer ring: 17 circles (was 16), slightly reduced radius\n    - Use all four corners with small circles (was three)\n    - Slightly smaller min radius to allow more corner/crowd flexibility\n    - Less conservative shrink factors (0.994 instead of 0.995)\n    - One extra greedy expand pass at the end\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Inner ring of 8 circles \n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.22 * np.cos(angle), 0.5 + 0.22 * np.sin(angle)]\n    \n    # Outer ring: 17 circles (was 16), slightly smaller radius\n    outer_ring_r = 0.419\n    for i in range(17):\n        angle = 2 * np.pi * i / 17\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # Four corner circles with small margin\n    margin = 0.075\n    centers[25-3] = [margin, margin]\n    centers[25-2] = [1-margin, margin]\n    centers[25-1] = [1-margin, 1-margin]\n    centers[25]   = [margin, 1-margin]\n    \n    # Reduced min radius for better \"fit\"\n    r_min = 0.0065\n\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.990  # keep aggressive initial shrink\n\n    # Pairwise distance pass, slightly tighter (0.994)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.994:\n                scale = (dist * 0.994) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # Greedy expansion, 7 passes (was 6), and less conservative wall margin\n    for pass_num in range(7):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.994))\n            \n    # Final push: move all circles slightly outward from center, then do last radius expand\n    center_pt = np.array([0.5, 0.5])\n    for i in range(1, n):  # skip the central circle\n        vec = centers[i] - center_pt\n        norm = np.linalg.norm(vec)\n        if norm > 1e-7:\n            push = 0.003 * (vec / norm)\n            centers[i] += push\n            # Clamp to [0,1]\n            centers[i][0] = min(max(centers[i][0], 0.0), 1.0)\n            centers[i][1] = min(max(centers[i][1], 0.0), 1.0)\n\n    # Two final greedy expand passes to squeeze in any gained margin\n    for _ in range(2):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.994))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.640784973929292,
      "additional_data": {
        "sum_radii": "1.640785",
        "target_ratio": "0.622689",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 95,
    "parent_id": 64,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    r_init = 0.044  # slightly larger initial radii\n    centers = np.zeros((n, 2))\n    idx = 0\n\n    # Place 4 circles in the corners, slightly inset\n    inset = 0.065\n    corners = [\n        [inset, inset],\n        [1-inset, inset],\n        [1-inset, 1-inset],\n        [inset, 1-inset]\n    ]\n    for c in corners:\n        centers[idx] = c\n        idx += 1\n\n    # Center circle\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n\n    # First shell: 8\n    R1 = 0.20\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle), 0.5 + R1 * np.sin(angle)]\n        idx += 1\n\n    # Second shell: 13 (increased by 1)\n    R2 = 0.41\n    for i in range(13):\n        angle = 2 * np.pi * i / 13 + (np.pi / 13)\n        centers[idx] = [0.5 + R2 * np.cos(angle), 0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Placement of last circle: greedy, farthest from all existing centers and boundaries\n    grid_res = 32\n    search_points = np.stack(np.meshgrid(\n        np.linspace(0.07,0.93,grid_res),\n        np.linspace(0.07,0.93,grid_res)\n    ), axis=-1).reshape(-1,2)\n    dists = []\n    for pt in search_points:\n        m = np.min(np.linalg.norm(centers[:idx] - pt, axis=1))\n        m = min(m, pt[0], pt[1], 1-pt[0], 1-pt[1])\n        dists.append(m)\n    best_idx = np.argmax(dists)\n    centers[idx] = search_points[best_idx]\n    idx += 1\n\n    assert idx == n\n\n    radii = np.ones(n) * r_init\n    \n    max_iters = 82  # more iterations\n    grow_amt = 0.0285  # more conservative inflation\n\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.9 + 0.0035\n\n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    radii[i] -= overlap/2\n                    radii[j] -= overlap/2\n                    radii[i] = max(radii[i], 0)\n                    radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation (random order)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final clean up: boundary enforcement\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                radii[i] -= overlap/2\n                radii[j] -= overlap/2\n                radii[i] = max(radii[i], 0)\n                radii[j] = max(radii[j], 0)\n    \n    # Border enforcement again\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        if radii[i] > max_r:\n            radii[i] = max(0, max_r)\n\n    radii = np.clip(radii, 0, None)\n    sum_radii = np.sum(radii)\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: index 26 is out of bounds for axis 0 with size 26"
      }
    }
  },
  {
    "id": 96,
    "parent_id": 20,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Slight improvement: \n    - bump outer ring radius,\n    - push lone circle closer to edge,\n    - start with larger initial radii,\n    - finer overlap/expansion factors.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles (inner ring), slightly nudged outward\n    r_inner = 0.25\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n    \n    # Ring of 16 circles (outer ring), slightly expanded further\n    r_outer = 0.423\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n    \n    # One additional circle: pushed to very top, still inside\n    centers[25] = [0.5, 0.93]  # maximal y before hitting edge\n    \n    r_min = 0.008\n    \n    # Initial radii: distance to closest wall, slightly optimistic scale\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.996  # slightly more aggressive than before\n    \n    # First overlap resolution pass (even less aggressive)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if dist < 1e-8:\n                continue\n            if radii[i] + radii[j] > dist * 0.999:  # only tiny nudge\n                scale = (dist * 0.999) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    # More greedy improvement passes (expand radii)\n    for _ in range(6):  # two extra passes\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r * 0.998))  # slightly less conservative\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "invalid",
        "error": "Invalid packing (overlaps or out of bounds)"
      }
    }
  },
  {
    "id": 97,
    "parent_id": 82,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    # Give larger starting radius than before, but depend on circle's position\n    r_base = 0.036 \n\n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n\n    # First shell: 8\n    R1 = 0.21\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n\n    # Second shell: 12\n    R2 = 0.41\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi/12)\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # 5 outermost points: corners+center-top\n    outer_points = np.array([\n        [0.08, 0.08],    # lower left corner\n        [0.92, 0.08],    # lower right corner\n        [0.92, 0.92],    # upper right corner\n        [0.08, 0.92],    # upper left corner\n        [0.5, 0.97],     # top edge center\n    ])\n    for i in range(5):\n        centers[idx] = outer_points[i]\n        idx += 1\n\n    ## Initialize radii based on wall proximity:\n    radii = np.zeros(n)\n    for i in range(n):\n        x, y = centers[i]\n        # Try to make initial radius ~80% of maximum possible just from walls\n        r_wall = min(x, y, 1 - x, 1 - y)\n        radii[i] = min(r_base, 0.8 * r_wall)\n    # Bump up the outermost points slightly (they're not crowded)\n    for i in range(n-5, n):\n        radii[i] *= 1.11\n\n    max_iters = 62  # just a few more than before\n    grow_amt = 0.0335\n\n    rng = np.random.default_rng(42)  # Deterministic for reproducibility\n\n    min_rad = 1e-3  # CHANGED: do not allow circles to shrink below this\n\n    for it in range(max_iters):\n        inflation = grow_amt * (1 - it / max_iters) * 0.96 + 0.0026\n\n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = max(rmax, min_rad)\n\n        # 2. Overlap resolution (prevents negative radii)\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] = max(radii[i] - overlap * f_i, min_rad)\n                        radii[j] = max(radii[j] - overlap * f_j, min_rad)\n\n        # 3. Inflation (random ordering for more local max escape)\n        order = np.arange(n)\n        rng.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            new_r = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(new_r, min_rad)\n\n    # Final clean-up: multiple passes to remove all tiny overlaps/outs\n    for cleanup in range(6):\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = max(rmax, min_rad)\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-9:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-10:\n                        shrink_i = radii[i] / total * overlap\n                        shrink",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 98,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    # Slightly larger initial radius than before\n    r_init = 0.038  # Was 0.035\n    \n    centers = np.zeros((n, 2))\n    idx = 0\n    centers[idx] = [0.5, 0.5]\n    idx += 1\n    \n    # First shell: 8\n    R1 = 0.205  # slightly tighter\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = [0.5 + R1 * np.cos(angle),\n                        0.5 + R1 * np.sin(angle)]\n        idx += 1\n        \n    # Second shell: 11 (was 12)\n    R2 = 0.403\n    for i in range(11):\n        angle = 2 * np.pi * i / 11 + (np.pi/11)  # Break symmetry for more efficient coverage\n        centers[idx] = [0.5 + R2 * np.cos(angle),\n                        0.5 + R2 * np.sin(angle)]\n        idx += 1\n\n    # Next: 4 corners + 4 edge centers\n    corners = np.array([\n        [0.07, 0.07],\n        [0.93, 0.07],\n        [0.93, 0.93],\n        [0.07, 0.93]\n    ])\n    edge_centers = np.array([\n        [0.5, 0.07],\n        [0.5, 0.93],\n        [0.07, 0.5],\n        [0.93, 0.5]\n    ])\n    for i in range(4):\n        centers[idx] = corners[i]\n        idx += 1\n    for i in range(4):\n        centers[idx] = edge_centers[i]\n        idx += 1\n\n    # We should now have 1 + 8 + 11 + 4 + 4 = 28,\n    # but original had 5 \"corner\" points; so total now is 1+8+11+4+4=28, so remove 2 from shell2\n    # Actually, we did only 11 in shell2 (vs 12), so it matches 1+8+11+4+4=28, so we need to remove 2\n    # We'll skip the last 2 centers at the edge (keep only 2, not 4).\n    # Instead, to keep at 26, add only the first 2 edge centers:\n    idx = 1+8+11+4\n    edge_centers = edge_centers[:2]\n\n    for i in range(2):\n        centers[idx] = edge_centers[i]\n        idx += 1\n\n    # Now we have exactly 26.\n\n    radii = np.ones(n) * r_init\n    \n    max_iters = 70  # was 53\n    grow_amt = 0.035  # slight increase\n    \n    for it in range(max_iters):\n        # Shrink inflation step slowly as system settles\n        inflation = grow_amt * (1 - it / max_iters) * 0.92 + 0.0045\n        \n        # 1. Restrict to in-bounds\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # 2. Overlap resolution\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n        \n        # 3. Inflation (random ordering for more local max escape)\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(centers[idx_i][0], centers[idx_i][1], 1 - centers[idx_i][0], 1 - centers[idx_i][1])\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation)\n            radii[idx_i] = max(radii[idx_i], 0)\n    \n    # Final clean-up: shrink any that poke out of the bounds\n    for i in range(n):\n        x, y = centers[i]\n        rmax = min(x, y, 1 - x, 1 - y)\n        if radii[i] > rmax:\n            radii[i] = rmax\n\n    # Final overlap cull\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(centers[i] - centers[j])\n            min_dist = radii[i] + radii[j]\n            if d < min_dist - 1e-9:\n                overlap = min_dist - d\n                total = radii[i] + radii[j]\n                if total > 1e-10:\n                    shrink_i = radii[i]",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: index 26 is out of bounds for axis 0 with size 26"
      }
    }
  },
  {
    "id": 99,
    "parent_id": 30,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement: make the ellipse even more corner-reaching,\n    adjust wall squeeze, more passes, and give a touch more to center.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # 1 center\n    centers[0] = [0.5, 0.5]\n    \n    # Arrange: 10 inner ring, 15 outer ring (same as before)\n    inner_count = 10\n    outer_count = 15\n    assert 1 + inner_count + outer_count == n\n\n    # Slightly higher radii for rings\n    inner_ring_r = 0.249  # up a hair\n    # Make ellipse for outer ring more corner-reaching\n    outer_ring_rx = 0.425   # horizontal outer radius\n    outer_ring_ry = 0.438   # vertical outer radius (more elliptical)\n    \n    # Inner ring (circular, centered)\n    for i in range(inner_count):\n        angle = 2 * np.pi * i / inner_count\n        centers[1 + i] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Outer ring (elliptical toward corners)\n    for i in range(outer_count):\n        angle = 2 * np.pi * i / outer_count\n        cx = 0.5 + outer_ring_rx * np.cos(angle)\n        cy = 0.5 + outer_ring_ry * np.sin(angle)\n        centers[1 + inner_count + i] = [cx, cy]\n\n    r_min = 0.009  # up slightly, helps avoid arresting growth with tiny circles\n\n    # Slightly less conservative margin\n    wall_margin = 0.997\n\n    # Initial wall squeeze\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= wall_margin\n\n    # Give center a little expansion bonus\n    radii[0] *= 1.052  # boost center (stays far from wall)\n\n    # Improved proximity shrink: shrink only the bigger circle, 4 passes, tighter test\n    for it in range(4):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * wall_margin:\n                    # Only shrink the larger one\n                    if radii[i] > radii[j]:\n                        radii[i] = max(r_min, dist * wall_margin - radii[j])\n                    else:\n                        radii[j] = max(r_min, dist * wall_margin - radii[i])\n\n    # Expansion pass for each circle (4 times, more even fill)\n    for iter_expand in range(4):\n        for i in range(n):\n            # Distance to wall constraint\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            # Distance to other circles\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-8:\n                    max_r = min(max_r, d - radii[j])\n            # Safety margin\n            radii[i] = max(r_min, min(radii[i], max_r * wall_margin))\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.8717603256491753,
      "additional_data": {
        "sum_radii": "1.871760",
        "target_ratio": "0.710345",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 100,
    "parent_id": 25,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    # Initial radii: bigger for shells and corners, help \"seed\" final packing\n    r_init_outer = 0.051\n    r_init_inner = 0.041\n    r_init_core = 0.0455  # Bigger than shell, small enough not to starve shell\n\n    centers = np.zeros((n, 2))\n    radii = np.zeros(n)\n    idx = 0\n    # Center circle\n    centers[idx] = [0.5, 0.5]\n    radii[idx] = r_init_core\n    idx += 1\n    \n    # First shell: 8 (octagon at radius R1)\n    R1 = 0.197\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[idx] = np.array([0.5, 0.5]) + R1 * np.array([np.cos(angle), np.sin(angle)])\n        radii[idx] = r_init_inner\n        idx += 1\n\n    # Second shell: 12, at a wider radius R2, staggered\n    R2 = 0.39\n    for i in range(12):\n        angle = 2 * np.pi * i / 12 + (np.pi / 12)\n        centers[idx] = np.array([0.5, 0.5]) + R2 * np.array([np.cos(angle), np.sin(angle)])\n        # Slightly larger radii for those at high |x| or |y|\n        bias = max(abs(centers[idx][0] - 0.5), abs(centers[idx][1] - 0.5))\n        radii[idx] = r_init_inner + 0.009 * bias * 3.1\n        idx += 1\n\n    # Last shell: 8 at corners+edge-midpoints, slightly indented\n    offset = 0.055  # Slight corner inset\n    mids = [\n        [0.5, offset],\n        [0.5, 1 - offset],\n        [offset, 0.5],\n        [1 - offset, 0.5],\n    ]\n    corners = [\n        [offset, offset],\n        [1 - offset, offset],\n        [1 - offset, 1 - offset],\n        [offset, 1 - offset],\n    ]\n    for pt in corners + mids:\n        centers[idx] = pt\n        radii[idx] = r_init_outer\n        idx += 1\n\n    # Make sure we've got all circles\n    assert idx == n\n\n    max_iters = 82\n    grow_amt = 0.031\n    for it in range(max_iters):\n        # Shrink inflation step slowly as system settles\n        inflation = grow_amt * (1 - it / max_iters) * 0.92 + 0.005\n        # Squeeze radii to fit in box\n        for i in range(n):\n            x, y = centers[i]\n            rmax = min(x, y, 1 - x, 1 - y)\n            if radii[i] > rmax:\n                radii[i] = rmax\n\n        # Overlap resolution\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                min_dist = radii[i] + radii[j]\n                if d < min_dist - 1e-12:\n                    overlap = min_dist - d\n                    total = radii[i] + radii[j]\n                    if total > 1e-12:\n                        f_i = radii[i] / total\n                        f_j = radii[j] / total\n                        radii[i] -= overlap * f_i\n                        radii[j] -= overlap * f_j\n                        radii[i] = max(radii[i], 0)\n                        radii[j] = max(radii[j], 0)\n\n        # Inflate in random order\n        order = np.arange(n)\n        np.random.shuffle(order)\n        for idx_i in order:\n            max_r = min(\n                centers[idx_i][0], centers[idx_i][1],\n                1 - centers[idx_i][0], 1 - centers[idx_i][1]\n            )\n            for j in range(n):\n                if idx_i == j:\n                    continue\n                d = np.linalg.norm(centers[idx_i] - centers[j])\n                if d > 1e-14:\n                    candidate = d - radii[j]\n                    if candidate < max_r:\n                        max_r = candidate\n            # Slightly bias inflation for corner+mid circles for first 1/3 of iterations\n            bias = 1.0\n            if it < max_iters // 3 and idx_i >= (1+8+12):\n                bias = 1.07\n            radii[idx_i] = min(max_r, radii[idx_i] + inflation * bias)\n            radii[idx_i] = max(radii[idx_i], 0)\n\n    # Final in-box cull\n    for i in range(n):\n        x, y = centers",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: index 26 is out of bounds for axis 0 with size 26"
      }
    }
  },
  {
    "id": 101,
    "parent_id": 22,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Iterative tweak:\n    - Slightly increase the outer ring and decrease the inner ring\n    - Place extra circles at more optimal off-diagonal, asymmetric spots\n    - Use slightly less shrinkage during overlap adjustment\n    - Perform extra greedy maximization passes (17 passes)\n    - Lower r_min for more aggressive fill\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles, radius tuned slightly smaller\n    r_inner = 0.232\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r_inner * np.cos(angle), 0.5 + r_inner * np.sin(angle)]\n\n    # Outer ring of 15 circles slightly *further* out\n    r_outer = 0.462\n    for i in range(15):\n        angle = 2 * np.pi * i / 15\n        centers[i + 9] = [0.5 + r_outer * np.cos(angle), 0.5 + r_outer * np.sin(angle)]\n\n    # Place extra 2 circles close to two different corners, but off-diagonal to avoid cluster\n    centers[24] = [0.09, 0.93]\n    centers[25] = [0.93, 0.09]\n\n    r_min = 0.006  # More aggressive (smaller) minimal radius\n\n    # Initial radii, push slightly closer to wall\n    radii = np.array([max(r_min, min(x, y, 1 - x, 1 - y)) for x, y in centers])\n    radii *= 0.999  # slightly less shrinkage\n\n    # Overlap adjustment -- gentler shrinkage than before\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist * 0.999:\n                scale = (dist * 0.999) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # More maximization passes (17) to let the fill expand\n    for pass_num in range(17):\n        for i in range(n):\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            for j in range(n):\n                if j == i:\n                    continue\n                d = np.linalg.norm(centers[i] - centers[j])\n                if d > 1e-10:\n                    max_r = min(max_r, d - radii[j])\n            radii[i] = max(r_min, min(radii[i], max_r*0.998))  # slightly less greedy than before\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.7027227555308992,
      "additional_data": {
        "sum_radii": "1.702723",
        "target_ratio": "0.646195",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  }
]