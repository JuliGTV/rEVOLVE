[
  {
    "id": 1,
    "parent_id": null,
    "solution": "import numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct arrangement of 26 circles in unit square to maximize sum of radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n    \n    # Ring of 16 circles\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.4 * np.cos(angle), 0.5 + 0.4 * np.sin(angle)]\n    \n    # One additional circle\n    centers[25] = [0.5, 0.85]\n    \n    # Ensure all circles are well within the unit square\n    centers = np.clip(centers, 0.1, 0.9)\n    \n    # Calculate radii\n    n = centers.shape[0]\n    radii = np.ones(n) * 0.05  # Start with small radii\n    \n    # Limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y, 0.08)\n    \n    # Limit by distance to other circles\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist * 0.95:  # Leave small gap\n                scale = (dist * 0.95) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.780464893137411,
      "additional_data": {
        "sum_radii": "1.780465",
        "target_ratio": "0.675698",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 2,
    "parent_id": 1,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Iterative improvement: Apply multiple passes of the pairwise radii scaling to reduce overlap\n    and increase individual radii, maximizing the sum.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n    \n    # Ring of 16 circles\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.4 * np.cos(angle), 0.5 + 0.4 * np.sin(angle)]\n    \n    # One additional circle\n    centers[25] = [0.5, 0.85]\n    \n    # Ensure all circles are well within the unit square\n    centers = np.clip(centers, 0.1, 0.9)\n    \n    # Calculate radii\n    radii = np.ones(n) * 0.05  # Start with small radii\n    \n    # Limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y, 0.08)\n    \n    # Limit by distance to other circles - do several passes!\n    for _ in range(10):  # Added: multiple passes\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n                if radii[i] + radii[j] > dist * 0.95:\n                    scale = (dist * 0.95) / (radii[i] + radii[j])\n                    radii[i] *= scale\n                    radii[j] *= scale\n            # Also reapply box constraint after adjustment\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y, 0.08)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.780464893137411,
      "additional_data": {
        "sum_radii": "1.780465",
        "target_ratio": "0.675698",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 3,
    "parent_id": 2,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Initial hexagonal/triangular lattice arrangement, fit in box\n    def hex_lattice_coords(num, r_min=0.04):\n        # Fit as many as possible in 5 rows hex lattice\n        rows = [5, 5, 6, 5, 5]  # sum to 26\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for i, nrow in enumerate(rows):\n            offset = (max(rows) - nrow) / 2 * dx\n            for j in range(nrow):\n                x = r_min + offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    # Start with small radius everywhere, safe for constraints\n    r0 = 0.033\n\n    # Start with a hex lattice, but add a bit of random \"shake\" for symmetry breaking\n    centers0 = hex_lattice_coords(n, r_min=r0)\n    np.random.seed(2)\n    centers0 += (np.random.rand(n,2)-0.5)*0.06\n\n    # Initial radii\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    # --- Define constraints ---\n\n    cons = []\n\n    # All circles within bounds: x_i, y_i in [ri, 1-ri]\n    for i in range(n):\n        def makefn_idx(i):\n            return lambda x: x[2*i]   - x[2*n+i]           # x_i >= r_i \u21d2 x_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': makefn_idx(i)})\n\n        def makefn_idx2(i):\n            return lambda x: 1 - x[2*i]    - x[2*n+i]      # 1 - x_i >= r_i \u21d2 1-x_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': makefn_idx2(i)})\n\n        def makefn_idy(i):\n            return lambda x: x[2*i+1] - x[2*n+i]          # y_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': makefn_idy(i)})\n\n        def makefn_idy2(i):\n            return lambda x: 1 - x[2*i+1] - x[2*n+i]      # 1 - y_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': makefn_idy2(i)})\n\n        # radii nonnegative, bounded\n        def makefn_r0(i):\n            return lambda x: x[2*n+i] - 0.011\n        cons.append({'type':'ineq', 'fun': makefn_r0(i)})\n        def makefn_r1(i):\n            return lambda x: 0.13 - x[2*n+i]\n        cons.append({'type':'ineq', 'fun': makefn_r1(i)})\n\n    # All pairs: dist(center_i, center_j) >= ri + rj\n    for i in range(n):\n        for j in range(i+1, n):\n            def makefun(i, j):\n                return lambda x: (\n                    (x[2*i  ] - x[2*j  ])**2 +\n                    (x[2*i+1] - x[2*j+1])**2\n                )**0.5 - (x[2*n+i] + x[2*n+j] + 0.003)\n            cons.append({'type':'ineq', 'fun': makefun(i,j)})\n\n    # --- Objective: minimize negative sum of radii ---\n    def objective(x):\n        # -(sum radii)\n        return -np.sum(x[2*n:])\n\n    # --- Run optimizer ---\n    # Allow maxiter to be reasonably large, and tighter tolerance.\n    result = minimize(\n        objective, x0, constraints=cons, method='SLSQP',\n        options={'ftol':1e-7, 'maxiter': 600, 'disp':False}\n    )\n\n    if not result.success:\n        # If failed, revert to initial feasible (should almost never happen)\n        x = x0\n    else:\n        x = result.x\n\n    # --- Extract centers and radii ---\n    centers = x[:2*n].reshape((n,2))\n    radii = x[2*n:]\n\n    sum_radii = np.sum(radii)\n\n    return centers, radii, float(sum_radii)\n\n",
    "evaluation": {
      "fitness": 2.5964943861802476,
      "additional_data": {
        "sum_radii": "2.596494",
        "target_ratio": "0.985387",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 4,
    "parent_id": 2,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small improvement on previous: Allow circles closer to border, tweak ring radii,\n    remove arbitrary max radius cap, tighten overlap threshold, and more passes.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Inner ring of 8\n    r1 = 0.23\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r1 * np.cos(angle), 0.5 + r1 * np.sin(angle)]\n    \n    # Outer ring of 16\n    r2 = 0.405\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + r2 * np.cos(angle), 0.5 + r2 * np.sin(angle)]\n    \n    # One additional circle\n    centers[25] = [0.5, 0.88]\n    \n    # Don't restrict centers artificially; let border constraint handle\n    # Calculate initial radii -- start a little larger\n    radii = np.ones(n) * 0.065\n    \n    # Limit by distance to square borders ONLY (no hard cap)\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n    \n    # Limit by distance to other circles - more tight, more passes\n    for _ in range(25):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n                if dist < 1e-10:\n                    continue  # Avoid divide by zero for degenerate\n                if radii[i] + radii[j] > dist * 0.98:   # Tighter threshold than before\n                    scale = (dist * 0.98) / (radii[i] + radii[j])\n                    radii[i] *= scale\n                    radii[j] *= scale\n            x, y = centers[i]\n            # After each scaling, still border constraints\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.4199560547422547,
      "additional_data": {
        "sum_radii": "1.419956",
        "target_ratio": "0.538883",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 5,
    "parent_id": 1,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Place 26 circles in a unit square to maximize sum of radii.\n    Small iterative improvement: allow placing centers closer to the square boundary,\n    allow larger radii, and run several rounds of pairwise radius shrink to resolve overlap.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Center circle\n    centers[0] = [0.5, 0.5]\n    \n    # 8 circles inner ring\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n    \n    # 16 circles outer ring\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.4 * np.cos(angle), 0.5 + 0.4 * np.sin(angle)]\n    \n    # One extra circle (move it to a corner to free up space)\n    centers[25] = [0.15, 0.85]\n    \n    # Do not clip centers (let circles expand as close to border as possible)\n    \n    # Initial radii: max possible limited by borders\n    radii = np.zeros(n)\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y, 0.09)  # allow up to 0.09 for potential room\n    \n    # Iteratively resolve overlaps and maximize radii\n    n_rounds = 6\n    for round in range(n_rounds):\n        # Permute order to prevent stuck dynamics\n        pairs = [(i, j) for i in range(n) for j in range(i + 1, n)]\n        np.random.shuffle(pairs)\n        for i, j in pairs:\n            dx = centers[i] - centers[j]\n            d = np.linalg.norm(dx)\n            if d < 1e-8:\n                continue\n            # If overlap, shrink the larger radius just enough\n            overlap = radii[i] + radii[j] - d\n            if overlap > -1e-10:\n                # Shrink only the larger radius, to keep sum higher\n                if radii[i] > radii[j]:\n                    radii[i] = max(radii[i] - overlap, 0.0)\n                else:\n                    radii[j] = max(radii[j] - overlap, 0.0)\n        # After all pairs, update border-limited radii\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y, 0.1)\n    \n    # One final border and non-negativity check\n    radii = np.clip(radii, 0, None)\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1-x, 1-y, 0.13)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.871408292507999,
      "additional_data": {
        "sum_radii": "1.871408",
        "target_ratio": "0.710212",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 6,
    "parent_id": 3,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Use a more balanced [4,6,6,6,4] hex pattern to fill the square\n    def hex_lattice_coords(num, r_min=0.04):\n        rows = [4, 6, 6, 6, 4]  # sum to 26\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for i, nrow in enumerate(rows):\n            offset = (max(rows) - nrow) / 2 * dx\n            for j in range(nrow):\n                x = r_min + offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    # Smaller start rad\n    r0 = 0.032\n    centers0 = hex_lattice_coords(n, r_min=r0)\n\n    # Add a bit more shake to help optimizer avoid local minima\n    np.random.seed(2)\n    centers0 += (np.random.rand(n,2)-0.5)*0.10\n\n    # Initial radii\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    cons = []\n\n    # All circles within bounds\n    for i in range(n):\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]})\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i]   - x[2*n+i]})\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]})\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]})\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.009})\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: 0.135 - x[2*n+i]})\n\n    # No overlap (distance at least ri + rj)\n    # Use minimal slack for numerical stability\n    slack = 1e-8\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({'type': 'ineq', 'fun': lambda x, i=i, j=j: (\n                ((x[2*i] - x[2*j])**2 + (x[2*i+1] - x[2*j+1])**2)**0.5 - (x[2*n+i] + x[2*n+j] + slack)\n            )})\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    result = minimize(\n        objective, x0, constraints=cons, method='SLSQP',\n        options={'ftol':1e-8, 'maxiter': 1200, 'disp': False}\n    )\n\n    if not result.success:\n        x = x0\n    else:\n        x = result.x\n\n    centers = x[:2*n].reshape((n,2))\n    radii = x[2*n:]\n    sum_radii = np.sum(radii)\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 2.5936755218027745,
      "additional_data": {
        "sum_radii": "2.593676",
        "target_ratio": "0.984317",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 7,
    "parent_id": 2,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved: More passes for radii scaling, allow slightly greater maximum radius,\n    and permit circles to be a bit closer to the boundary for better utilization.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n    \n    # Ring of 16 circles\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.4 * np.cos(angle), 0.5 + 0.4 * np.sin(angle)]\n    \n    # One additional circle\n    centers[25] = [0.5, 0.85]\n    \n    # Allow slightly closer to border\n    centers = np.clip(centers, 0.08, 0.92)\n    \n    # Calculate radii\n    radii = np.ones(n) * 0.052  # Start with slightly larger radii\n    \n    # Limit by distance to square borders\n    max_rad = 0.085  # Slightly higher\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y, max_rad)\n    \n    # Limit by distance to other circles - more passes!\n    for _ in range(24):  # Increased number of passes\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * 0.95:\n                    scale = (dist * 0.95) / (radii[i] + radii[j])\n                    radii[i] *= scale\n                    radii[j] *= scale\n            # Also reapply box constraint after adjustment\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y, max_rad)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.7751258275399067,
      "additional_data": {
        "sum_radii": "1.775126",
        "target_ratio": "0.673672",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 8,
    "parent_id": 1,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct arrangement of 26 circles in unit square to maximize sum of radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n    \n    # Ring of 16 circles\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.4 * np.cos(angle), 0.5 + 0.4 * np.sin(angle)]\n    \n    # One additional circle\n    centers[25] = [0.5, 0.85]\n\n    # NO CLIPPING of centers: use all the space\n    \n    # Start with larger radii for initial guess (liberal)\n    radii = np.full(n, 0.1)\n    \n    # Perform multiple passes of shrinking for overlaps & border constraints\n    num_passes = 8  # more passes gives more accurate shrink\n    for _ in range(num_passes):\n        # Limit by distance to square borders\n        for i in range(n):\n            x, y = centers[i]\n            max_r_border = min(x, y, 1 - x, 1 - y)\n            # Don't use fixed max; let the border be the only limit\n            if radii[i] > max_r_border:\n                radii[i] = max_r_border\n\n        # Limit by distance to other circles (minimize overlap)\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < 1e-12:  # Avoid division by zero in pathological config\n                    scale = 0.5\n                else:\n                    scale = min(1.0, (dist * 0.99) / (radii[i] + radii[j]) )\n                if scale < 1.0:\n                    # Scale both radii down proportionally to fit with a small gap\n                    r_sum = radii[i] + radii[j]\n                    if r_sum > 0:\n                        ratio_i = radii[i] / r_sum\n                        ratio_j = radii[j] / r_sum\n                        # Both shrink so sum becomes dist*0.99\n                        radii[i] = ratio_i * dist * 0.99\n                        radii[j] = ratio_j * dist * 0.99\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.8124551233767188,
      "additional_data": {
        "sum_radii": "1.812455",
        "target_ratio": "0.687839",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 9,
    "parent_id": 8,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved: More tightly packed rings and smart placement of extra circle.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles (slightly bigger radius)\n    r1 = 0.27  # was 0.25\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r1 * np.cos(angle), 0.5 + r1 * np.sin(angle)]\n    \n    # Ring of 16 circles (slightly bigger)\n    r2 = 0.415  # was 0.4\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + r2 * np.cos(angle), 0.5 + r2 * np.sin(angle)]\n    \n    # Improved position for extra circle, more \"in a nook\"\n    centers[25] = [0.13, 0.87]  # previously [0.5, 0.85]\n\n    # Start with slightly larger radii for initial guess\n    radii = np.full(n, 0.105)\n    \n    # Increase number of passes\n    num_passes = 12\n    for _ in range(num_passes):\n        # Limit by distance to square borders\n        for i in range(n):\n            x, y = centers[i]\n            max_r_border = min(x, y, 1 - x, 1 - y)\n            if radii[i] > max_r_border:\n                radii[i] = max_r_border\n\n        # Limit by distance to other circles (minimize overlap)\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < 1e-12:\n                    scale = 0.5\n                else:\n                    scale = min(1.0, (dist * 0.99) / (radii[i] + radii[j]) )\n                if scale < 1.0:\n                    r_sum = radii[i] + radii[j]\n                    if r_sum > 0:\n                        ratio_i = radii[i] / r_sum\n                        ratio_j = radii[j] / r_sum\n                        radii[i] = ratio_i * dist * 0.99\n                        radii[j] = ratio_j * dist * 0.99\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.9779534179019076,
      "additional_data": {
        "sum_radii": "1.977953",
        "target_ratio": "0.750646",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 10,
    "parent_id": 7,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Set random seed for determinism\n    rs = np.random.RandomState(42)\n\n    # Parameters for initial guess: 5 rows, 6 columns (more central)\n    rows, cols = 5, 6\n    if rows * cols < n:\n        cols += 1\n    grid_x = np.linspace(0.12, 0.88, cols)\n    grid_y = np.linspace(0.12, 0.88, rows)\n    centers = np.array([[x, y] for y in grid_y for x in grid_x])[:n]\n    # Slight jitter to break perfect symmetry\n    centers += rs.uniform(-0.03, 0.03, centers.shape)\n    # Initial radius: as big as fits with min center-edge distance and rough neighbor distance\n    rough_sep = min(grid_x[1] - grid_x[0], grid_y[1] - grid_y[0])\n    init_r = min(np.min(np.minimum(centers, 1 - centers)), rough_sep / 2.4)\n    radii = np.full(n, init_r * 0.95)\n\n    # Flattened variable vector: [x0, y0, r0, x1, y1, r1, ...]\n    x0 = np.empty(n * 3)\n    x0[0::3] = centers[:,0]\n    x0[1::3] = centers[:,1]\n    x0[2::3] = radii\n\n    # Bounds\n    bounds = []\n    for i in range(n):\n        # x in [r, 1-r], y in [r, 1-r], r in [0.002, 0.15]\n        # We'll use soft constraints for x/y, but for bounds, keep [0,1] for x/y, [0,0.15] for r\n        bounds.extend([(0.0,1.0), (0.0,1.0), (0.002,0.16)])\n\n    def objective(z):\n        # We maximize sum r_i; minimize negative for scipy\n        radii = z[2::3]\n        return -np.sum(radii)\n\n    cons = []\n\n    # Each circle must be inside box: x_i - r_i >= 0, x_i + r_i <= 1\n    #                                 y_i - r_i >= 0, y_i + r_i <= 1\n    for i in range(n):\n        def box_left(z, i=i):\n            return z[0 + 3*i] - z[2 + 3*i]\n        def box_right(z, i=i):\n            return 1.0 - (z[0 + 3*i] + z[2 + 3*i])\n        def box_bottom(z, i=i):\n            return z[1 + 3*i] - z[2 + 3*i]\n        def box_top(z, i=i):\n            return 1.0 - (z[1 + 3*i] + z[2 + 3*i])\n        cons.append({'type':'ineq', 'fun':box_left})\n        cons.append({'type':'ineq', 'fun':box_right})\n        cons.append({'type':'ineq', 'fun':box_bottom})\n        cons.append({'type':'ineq', 'fun':box_top})\n\n    # All pairs must be non-overlapping: distance >= r_i + r_j\n    for i in range(n):\n        for j in range(i+1, n):\n            def sep(z, i=i, j=j):\n                xi, yi, ri = z[3*i], z[3*i+1], z[3*i+2]\n                xj, yj, rj = z[3*j], z[3*j+1], z[3*j+2]\n                return np.hypot(xi-xj, yi-yj) - (ri + rj)\n            cons.append({'type':'ineq', 'fun':sep})\n\n    # Optimize\n    res = minimize(\n        objective, x0, method='SLSQP', bounds=bounds,\n        constraints=cons,\n        options={'disp': False, 'maxiter':1600, 'ftol':1e-8}\n    )\n\n    z = res.x\n    centers = np.stack([z[::3], z[1::3]], axis=-1)\n    radii = z[2::3]\n\n    # Return\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.5862801810446983,
      "additional_data": {
        "sum_radii": "2.586280",
        "target_ratio": "0.981511",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 11,
    "parent_id": 2,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n    # Create an initial hexagonal grid close-packed inside unit square\n    # Compute rows and columns needed for 26 circles\n    # We use hex-grid logic\n    rows = 5\n    row_counts = [5,6,5,6,4]  # totals to 26 circles\n    centers = []\n    y_spacing = 1.0 / (rows + 1)\n    r0 = 0.035  # initial guess for radius\n\n    y0 = y_spacing\n    idx = 0\n    for i, num_in_row in enumerate(row_counts):\n        x_spacing = 1.0 / (num_in_row + 1)\n        offset = 0 if i % 2 == 0 else x_spacing/2\n        x0 = x_spacing + offset\n        for j in range(num_in_row):\n            centers.append([x0 + j * x_spacing, y0])\n            idx += 1\n        y0 += y_spacing\n    centers = np.array(centers)\n    radii = np.ones(n) * r0\n    # Flatten variables: order [x0, y0, r0, x1, y1, r1, ...]\n    x0 = np.zeros(n*3)\n    x0[0::3] = centers[:,0]\n    x0[1::3] = centers[:,1]\n    x0[2::3] = radii\n\n    # Bounds: x, y in [r, 1-r], r in [0.01, 0.10]\n    bounds = []\n    for i in range(n):\n        # x bound: [r, 1-r]\n        bounds.append( (0.0, 1.0) ) # x\n        bounds.append( (0.0, 1.0) ) # y\n        bounds.append( (0.012, 0.12) ) # r: MIN radius enlarged for stability, MAX small\n    bounds = tuple(bounds)\n    # Constraints: all circles in square, all pairwise non-overlap\n    def constraints_fun(x):\n        cons = []\n        for i in range(n):\n            xi, yi, ri = x[3*i:3*i+3]\n            # Inside box\n            cons.extend([\n                xi - ri,      # left\n                1.0 - xi - ri,# right\n                yi - ri,      # bottom\n                1.0 - yi - ri # top\n            ])\n        # Pairwise non-overlap\n        for i in range(n):\n            xi, yi, ri = x[3*i:3*i+3]\n            for j in range(i+1, n):\n                xj, yj, rj = x[3*j:3*j+3]\n                dij = np.hypot(xi-xj, yi-yj)\n                # constraint: dij - (ri+rj) >= 0\n                cons.append(dij - (ri + rj) + 1e-6)\n        return np.array(cons)\n    constraints = {'type':'ineq', 'fun': constraints_fun}\n    # Objective: maximize sum of radii -> minimize negative sum\n    def objective(x):\n        return -np.sum(x[2::3])\n    # Run optimizer\n    res = minimize(\n        objective, x0, method='SLSQP', bounds=bounds, constraints=constraints,\n        options={'maxiter':2200, 'ftol':1e-10, 'disp': False}\n    )\n    # Prepare output\n    sol = res.x\n    final_centers = np.stack([sol[0::3], sol[1::3]], axis=1)\n    final_radii = sol[2::3]\n    sum_radii = np.sum(final_radii)\n    return final_centers, final_radii, sum_radii\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "invalid",
        "error": "Invalid packing (overlaps or out of bounds)"
      }
    }
  },
  {
    "id": 12,
    "parent_id": 1,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved arrangement of 26 circles in unit square to maximize sum of radii.\n    Small iterative improvement: remove unnecessary clipping of centers,\n    and enforce border constraints only by radii, and use a more careful\n    iterative radii reduction for overlaps.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Inner ring of 8 circles\n    inner_ring_r = 0.25\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Outer ring of 16 circles\n    outer_ring_r = 0.40\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # One additional circle (placed near top edge, but not clipped)\n    centers[25] = [0.5, 0.88]  # slightly closer to top\n\n    # Initialize radii to a larger guess\n    radii = np.ones(n) * 0.07\n    \n    # First pass: border limit\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n    \n    # Iteratively shrink radii to resolve overlaps, multiple passes\n    for _ in range(4):\n        # For all pairs, check overlap and adjust\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = centers[i] - centers[j]\n                d = np.hypot(dx, dy)\n                if d < 1e-12:\n                    # practically coincident: shrink both\n                    s = 0.5\n                else:\n                    s = min(1.0, (d * 0.98) / (radii[i] + radii[j]))  # less harsh shrinking\n                if s < 1.0:\n                    radii[i] *= s\n                    radii[j] *= s\n        # After each pass, restore border constraint\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.6933000000000002,
      "additional_data": {
        "sum_radii": "1.693300",
        "target_ratio": "0.642619",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 13,
    "parent_id": 3,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Improved hex/triangular grid: alternate 6,5 rows for 6 rows\n    def alt_hex_coords(num, r_min=0.04):\n        # Alternating rows of 5 and 6, total 26\n        rows = [5,6,5,5,6,5]  # still 26\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for nrow in rows:\n            offset = (max(rows) - nrow) / 2 * dx\n            for j in range(nrow):\n                x = r_min + offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    # Initial radii\n    r0 = 0.034\n\n    # Seed with lattice, to be perturbed later\n    centers0 = alt_hex_coords(n, r_min=r0)\n\n    # Initial radii: allow a touch larger than before\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    # --- Define constraints ---\n\n    cons = []\n\n    # All circles within bounds: x_i, y_i in [ri, 1-ri]\n    for i in range(n):\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]           })  # x_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]      })  # 1 - x_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]          })  # y_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]      })  # 1 - y_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.011             })  # r_i >= 0.011\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: 0.13 - x[2*n+i]              })  # r_i <= 0.13\n\n    # All pairs: dist(center_i, center_j) >= ri + rj\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({'type':'ineq', 'fun': lambda x, i=i, j=j: (\n                ((x[2*i  ] - x[2*j  ])**2 + (x[2*i+1] - x[2*j+1])**2 )**0.5\n                - (x[2*n+i] + x[2*n+j] + 0.001))})\n\n    # --- Objective: maximize sum of radii (minimize its negative) ---\n    def objective(x):  # maximize sum of radii\n        return -np.sum(x[2*n:])\n\n    # --- Optimization routine, with optional jitter ---\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = np.copy(x0)\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n)-0.5)*jitter\n        result = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-8, 'maxiter': 1100, 'disp': False}\n        )\n        if result.success:\n            return result.x, -result.fun\n        else:\n            # fallback, return starting point (low fitness)\n            return xstart, np.sum(xstart[2*n:])\n    \n    # MULTI-START: main run, then small (safe) random restart(s)\n    xs_list, fits = [], []\n\n    xbest, fitbest = optimize_once(x0, seed=None, jitter=0.0)\n    xs_list.append(xbest)\n    fits.append(fitbest)\n\n    # Two small jitters/retries\n    for s, scale in enumerate([0.012, 0.024]):\n        xtry, fittry = optimize_once(xbest, seed=10+s, jitter=scale)\n        xs_list.append(xtry)\n        fits.append(fittry)\n\n    # Pick the best\n    idx_best = np.argmax(fits)\n    x = xs_list[idx_best]\n\n    # --- Extract centers and radii ---\n    centers = x[:2*n].reshape((n,2))\n    radii = x[2*n:]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 2.6019300255080755,
      "additional_data": {
        "sum_radii": "2.601930",
        "target_ratio": "0.987450",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 14,
    "parent_id": 7,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Slightly smaller inner radii for more squeeze\n    - Outer ring placed at slightly lower radius\n    - Circles allowed a bit closer to the boundary\n    - 26th circle placed at (0.75, 0.5) instead of (0.5, 0.85)\n    - More passes for scaling\n    - Slightly higher max allowed radius\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Ring of 8 circles\n    r1 = 0.245  # slightly smaller allows inner and outer more room\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r1 * np.cos(angle), 0.5 + r1 * np.sin(angle)]\n\n    # Ring of 16 circles\n    r2 = 0.395  # slightly in from edge\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + r2 * np.cos(angle), 0.5 + r2 * np.sin(angle)]\n\n    # One additional circle at a side gap (right)\n    centers[25] = [0.75, 0.5]\n\n    # Allow circles closer to boundary\n    centers = np.clip(centers, 0.06, 0.94)\n\n    # Initialize radii\n    radii = np.ones(n) * 0.055  # start slightly larger\n\n    max_rad = 0.088  # slightly larger max\n\n    # Limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y, max_rad)\n\n    # Limit by distance to other circles - more passes!\n    for _ in range(32):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * 0.95:\n                    scale = (dist * 0.95) / (radii[i] + radii[j])\n                    radii[i] *= scale\n                    radii[j] *= scale\n            # Reapply border constraint and max\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y, max_rad)\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.732685646246721,
      "additional_data": {
        "sum_radii": "1.732686",
        "target_ratio": "0.657566",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 15,
    "parent_id": 1,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef initial_hexgrid(n, margin=0.03):\n    \"\"\"\n    Place n centers in an approximate optimal hexagonal grid inside unit square.\n    Returns:\n        centers: (n,2) array\n    \"\"\"\n    # Compute rows, cols to be as square as possible\n    # For hex grid, alternate rows have fewer elements\n    best_diff = 1e9\n    best_rows, best_cols = None, None\n    for rows in range(4, 9):\n        cols = int(np.ceil(n / rows))\n        diff = abs(rows - cols * np.sqrt(3)/2)\n        if diff < best_diff:\n            best_diff, best_rows, best_cols = diff, rows, cols\n    rows, cols = best_rows, best_cols\n\n    dy = (1 - 2*margin) / (rows - 1)\n    dx = (1 - 2*margin) / (cols - 1) if cols > 1 else 0.5\n    centers = []\n    for r in range(rows):\n        y = margin + r * dy\n        shift = 0.5*dx if r % 2 == 1 and cols > 1 else 0\n        c_this = cols - (1 if (r%2==1 and n%2==1 and n%cols!=0) else 0)\n        for c in range(cols):\n            x = margin + c * dx + shift\n            if 0 <= x <= 1 and 0 <= y <= 1:\n                centers.append([x, y])\n    centers = np.array(centers)\n    if len(centers) > n:  # Trim to n\n        centers = centers[:n]\n    elif len(centers) < n:  # Add some random ones\n        extra = n - len(centers)\n        extras = margin + (1-2*margin)*np.random.rand(extra,2)\n        centers = np.vstack([centers, extras])\n    return centers\n\ndef pack_objective(x, n):\n    # x: 3n array: [x1,y1,r1, ..., xn,yn,rn]\n    radii = x[2::3]\n    # We want to maximize sum radii, so minimize negative sum\n    return -np.sum(radii)\n\ndef gen_constraints(n):\n    constraints = []\n    # Inside square:\n    def make_in_square(idx):\n        return [\n            {'type':'ineq', 'fun': lambda x, idx=idx: x[3*idx]     - x[3*idx+2]},  # x - r >= 0\n            {'type':'ineq', 'fun': lambda x, idx=idx: 1 - x[3*idx] - x[3*idx+2]}, # 1-x - r >= 0\n            {'type':'ineq', 'fun': lambda x, idx=idx: x[3*idx+1]   - x[3*idx+2]}, # y - r >= 0\n            {'type':'ineq', 'fun': lambda x, idx=idx: 1 - x[3*idx+1] - x[3*idx+2]},# 1-y - r >= 0\n            {'type':'ineq', 'fun': lambda x, idx=idx: x[3*idx+2]}, # r >= 0\n            {'type':'ineq', 'fun': lambda x, idx=idx: 0.30 - x[3*idx+2]} # r <= 0.30\n        ]\n    # Nonoverlap:\n    def make_nonoverlap(i,j):\n        return {\n            'type':'ineq',\n            'fun': lambda x, i=i, j=j: (\n                np.linalg.norm(x[3*i:3*i+2] - x[3*j:3*j+2]) - (x[3*i+2] + x[3*j+2])\n            )\n        }\n    # All constraints:\n    for idx in range(n):\n        constraints += make_in_square(idx)\n    for i in range(n):\n        for j in range(i+1, n):\n            constraints.append(make_nonoverlap(i,j))\n    return constraints\n\ndef run_packing():\n    np.random.seed(101)  # reproducible\n    n = 26\n    margin = 0.045\n\n    # --- Initial guess: hex grid, initial radii ---\n    centers0 = initial_hexgrid(n, margin=margin)\n    # Slight jitter\n    centers0 += (np.random.rand(n,2)-0.5)*0.015\n    # Initial radii: distance to closest wall\n    radii0 = np.min([\n        centers0[:,0], 1-centers0[:,0],\n        centers0[:,1], 1-centers0[:,1]\n    ], axis=0) - 1e-2\n    radii0 = np.clip(radii0, 0.01, 0.16)\n    x0 = np.zeros(3*n)\n    x0[::3] = centers0[:,0]\n    x0[1::3] = centers0[:,1]\n    x0[2::3] = radii0\n\n    # --- Constraints ---\n    constraints = gen_constraints(n)\n\n    # --- Optimize ---\n    result = minimize(\n        pack_objective,\n        x0,\n        args=(n,),\n        constraints=constraints,\n        method='SLSQP',\n        options={'ftol':1e-7, 'maxiter':500, 'disp': False}\n    )\n    x = result.x\n    centers = np.stack([x[::3], x[1::3]], axis=1)\n    radii = x[2::3]\n\n    # Minor post-processing: shrink radii ever so slightly if needed\n    for i in range(n):\n        # Border\n        radii[i] = min(radii[i],\n                       centers[i,0], 1-centers[i,0",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 16,
    "parent_id": 9,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Slight improvement: adjust rings to 1+9+16, try more passes and finer scaling, and move extra circle location a bit.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 9 circles (better fits than 8)\n    r1 = 0.28\n    for i in range(9):\n        angle = 2 * np.pi * i / 9\n        centers[i + 1] = [0.5 + r1 * np.cos(angle), 0.5 + r1 * np.sin(angle)]\n    \n    # Ring of 16 circles\n    r2 = 0.415\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 10] = [0.5 + r2 * np.cos(angle), 0.5 + r2 * np.sin(angle)]\n    \n    # Position for the \"extra\" circle: try near but inside top edge, off center\n    centers[25] = [0.15, 0.87]\n    \n    # Start with slightly larger radii for initial guess\n    radii = np.full(n, 0.12)\n    \n    # Increase number of passes and use a tighter scaling factor\n    num_passes = 20\n    for _ in range(num_passes):\n        # Limit by distance to square borders\n        for i in range(n):\n            x, y = centers[i]\n            max_r_border = min(x, y, 1 - x, 1 - y)\n            if radii[i] > max_r_border:\n                radii[i] = max_r_border\n\n        # Limit by distance to other circles (minimize overlap)\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < 1e-12:\n                    scale = 0.5\n                else:\n                    scale = min(1.0, (dist * 0.995) / (radii[i] + radii[j]) )\n                if scale < 1.0:\n                    r_sum = radii[i] + radii[j]\n                    if r_sum > 0:\n                        ratio_i = radii[i] / r_sum\n                        ratio_j = radii[j] / r_sum\n                        radii[i] = ratio_i * dist * 0.995\n                        radii[j] = ratio_j * dist * 0.995\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.8205724192818438,
      "additional_data": {
        "sum_radii": "1.820572",
        "target_ratio": "0.690919",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 17,
    "parent_id": 1,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef make_hex_grid(n, padding=0.07, seed=0):\n    \"\"\"\n    Generate n points in a nearly hexagonal lattice inside [0,1]x[0,1],\n    spread as evenly as possible.\n    \"\"\"\n    # Try to get grid dims as close to square as possible\n    # For 26, try 5 rows of 5 or 6\n    rows = 5\n    cols = 6\n    y = np.linspace(padding, 1-padding, rows)\n    x = np.linspace(padding, 1-padding, cols)\n    centers = []\n    for i in range(rows):\n        # Shift every other row for hex pattern\n        xrow = x.copy()\n        if i%2 == 1:\n            xrow += (x[1]-x[0])/2\n        # Remove out-of-bounds shifted points\n        row_centers = []\n        for xx in xrow:\n            if padding <= xx <= 1-padding:\n                row_centers.append(xx)\n        for xx in row_centers:\n            centers.append((xx,y[i]))\n    # Truncate or randomly sample if too many\n    np.random.seed(seed)\n    if len(centers) > n:\n        idx = np.random.choice(len(centers), n, replace=False)\n        centers = [centers[i] for i in idx]\n    elif len(centers) < n:\n        # Add some in corners\n        for _ in range(n - len(centers)):\n            centers.append((padding + (1-2*padding)*np.random.rand(),\n                            padding + (1-2*padding)*np.random.rand()))\n    return np.array(centers)\n\ndef arrange_initial(n, padding=0.07):\n    centers = make_hex_grid(n, padding=padding)\n    radii = np.ones(n) * 0.03\n    return centers, radii\n\ndef constraint_no_overlap(vars, n):\n    \"\"\"\n    vars = [x0,y0,r0, x1,y1,r1, ...]\n    Returns array of min-distances between all pairs, must be >=0.\n    \"\"\"\n    res = []\n    centers = vars[:-n].reshape((n,2))\n    radii = vars[-n:]\n    for i in range(n):\n        for j in range(i+1,n):\n            d = np.linalg.norm(centers[i]-centers[j])\n            res.append( d - (radii[i]+radii[j]) )\n    return np.array(res)\n\ndef constraint_in_square(vars, n):\n    \"\"\"\n    Returns constraints for all circles to be inside square [0,1]^2.\n    For each circle, x-r >= 0, x+r <= 1, y-r >=0, y+r <=1\n    \"\"\"\n    centers = vars[:-n].reshape((n,2))\n    radii = vars[-n:]\n    res = []\n    x = centers[:,0]\n    y = centers[:,1]\n    res.extend( x - radii )         # >= 0\n    res.extend( 1 - (x + radii) )   # >= 0\n    res.extend( y - radii )         # >= 0\n    res.extend( 1 - (y + radii) )   # >= 0\n    return np.array(res)\n\ndef objective(vars, n):\n    \"\"\"Negative sum of radii (as we minimize)\"\"\"\n    radii = vars[-n:]\n    return -np.sum(radii)\n\ndef run_packing():\n    n = 26\n\n    # Initial guess\n    centers, radii = arrange_initial(n, padding=0.065)\n    x0 = np.concatenate([centers.ravel(), radii])\n\n    # Bounds for optimization\n    bounds = []\n    for i in range(n):\n        # centers x/y in [0,1]\n        bounds.append((0.0,1.0)) # x\n        bounds.append((0.0,1.0)) # y\n    for i in range(n):\n        # radii in [0.005, 0.25]\n        bounds.append((0.005, 0.20))\n\n    cons = []\n    # Non-overlap constraint\n    cons.append({'type':'ineq','fun':constraint_no_overlap, 'args':(n,)})\n    # Stay inside square\n    cons.append({'type':'ineq','fun':constraint_in_square, 'args':(n,)})\n\n    # Run optimization\n    result = minimize(objective, x0, args=(n,),\n                      method='SLSQP',\n                      bounds=bounds,\n                      constraints=cons,\n                      options={'maxiter':500,'ftol':1e-7,'disp':False})\n\n    xopt = result.x\n    centers = xopt[:-n].reshape((n,2))\n    radii = xopt[-n:]\n    # Ensure valid output\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.5836498025524124,
      "additional_data": {
        "sum_radii": "2.583650",
        "target_ratio": "0.980512",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 18,
    "parent_id": 13,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Slightly improved grid: first row 6, then 5,5,5,5 (total 26)\n    def alt_hex_coords(num, r_min=0.04):\n        rows = [6,5,5,5,5]  # 6+5+5+5+5=26\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for nrow in rows:\n            offset = (max(rows) - nrow) / 2 * dx\n            for j in range(nrow):\n                x = r_min + offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    # Slightly larger initial radii\n    r0 = 0.036\n    r_min_grid = r0 + 0.002\n\n    centers0 = alt_hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    # --- Constraints ---\n    cons = []\n\n    # Limits for circle in square and radii\n    for i in range(n):\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]           })  # x_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]      })  # 1 - x_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]          })  # y_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]      })  # 1 - y_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.011             })  # r_i >= 0.011\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: 0.14 - x[2*n+i]              })  # r_i <= 0.14\n\n    # Nonoverlap\n    epsilon = 5e-4\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({'type':'ineq', 'fun': lambda x, i=i, j=j: (\n                ((x[2*i] - x[2*j])**2 + (x[2*i+1] - x[2*j+1])**2 )**0.5\n                - (x[2*n+i] + x[2*n+j] + epsilon))})\n\n    # --- Objective: maximize sum of radii (minimize negative) ---\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    # --- Optimization routine, multi-start ---\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = np.copy(x0)\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n)-0.5)*jitter\n        result = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-8, 'maxiter':2000, 'disp':False}\n        )\n        if result.success:\n            return result.x, -result.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    # Multi-start: original, then more restarts with different jitters/seeds\n    xs_list, fits = [], []\n\n    # original\n    xbest, fitbest = optimize_once(x0, seed=None, jitter=0.0)\n    xs_list.append(xbest)\n    fits.append(fitbest)\n    # additional jitters. Try 5 restarts: 3 with jitter=0.012, 2 with jitter=0.023\n    for s, scale in enumerate([0.012]*3 + [0.023]*2):\n        xtry, fittry = optimize_once(xbest, seed=10+s, jitter=scale)\n        xs_list.append(xtry)\n        fits.append(fittry)\n\n    idx_best = np.argmax(fits)\n    x = xs_list[idx_best]\n\n    centers = x[:2*n].reshape((n,2))\n    radii = x[2*n:]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 2.624682986398121,
      "additional_data": {
        "sum_radii": "2.624683",
        "target_ratio": "0.996085",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 19,
    "parent_id": 18,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Slightly improved grid: first row 6, then 5,5,5,5 (total 26)\n    def alt_hex_coords(num, r_min=0.0385):\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            # alternate true hex offset on even rows for denser packing\n            row_offset = (dx/2 if idx%2 else 0) + (max(rows) - nrow)/2*dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    # Slightly larger initial radii\n    r0 = 0.0365\n    r_min_grid = r0 + 0.0025\n\n    centers0 = alt_hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    cons = []\n    # boundary + radius bounds\n    for i in range(n):\n        cons += [\n            {'type':'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n            {'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n            {'type':'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n            {'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n            {'type':'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.008},\n            {'type':'ineq', 'fun': lambda x, i=i: 0.16 - x[2*n+i]},\n        ]\n    # non-overlap with smaller epsilon\n    epsilon = 1e-4\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type':'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i]-x[2*j], x[2*i+1]-x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + epsilon)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n)-0.5)*jitter\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-8, 'maxiter':3000, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    # multi-start\n    xs, fits = [], []\n    xbest, fbest = optimize_once(x0, None, 0.0)\n    xs.append(xbest); fits.append(fbest)\n    for idx, jit in enumerate([0.012,0.012,0.023,0.023,0.035,0.035]):\n        xtry, ftry = optimize_once(xbest, seed=20+idx, jitter=jit)\n        xs.append(xtry); fits.append(ftry)\n    # pick best\n    ib = int(np.argmax(fits))\n    xopt = xs[ib]\n    centers = xopt[:2*n].reshape(n,2)\n    radii   = xopt[2*n:]\n    return centers, radii, float(np.sum(radii))\n",
    "evaluation": {
      "fitness": 2.6296633742385978,
      "additional_data": {
        "sum_radii": "2.629663",
        "target_ratio": "0.997975",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 20,
    "parent_id": 16,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement: switch to 1+6+12+7 rings (\"hex packed\" core plus outer), \n    more passes, slightly tighter ratio for overlap, gentle randomization of outer shell positions,\n    and refined initial radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # 1st ring: 6 circles (hexagon)\n    r1 = 0.23\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        centers[1 + i] = [0.5 + r1 * np.cos(angle), 0.5 + r1 * np.sin(angle)]\n    \n    # 2nd ring: 12 circles (hexagonal shell)\n    r2 = 0.37\n    for i in range(12):\n        angle = 2 * np.pi * i / 12\n        centers[7 + i] = [0.5 + r2 * np.cos(angle), 0.5 + r2 * np.sin(angle)]\n    \n    # Outer layer: 7 circles, placed somewhat sparsely but near outer edge, randomized angle\n    r3 = 0.46\n    for i in range(7):\n        angle = 2 * np.pi * i / 7 + (np.random.rand()-0.5)*0.15  # small random offset to break symmetry\n        x = 0.5 + r3 * np.cos(angle)\n        y = 0.5 + r3 * np.sin(angle)\n        # Clamp to slightly inside square if outside\n        x = min(max(x, 0.06), 0.94)\n        y = min(max(y, 0.06), 0.94)\n        centers[19 + i] = [x, y]\n    \n    # Start with radii a bit larger than before, to challenge the packing\n    radii = np.full(n, 0.13)\n    \n    # More passes and a slightly tighter overlap buffer\n    num_passes = 50\n    for _ in range(num_passes):\n        # Limit by distance to square borders\n        for i in range(n):\n            x, y = centers[i]\n            max_r_border = min(x, y, 1 - x, 1 - y)\n            if radii[i] > max_r_border:\n                radii[i] = max_r_border\n\n        # Limit by distance to other circles (minimize overlap)\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < 1e-12:\n                    scale = 0.5\n                else:\n                    scale = min(1.0, (dist * 0.997) / (radii[i] + radii[j]) )\n                if scale < 1.0:\n                    r_sum = radii[i] + radii[j]\n                    if r_sum > 0:\n                        ratio_i = radii[i] / r_sum\n                        ratio_j = radii[j] / r_sum\n                        radii[i] = ratio_i * dist * 0.997\n                        radii[j] = ratio_j * dist * 0.997\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.6200619712687334,
      "additional_data": {
        "sum_radii": "1.620062",
        "target_ratio": "0.614824",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 21,
    "parent_id": 10,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Construct initial guess: central, inner shell, outer shell, corner/edge fillers\n\n    # Central circle (index 0)\n    center = np.array([0.5, 0.5])\n\n    # Inner shell: 6 circles spaced hexagonally at radius r1 (to be determined)\n    inner_shell_theta = np.linspace(0, 2*np.pi, 7, endpoint=False)[:-1]\n    inner_shell_r = 0.165  # normalized inner shell distance (manually tuned)\n    inner_shell_xy = center + 0.265 * np.stack([np.cos(inner_shell_theta), np.sin(inner_shell_theta)], axis=-1)\n\n    # Outer shell: 12 circles spaced at larger radius, but squashed to fit into square\n    outer_shell_theta = np.linspace(0, 2*np.pi, 13, endpoint=False)[:-1]\n    R2 = 0.39  # adjust\n    # \"Squash\" to unit square edges\n    angle = outer_shell_theta\n    squash_x = 0.5 + R2*np.cos(angle) * 0.90\n    squash_y = 0.5 + R2*np.sin(angle) * 0.90\n    outer_shell_xy = np.stack([squash_x, squash_y], axis=1)\n\n    # 7 edge/corner fillers, roughly one near each corner and edge middle (but not duplicating)\n    fillers = np.array([\n        [0.13, 0.13],\n        [0.13, 0.87],\n        [0.87, 0.13],\n        [0.87, 0.87],\n        [0.5, 0.13],\n        [0.13, 0.5],\n        [0.5, 0.87]\n    ])\n\n    # Assemble all centers\n    centers_init = np.vstack([\n        center[None],           # 1\n        inner_shell_xy,         # 6\n        outer_shell_xy,         # 12\n        fillers                 # 7\n    ])  # shape (26,2)\n\n    assert centers_init.shape == (26,2), \"Bad arrangement\"\n\n    # Assign radii: larger for center, a bit smaller for inner, smaller for outer and fillers\n    r_center = 0.132    # loosened for optimizer\n    r_inner = 0.109\n    r_outer = 0.082\n    r_filler = 0.07\n\n    radii_init = np.concatenate([\n        [r_center],\n        [r_inner]*6,\n        [r_outer]*12,\n        [r_filler]*7\n    ])\n\n    # Add random <1% jitter to break symmetries and help optimizer escape local minima\n    rs = np.random.RandomState(24)\n    centers_init += rs.uniform(-0.009, 0.009, centers_init.shape)\n\n    # Construct optimization variables: [x0, y0, r0, x1, y1, r1, ...]\n    x0 = np.empty(n*3)\n    x0[0::3] = centers_init[:,0]\n    x0[1::3] = centers_init[:,1]\n    x0[2::3] = radii_init\n\n    # --- Constraints ---\n\n    bounds = []\n    for i in range(n):\n        # We allow full box for centers, but radii in [0.004, 0.18]\n        bounds.extend([(0.0,1.0), (0.0,1.0), (0.004,0.18)])\n\n    def objective(z):\n        # maximize sum radii\n        return -np.sum(z[2::3])\n\n    cons = []\n\n    # Each circle in square (center +/- radius in [0,1] for both axes)\n    for i in range(n):\n        def bl(z, i=i):\n            return z[0+3*i] - z[2+3*i]\n        def br(z, i=i):\n            return 1.0 - (z[0+3*i] + z[2+3*i])\n        def bb(z, i=i):\n            return z[1+3*i] - z[2+3*i]\n        def bt(z, i=i):\n            return 1.0 - (z[1+3*i] + z[2+3*i])\n        cons.append({'type':'ineq','fun':bl})\n        cons.append({'type':'ineq','fun':br})\n        cons.append({'type':'ineq','fun':bb})\n        cons.append({'type':'ineq','fun':bt})\n\n    # Non-overlap between every pair\n    for i in range(n):\n        for j in range(i+1, n):\n            def sep(z, i=i, j=j):\n                xi, yi, ri = z[3*i], z[3*i+1], z[3*i+2]\n                xj, yj, rj = z[3*j], z[3*j+1], z[3*j+2]\n                return np.hypot(xi-xj, yi-yj) - (ri + rj)\n            cons.append({'type':'ineq','fun':sep})\n\n    # We use SLSQP, but increase iterations and use tighter tolerance\n    res = minimize(\n        objective, x0, method='SLSQP', bounds=bounds, constraints=cons,\n        options={'disp': False",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 22,
    "parent_id": 12,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Place the 26th circle in the lower-left corner ([r, r]) instead of 'floating' near top edge.\n    - Increase passes to 8 for tighter fitting.\n    - Tweak initial radius guesses: center and corners can be slightly larger, inner ring medium, outer ring slightly smaller.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Inner ring of 8 circles\n    inner_ring_r = 0.25\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Outer ring of 16 circles\n    outer_ring_r = 0.40\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # One additional circle in the bottom left corner (placed at [p, p])\n    corner_idx = 25\n    p = 0.06  # initial guess, will be reduced to fit border\n    centers[corner_idx] = [p, p]\n    \n    # Assign initial radii with slight variation based on likely available space\n    radii = np.ones(n) * 0.07\n    radii[0] = 0.08  # center\n    for i in range(1, 9):\n        radii[i] = 0.073  # inner ring\n    for i in range(9, 25):\n        radii[i] = 0.068  # outer ring\n    radii[corner_idx] = 0.085  # the corner circle can, in principle, be a bit bigger\n    \n    # First pass: border limit\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n    # For the corner, ensure it's clipped also by square border\n    # radii[corner_idx] = min(radii[corner_idx], centers[corner_idx][0], centers[corner_idx][1])\n    \n    # Increase the number of passes for more accurate fitting\n    for _ in range(8):\n        # For all pairs, check overlap and adjust\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = centers[i] - centers[j]\n                d = np.hypot(dx, dy)\n                # Tighter tolerance, less shrinkage when just touching\n                if d < 1e-12:\n                    s = 0.5\n                else:\n                    s = min(1.0, (d * 0.985) / (radii[i] + radii[j]))\n                if s < 1.0:\n                    # Slight bias: shrink only the smaller of the two in a conflict\n                    if radii[i] < radii[j]:\n                        radii[i] *= s\n                    else:\n                        radii[j] *= s\n        # After each pass, restore border constraint\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.8120000000000003,
      "additional_data": {
        "sum_radii": "1.812000",
        "target_ratio": "0.687666",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 23,
    "parent_id": 8,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct arrangement of 26 circles in unit square to maximize sum of radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles with slightly larger radius (move closer to edge)\n    r1 = 0.275  # was 0.25\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r1 * np.cos(angle), 0.5 + r1 * np.sin(angle)]\n    \n    # Ring of 16 circles, just inside the square boundary\n    # Push to maximum while ensuring all radii < 0.5 to stay inside square\n    r2 = 0.45  # was 0.4\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        # Add a small jitter to break up perfect symmetry and help packing\n        jitter = 0.007 * np.array([np.sin(angle*3.2), np.cos(angle*2.3)])\n        centers[i + 9] = [0.5 + r2 * np.cos(angle), 0.5 + r2 * np.sin(angle)]\n        centers[i + 9] += jitter\n    \n    # 26th circle: wedge it at the bottom center between outer rings\n    centers[25] = [0.5, 0.12]\n\n    # Start with liberal radii - will be shrunk iteratively\n    radii = np.full(n, 0.11)\n    \n    # More passes for finer adjustment\n    num_passes = 17\n    for _ in range(num_passes):\n        # Limit by distance to square borders\n        for i in range(n):\n            x, y = centers[i]\n            max_r_border = min(x, y, 1 - x, 1 - y)\n            if radii[i] > max_r_border:\n                radii[i] = max_r_border\n\n        # Limit by distance to other circles (minimize overlap)\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                eps = 1e-13\n                if dist < eps:\n                    scale = 0.5\n                else:\n                    scale = min(1.0, (dist * 0.994) / (radii[i] + radii[j]) )\n                if scale < 1.0:\n                    r_sum = radii[i] + radii[j]\n                    if r_sum > 0:\n                        ratio_i = radii[i] / r_sum\n                        ratio_j = radii[j] / r_sum\n                        radii[i] = ratio_i * dist * 0.994\n                        radii[j] = ratio_j * dist * 0.994\n\n    # Final expansion: greedy, each radius increases individually (subject to border and no overlap)\n    for idx in np.argsort(-radii):\n        max_r = min(centers[idx][0], centers[idx][1], 1-centers[idx][0], 1-centers[idx][1])\n        for j in range(n):\n            if j == idx:\n                continue\n            dist = np.linalg.norm(centers[idx] - centers[j])\n            if dist - radii[j] < max_r:\n                max_r = dist - radii[j]\n        max_r = max(max_r, 0.0)\n        radii[idx] = min(radii[idx], max_r)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.0423402144434175,
      "additional_data": {
        "sum_radii": "2.042340",
        "target_ratio": "0.775082",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 24,
    "parent_id": 8,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved arrangement: 1 central + 8 in inner ring + 17 in outer ring.\n    Initial radii set to nearly maximal by border & neighbor distances,\n    then a few relaxation passes to enforce constraints.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    centers[0] = [0.5, 0.5]\n    # ring parameters\n    dr1 = 0.35\n    dr2 = 0.42\n    # inner ring of 8\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[1 + i] = [0.5 + dr1 * np.cos(angle), 0.5 + dr1 * np.sin(angle)]\n    # outer ring of 17\n    for i in range(17):\n        angle = 2 * np.pi * i / 17\n        centers[9 + i] = [0.5 + dr2 * np.cos(angle), 0.5 + dr2 * np.sin(angle)]\n    # initialize radii to best feasible by border & neighbors\n    radii = np.zeros(n)\n    for i in range(n):\n        x, y = centers[i]\n        # border limit\n        r_border = min(x, y, 1 - x, 1 - y)\n        # neighbor-dist limit\n        dmin = 1.0\n        for j in range(n):\n            if j == i: continue\n            d = np.linalg.norm(centers[i] - centers[j])\n            if d < dmin:\n                dmin = d\n        r_neigh = 0.5 * dmin\n        radii[i] = 0.99 * min(r_border, r_neigh)\n    # relaxation passes\n    for _ in range(8):\n        # border constraints\n        for i in range(n):\n            x, y = centers[i]\n            mb = min(x, y, 1 - x, 1 - y)\n            if radii[i] > mb:\n                radii[i] = mb\n        # pairwise non-overlap\n        for i in range(n):\n            for j in range(i + 1, n):\n                ci = centers[i]; cj = centers[j]\n                dij = np.linalg.norm(ci - cj)\n                rij = radii[i] + radii[j]\n                if dij < rij:\n                    # shrink so sum = dij * factor\n                    target = dij * 0.995\n                    if target < 1e-8:\n                        continue\n                    scale = target / rij\n                    radii[i] *= scale\n                    radii[j] *= scale\n    sum_radii = float(np.sum(radii))\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.3932282214714151,
      "additional_data": {
        "sum_radii": "1.393228",
        "target_ratio": "0.528739",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 25,
    "parent_id": 24,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Iterative improvement on previous solution:\n    - Adjust ring radii\n    - Outer ring \"corner-rounding\"\n    - More relaxation passes\n    - Slightly increased scaling factors\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    centers[0] = [0.5, 0.5]\n\n    # ring parameters (adjusted for spread & border)\n    dr1 = 0.375          # inner ring radius, increased from 0.35\n    dr2 = 0.41           # outer ring radius, slightly reduced from 0.42\n\n    # inner ring of 8\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[1 + i] = [0.5 + dr1 * np.cos(angle), 0.5 + dr1 * np.sin(angle)]\n\n    # outer ring of 17, \"corner rounding\" adjustment\n    for i in range(17):\n        angle = 2 * np.pi * i / 17\n        # corner-rounding: shrink dr2 near corners (where |cos|,|sin| are both large)\n        fx = abs(np.cos(angle))\n        fy = abs(np.sin(angle))\n        corner_factor = max(0, (fx+fy)-1)   # >0 only near corners\n        radial_adj = dr2 - 0.04*corner_factor  # pull in near corners\n        centers[9 + i] = [0.5 + radial_adj * np.cos(angle), 0.5 + radial_adj * np.sin(angle)]\n\n    # initialize radii by border & neighbor constraints\n    radii = np.zeros(n)\n    for i in range(n):\n        x, y = centers[i]\n        r_border = min(x, y, 1 - x, 1 - y)\n        dmin = 1.0\n        for j in range(n):\n            if j == i: continue\n            d = np.linalg.norm(centers[i] - centers[j])\n            if d < dmin:\n                dmin = d\n        r_neigh = 0.5 * dmin\n        radii[i] = 0.995 * min(r_border, r_neigh)   # raise from 0.99 to 0.995\n\n    # relaxation passes (increase count)\n    for _ in range(18):\n        # border constraints\n        for i in range(n):\n            x, y = centers[i]\n            mb = min(x, y, 1 - x, 1 - y)\n            if radii[i] > mb:\n                radii[i] = mb\n        # pairwise non-overlap\n        for i in range(n):\n            for j in range(i + 1, n):\n                ci = centers[i]; cj = centers[j]\n                dij = np.linalg.norm(ci - cj)\n                rij = radii[i] + radii[j]\n                if dij < rij:\n                    # shrink so sum = dij * factor, use 0.997\n                    target = dij * 0.997\n                    if target < 1e-8:\n                        continue\n                    scale = target / rij\n                    radii[i] *= scale\n                    radii[j] *= scale\n\n    sum_radii = float(np.sum(radii))\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.0638024215765844,
      "additional_data": {
        "sum_radii": "1.063802",
        "target_ratio": "0.403720",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 26,
    "parent_id": 3,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Improved lattice: denser middle band\n    def hex_lattice_coords(num, r_min=0.038):\n        # Optimized row structure for 26 circles: 4,5,8,5,4\n        rows = [4, 5, 8, 5, 4]\n        coords = []\n        dx = (1 - 2 * r_min) / (max(rows) - 1)\n        dy = (1 - 2 * r_min) / (len(rows) - 1)\n        y = r_min\n        for i, nrow in enumerate(rows):\n            offset = (max(rows) - nrow) / 2 * dx\n            for j in range(nrow):\n                x = r_min + offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    # Start with larger radius for initial attempt (so circles fill more)\n    r0 = 0.038\n\n    # Arrange in hex lattice and add smaller random shake\n    centers0 = hex_lattice_coords(n, r_min=r0)\n    np.random.seed(2)\n    centers0 += (np.random.rand(n, 2) - 0.5) * 0.04\n\n    # Initial radii\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    # --- Define constraints ---\n\n    cons = []\n\n    # All circles within bounds: x_i, y_i in [ri, 1-ri]\n    for i in range(n):\n        def makefn_idx(i):\n            return lambda x: x[2*i] - x[2*n+i]  # x_i >= r_i\n        cons.append({'type': 'ineq', 'fun': makefn_idx(i)})\n\n        def makefn_idx2(i):\n            return lambda x: 1 - x[2*i] - x[2*n+i]  # 1 - x_i >= r_i\n        cons.append({'type': 'ineq', 'fun': makefn_idx2(i)})\n\n        def makefn_idy(i):\n            return lambda x: x[2*i+1] - x[2*n+i]  # y_i >= r_i\n        cons.append({'type': 'ineq', 'fun': makefn_idy(i)})\n\n        def makefn_idy2(i):\n            return lambda x: 1 - x[2*i+1] - x[2*n+i]  # 1 - y_i >= r_i\n        cons.append({'type': 'ineq', 'fun': makefn_idy2(i)})\n\n        # radii nonnegative, bounded tighter\n        def makefn_r0(i):\n            return lambda x: x[2*n+i] - 0.012\n        cons.append({'type': 'ineq', 'fun': makefn_r0(i)})\n\n        def makefn_r1(i):\n            return lambda x: 0.15 - x[2*n+i]\n        cons.append({'type': 'ineq', 'fun': makefn_r1(i)})\n\n    # All pairs: dist(center_i, center_j) >= ri + rj\n    for i in range(n):\n        for j in range(i+1, n):\n            def makefun(i, j):\n                return lambda x: (\n                    (x[2*i  ] - x[2*j  ])**2 +\n                    (x[2*i+1] - x[2*j+1])**2\n                )**0.5 - (x[2*n+i] + x[2*n+j] + 0.002)\n            cons.append({'type':'ineq', 'fun': makefun(i,j)})\n\n    # --- Objective: minimize negative sum of radii ---\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    # --- Run optimizer ---\n    result = minimize(\n        objective, x0, constraints=cons, method='SLSQP',\n        options={'ftol':1e-7, 'maxiter': 700, 'disp': False}\n    )\n\n    if not result.success:\n        x = x0\n    else:\n        x = result.x\n\n    centers = x[:2*n].reshape((n,2))\n    radii = x[2*n:]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 2.556049864105322,
      "additional_data": {
        "sum_radii": "2.556050",
        "target_ratio": "0.970038",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 27,
    "parent_id": 14,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    26 circles in a unit square, maximizing sum of radii.\n    Full non-linear optimization:\n        - Parameters are (x, y, r) for each circle.\n        - Constraints enforce inside-square and non-overlap.\n        - Initial guess combines a central hexagon + grid for rim.\n    Returns:\n        centers: (26, 2) numpy array\n        radii: (26,) numpy array\n        sum_radii: float\n    \"\"\"\n    n = 26\n    # Helper function to make a central hexagonal patch of 1+6+12=19 circles\n    def hex_patch(cx, cy, r, n_rings=2):\n        positions = [(cx, cy)]\n        for layer in range(1, n_rings+1):\n            for i in range(6*layer):\n                angle = 2*np.pi*i/(6*layer)\n                dx = layer*2*r*np.cos(angle)\n                dy = layer*2*r*np.sin(angle)\n                positions.append((cx+dx, cy+dy))\n        return np.array(positions)\n    # Estimate r so that 19 circles fit in patch and inside the square\n    center_r = 0.095\n    cen = 0.5\n    cen_positions = hex_patch(cen, cen, center_r, n_rings=2)\n    # If extra, trim\n    cen_positions = cen_positions[:19]\n    # Now 7 more at \"rim\", one per corner, three at mid-edges\n    rim_positions = np.array([\n        [0.07, 0.07],\n        [0.93, 0.07],\n        [0.07, 0.93],\n        [0.93, 0.93],\n        [0.5, 0.04],\n        [0.5, 0.96],\n        [0.96, 0.5]\n    ])\n    assert len(cen_positions) == 19 and rim_positions.shape[0] == 7\n    centers_init = np.vstack([cen_positions, rim_positions])\n    # Initial radii: central ones bigger\n    radii_init = np.ones(n) * 0.07\n    radii_init[:7] = center_r\n    radii_init[19:] = 0.065  # rim a bit smaller\n\n    # Stack all variables: (x0, y0, r0, x1, y1, r1, ...)\n    x0 = np.zeros(n*3)\n    x0[0::3] = centers_init[:,0]\n    x0[1::3] = centers_init[:,1]\n    x0[2::3] = radii_init\n\n    # Bounds for optimizer\n    bounds = []\n    for i in range(n):\n        # x in [r, 1-r], y in [r, 1-r], r in [0.02, 0.16]\n        bounds.append( (0.02, 0.98) )  # x\n        bounds.append( (0.02, 0.98) )  # y\n        bounds.append( (0.018, 0.16) ) # r (minimal, maximal)\n    bounds = tuple(bounds)\n\n    # Non-overlap constraints (pairwise, nonlinear)\n    def all_constraints(vars):\n        cons = []\n        # Border & inside-square: impose through bounds; but also x, y >= r and <= 1-r\n        for i in range(n):\n            xi, yi, ri = vars[3*i:3*i+3]\n            cons.append( xi - ri )      # x >= r  (>=0)\n            cons.append( 1 - xi - ri )  # x <= 1-r (>=0)\n            cons.append( yi - ri )\n            cons.append( 1 - yi - ri )\n            cons.append( ri - 0.018 )   # r >= minrad\n            cons.append( 0.16 - ri )    # r <= maxrad\n        # No-overlap:\n        for i in range(n):\n            xi, yi, ri = vars[3*i:3*i+3]\n            for j in range(i+1, n):\n                xj, yj, rj = vars[3*j:3*j+3]\n                dx = xi - xj\n                dy = yi - yj\n                dist2 = dx*dx + dy*dy\n                min_dist = (ri + rj)\n                cons.append( dist2 - (min_dist*min_dist) ) # \u22650: no overlap\n        return np.array(cons)\n\n    # Objective: maximize sum of radii\n    def objective(vars):\n        radii = vars[2::3]\n        return -np.sum(radii)\n\n    nonlinear_cons = {\n        'type':'ineq',\n        'fun': all_constraints\n    }\n\n    # Use SLSQP or trust-constr (trust-constr handles many constraints better)\n    res = minimize(objective, x0,\n                   method='SLSQP',\n                   bounds=bounds,\n                   constraints=[nonlinear_cons],\n                   options",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 28,
    "parent_id": 19,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n    RMIN = 0.01\n    RMAX = 0.15   # upper limit prevents circles getting \"stuck\" huge\n    UNIT = 1.0\n    N_ATTEMPTS = 32\n    \n    EPS_OVERLAP = 1e-4  # minimum spacing in overlap constraints\n\n    def random_feasible_init(seed=None):\n        # Heuristic: Try to spread circles randomly with radii near avg area packing\n        rng = np.random.RandomState(seed)\n        radii = rng.uniform(RMIN+0.01, 0.042, n)\n        xy = []\n        # Try to avoid overlap at init\n        fails = 0\n        for i in range(n):\n            for _ in range(1000):\n                xi = rng.uniform(radii[i], UNIT - radii[i])\n                yi = rng.uniform(radii[i], UNIT - radii[i])\n                # Only accept if not overlapping (generously)\n                if all(np.hypot(xi-xj, yi-yj) > (radii[i]+radii[j]+0.01)\n                       for j,(xj,yj) in enumerate(xy)):\n                    xy.append((xi, yi))\n                    break\n            else:\n                # fallback: place anyway, with overlap risk\n                fails += 1\n                xy.append((xi, yi))\n        return np.array(xy), radii\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def pack_optimize(x0):\n        cons = []\n        # Boundary constraints for each circle\n        for i in range(n):\n            cons += [\n                {'type':'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},       # x - r \u2265 0\n                {'type':'ineq', 'fun': lambda x, i=i: UNIT - x[2*i]    - x[2*n+i]}, # 1 - x - r \u22650\n                {'type':'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},      # y - r \u2265 0\n                {'type':'ineq', 'fun': lambda x, i=i: UNIT - x[2*i+1] - x[2*n+i]}, # 1 - y - r \u22650\n                {'type':'ineq', 'fun': lambda x, i=i: x[2*n+i] - RMIN},          # r \u2265 RMIN\n                {'type':'ineq', 'fun': lambda x, i=i: RMAX - x[2*n+i]},          # r \u2264 RMAX\n            ]\n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                cons.append({\n                    'type':'ineq',\n                    'fun': lambda x, i=i, j=j: (\n                        np.hypot(x[2*i]-x[2*j], x[2*i+1]-x[2*j+1])\n                        - (x[2*n+i] + x[2*n+j] + EPS_OVERLAP)\n                    )\n                })\n        res = minimize(\n            objective, x0, \n            method='SLSQP', \n            options={'ftol':1e-8, 'disp':False, 'maxiter':3500},\n            constraints=cons,\n        )\n        return res\n        \n    # Generate many random starts\n    best_sum = -np.inf\n    best_x = None\n    for k in range(N_ATTEMPTS):\n        xy, radii = random_feasible_init(seed=2023+k*53)\n        x0 = np.concatenate([xy.flatten(), radii])\n        res = pack_optimize(x0)\n        # Feasibility check\n        if not res.success:\n            continue\n        this_sum = -res.fun\n        if this_sum > best_sum:\n            best_sum = this_sum\n            best_x = res.x\n\n    if best_x is None:\n        # fallback: random initial\n        xy, radii = random_feasible_init(seed=42)\n        best_x = np.concatenate([xy.flatten(), radii])\n        best_sum = np.sum(radii)\n\n    centers = best_x[:2*n].reshape(n,2)\n    radii = best_x[2*n:]\n\n    # === Post-processing: locally grow each circle as much as possible ===\n    def grow_circle(i, x, step=1e-3):\n        # attempt to increase radius i while preserving validity\n        r_old = x[2*n+i]\n        r = r_old\n        while True:\n            r_try = r + step\n            # Check within square\n            xi, yi = x[2*i], x[2*i+1]\n            if not (r_try <= xi <= UNIT - r_try): break\n            if not (r_try <= yi <= UNIT - r_try): break\n            # No overlap to others\n            fail = False\n            for j in range(n):\n                if i == j: continue\n                xj, yj, rj = x[2*j], x[2*j+1], x[2*n+j]\n                if np.hypot(xi-xj, yi-yj) < (r_try + rj + EPS_OVERLAP):\n                    fail = True\n                    break\n            if fail: break\n            r = r_try\n        return r\n\n    # Greedily grow all, one pass (random order for fairness)\n    indices = np.random.permutation(n)\n    for i in indices:\n        r_new = grow_circle(i, best_x)\n        best_x[2*n+i] = r_new\n\n    centers = best_x[:2*n].reshape(n,2)\n    radii = best_x[2*n:]\n    sum_radii = float(np.sum(radii))\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution timed out after 30 seconds"
      }
    }
  },
  {
    "id": 29,
    "parent_id": 17,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef place_corners_edges_interior(n, margin=0.0, arrangement='default'):\n    \"\"\"\n    Place some circles in corners, some on edges, rest interior.\n    Returns centers (n,2).\n    \"\"\"\n    # For 26, use:\n    # 4 corners, 12 edges, 10 interior (general scheme)\n    assert n == 26\n    centers = []\n    r_edge = 0.08   # starting guess, will grow later\n    r_corner = 0.11\n    r_interior = 0.06\n\n    # Corners: (0,0),(0,1),(1,0),(1,1)\n    corner_offsets = [(margin,margin),\n                      (margin,1-margin),\n                      (1-margin,margin),\n                      (1-margin,1-margin)]\n    centers += corner_offsets\n\n    # Edges: Place 3 each on each side (not at corners)\n    edge_num_per = 3\n    # bottom y=margin\n    for i in range(1,edge_num_per+1):\n        dx = (1-2*margin)*(i)/(edge_num_per+1)\n        centers.append((margin+dx, margin))\n    # top y=1-margin\n    for i in range(1,edge_num_per+1):\n        dx = (1-2*margin)*(i)/(edge_num_per+1)\n        centers.append((margin+dx, 1-margin))\n    # left x=margin\n    for i in range(1,edge_num_per+1):\n        dy = (1-2*margin)*(i)/(edge_num_per+1)\n        centers.append((margin, margin+dy))\n    # right x=1-margin\n    for i in range(1,edge_num_per+1):\n        dy = (1-2*margin)*(i)/(edge_num_per+1)\n        centers.append((1-margin, margin+dy))\n\n    # Now the rest: interior core, hex packing, shifted if desired\n    n_remain = n - len(centers)\n    if arrangement == 'default':  # Regular hex, centered\n        n_rows = 3\n        n_cols = 4\n        y_lin = np.linspace(0.28, 0.72, n_rows)\n        x_lin = np.linspace(0.18, 0.82, n_cols)\n        for i in range(n_rows):\n            offset = 0.0 if i%2==0 else (x_lin[1]-x_lin[0])/2\n            for j in range(n_cols):\n                x = x_lin[j] + offset\n                if margin+r_interior < x < 1-margin-r_interior:\n                    centers.append((x, y_lin[i]))\n        # If still short, add extras near center:\n        while len(centers) < n:\n            centers.append((0.5 + 0.15*np.random.randn(),0.5+0.15*np.random.randn()))\n        # If too many, drop farthest from (0.5,0.5)\n        if len(centers) > n:\n            ccent = np.array(centers)\n            dists = np.linalg.norm(ccent - 0.5, axis=1)\n            idx = np.argsort(dists)\n            centers = [centers[i] for i in idx[:n]]\n    else:\n        raise NotImplementedError\n    centers = np.array(centers[:n])\n    return centers\n\ndef grow_radii(centers, margin=0.0, rel_tol=1e-5):\n    \"\"\" \n    Given fixed centers, compute the *largest radius* for each circle s.t. \n    - All circles are in [0,1]^2\n    - No overlap\n    \"\"\"\n    n = len(centers)\n    radii = np.full(n, 0.2, dtype=np.float64) # start large\n    # For each circle, compute the smallest allowed radius\n    order = np.argsort(np.linalg.norm(centers-0.5, axis=1))\n    radii[:] = 0.2\n    for idx in order[::-1]:  # grow from outside in\n        # (1) limit by square boundary\n        x, y = centers[idx]\n        maxr = min(x-margin, 1-margin-x, y-margin, 1-margin-y)\n        # (2) limit by neighbors\n        for j in range(n):\n            if j == idx:\n                continue\n            d = np.linalg.norm(centers[idx] - centers[j])\n            if d <= 0: continue\n            maxr = min(maxr, d - radii[j] - 1e-12)\n        radii[idx] = max(0.005, maxr)\n    # (3) one more pass to fine-tune (shrink slightly if any overlap)\n    for _ in range(3):\n        for i in range(n):\n            for j in range(n):\n                if i==j: continue\n                d = np.linalg.norm(centers[i]-",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 30,
    "parent_id": 10,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n    rs = np.random.RandomState(42)\n\n    # Hexagonal (\"honeycomb\") initialization:\n    # Each row is offset (staggered), spacing is adjusted so all circles fit\n    # We'll try 5 rows, alternating 5/6 per row (total 26)\n    rows = 5\n    cols_per_row = [5, 5, 5, 5, 6]  # 5 rows: last row has 6\n    total = sum(cols_per_row)\n    assert total == n\n\n    # Vertical and horizontal spacings\n    # Let r0 be the \"base\" radius. Horizontal sep: 2*r0, vertical sep: sqrt(3)*r0\n    # Fit in unit square: (cols-1)*hs + 2*r0 <= 1, (rows-1)*vs + 2*r0 <= 1\n    max_cols = max(cols_per_row)\n    hs = 1.0 / (max_cols + 0.2)     # Less than max_cols+1 to allow some margin\n    vs = hs * np.sqrt(3)/2          # Standard hex pattern\n\n    # Row y's, equally spaced, centered\n    y0 = hs/1.8\n    y_slots = [y0 + i*vs for i in range(rows)]\n    centers = []\n    idx = 0\n    for row, num in enumerate(cols_per_row):\n        if num == max_cols:\n            x_start = hs/1.8\n        else:\n            x_start = hs/1.8 + hs / 2\n        xs = [x_start + i*hs for i in range(num)]\n        ys = [y_slots[row]] * num\n        row_centers = np.column_stack([xs, ys])\n        centers.append(row_centers)\n    centers = np.vstack(centers)[:n]\n\n    # Add a little jitter to break perfect symmetry\n    centers += rs.uniform(-0.018, 0.018, centers.shape)\n    # Max radius that keeps all centers within [r, 1-r]\n    margin = np.minimum(centers.min(axis=0), 1-centers.max(axis=0)).min()\n    # Also, can't get closer than half the packing distance\n    rough_sep = min(hs, vs)\n    init_r = min(margin, rough_sep / 2.25)\n    radii = np.full(n, init_r * 0.93)\n\n    # Flatten for optimization: [x0, y0, r0, ...]\n    x0 = np.empty(n * 3)\n    x0[0::3] = centers[:,0]\n    x0[1::3] = centers[:,1]\n    x0[2::3] = radii\n\n    # Bounds\n    bounds = []\n    for i in range(n):\n        bounds.extend([(0.0,1.0), (0.0,1.0), (0.002,0.16)])\n\n    def objective(z):\n        radii = z[2::3]\n        return -np.sum(radii)\n\n    cons = []\n    for i in range(n):\n        def box_left(z, i=i):\n            return z[0 + 3*i] - z[2 + 3*i]\n        def box_right(z, i=i):\n            return 1.0 - (z[0 + 3*i] + z[2 + 3*i])\n        def box_bottom(z, i=i):\n            return z[1 + 3*i] - z[2 + 3*i]\n        def box_top(z, i=i):\n            return 1.0 - (z[1 + 3*i] + z[2 + 3*i])\n        cons.append({'type':'ineq', 'fun':box_left})\n        cons.append({'type':'ineq', 'fun':box_right})\n        cons.append({'type':'ineq', 'fun':box_bottom})\n        cons.append({'type':'ineq', 'fun':box_top})\n    for i in range(n):\n        for j in range(i+1, n):\n            def sep(z, i=i, j=j):\n                xi, yi, ri = z[3*i], z[3*i+1], z[3*i+2]\n                xj, yj, rj = z[3*j], z[3*j+1], z[3*j+2]\n                return np.hypot(xi-xj, yi-yj) - (ri + rj)\n            cons.append({'type':'ineq', 'fun':sep})\n\n    res = minimize(\n        objective, x0, method='SLSQP', bounds=bounds,\n        constraints=cons,\n        options={'disp': False, 'maxiter':2000, 'ftol':1e-8}\n    )\n\n    z = res.x\n    centers = np.stack([z[::3], z[1::3]], axis=-1)\n    radii = z[2::3]\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.6059594673834545,
      "additional_data": {
        "sum_radii": "2.605959",
        "target_ratio": "0.988979",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 31,
    "parent_id": 19,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Tweaked center-heavy hex grid: 7,6,5,4,4\n    def hex_coords(num, r_min=0.0362):\n        rows = [7,6,5,4,4]  # 7+6+5+4+4=26\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx%2 else 0) + (max(rows) - nrow)/2*dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    r0 = 0.0372  # slightly bigger\n    r_min_grid = r0 + 0.002\n\n    centers0 = hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    cons = []\n    # boundary + radius bounds\n    for i in range(n):\n        cons += [\n            {'type':'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n            {'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n            {'type':'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n            {'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n            {'type':'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.008},\n            {'type':'ineq', 'fun': lambda x, i=i: 0.165 - x[2*n+i]},\n        ]\n    # non-overlap constraint with smaller epsilon\n    epsilon = 1e-5\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type':'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i]-x[2*j], x[2*i+1]-x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + epsilon)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0, rad_jit=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n)-0.5)*jitter\n        if rad_jit > 0:\n            xstart[2*n:] += (np.random.rand(n)-0.5)*rad_jit\n            xstart[2*n:] = np.clip(xstart[2*n:], 0.008, 0.165)\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-8, 'maxiter':4000, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    # multi-start, more attempts\n    xs, fits = [], []\n    xbest, fbest = optimize_once(x0, None, 0.0, 0.0)\n    xs.append(xbest); fits.append(fbest)\n    jitters = [0.012, 0.018, 0.022, 0.03, 0.035, 0.042, 0.055, 0.06]\n    radjit = [0.004, 0.006, 0.008, 0.010, 0.012, 0.015, 0.018, 0.02]\n    for idx in range(len(jitters)):\n        xtry, ftry = optimize_once(xbest, seed=20+idx, jitter=jitters[idx], rad_jit=radjit[idx])\n        xs.append(xtry); fits.append(ftry)\n    # pick best\n    ib = int(np.argmax(fits))\n    xopt = xs[ib]\n    centers = xopt[:2*n].reshape(n,2)\n    radii   = xopt[2*n:]\n    return centers, radii, float(np.sum(radii))\n",
    "evaluation": {
      "fitness": 2.5609637672851546,
      "additional_data": {
        "sum_radii": "2.560964",
        "target_ratio": "0.971903",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 32,
    "parent_id": 22,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement on baseline:\n    - Move the 26th circle to the upper-left corner, which is less crowded.\n    - Slightly tweak initial radii guesses to give more to corners/center/outer.\n    - After main shrinkage passes, attempt a gentle \"re-inflation\" for non-constrained circles.\n    \"\"\"\n\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Inner ring of 8 circles\n    inner_ring_r = 0.25\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Outer ring of 16 circles\n    outer_ring_r = 0.40\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # One additional circle in the upper-left corner (less crowded)\n    corner_idx = 25\n    p = 0.06  # initial guess, will tighten later; upper-left\n    centers[corner_idx] = [p, 1 - p]\n    \n    # Assign initial radii with slight variation based on likely available space\n    radii = np.ones(n) * 0.0715\n    radii[0] = 0.081   # center gets a bit more\n    for i in range(1, 9):\n        radii[i] = 0.074   # inner ring slightly more\n    for i in range(9, 25):\n        radii[i] = 0.0695  # outer ring\n    radii[corner_idx] = 0.087  # the new corner can be a bit bigger\n    \n    # Border limit for all\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n    \n    # Overlap shrinking passes\n    for _ in range(9):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = centers[i] - centers[j]\n                d = np.hypot(dx, dy)\n                # avoid div zero\n                if d < 1e-12:\n                    s = 0.5\n                else:\n                    s = min(1.0, (d * 0.987) / (radii[i] + radii[j]))\n                if s < 1.0:\n                    # Slightly more fair shrinkage split, but slightly favor the smaller\n                    avg = (radii[i] + radii[j]) / 2\n                    if radii[i] < radii[j]:\n                        radii[i] *= s**0.65\n                        radii[j] *= s**0.35\n                    else:\n                        radii[j] *= s**0.65\n                        radii[i] *= s**0.35\n        # After each pass, restore border constraint\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    # Final gentle re-inflation: enlarge circles not in contact with any neighbor or edge\n    for i in range(n):\n        x, y = centers[i]\n        r = radii[i]\n        # If circle is at risk of hitting border, skip\n        if min(x, y, 1-x, 1-y) - r < 1e-5:\n            continue\n        # Check contact with other circles\n        ok = True\n        for j in range(n):\n            if i != j:\n                d = np.hypot(*(centers[i] - centers[j]))\n                if d - (r + radii[j]) < 1e-5:\n                    ok = False\n                    break\n        if ok:\n            # gently expand and re-clip to borders\n            radii[i] = min(r * 1.001, x, y, 1-x, 1-y)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.8467850000000001,
      "additional_data": {
        "sum_radii": "1.846785",
        "target_ratio": "0.700867",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 33,
    "parent_id": 17,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef make_hex_grid(n, padding=0.07, seed=None):\n    \"\"\"\n    Generate n points in a nearly hexagonal lattice inside [0,1]x[0,1],\n    spread as evenly as possible.\n    \"\"\"\n    rows = 5\n    cols = 6\n    y = np.linspace(padding, 1-padding, rows)\n    x = np.linspace(padding, 1-padding, cols)\n    centers = []\n    for i in range(rows):\n        # Shift every other row for hex pattern\n        xrow = x.copy()\n        if i%2 == 1:\n            xrow += (x[1]-x[0])/2\n        # Remove out-of-bounds shifted points\n        row_centers = []\n        for xx in xrow:\n            if padding <= xx <= 1-padding:\n                row_centers.append(xx)\n        for xx in row_centers:\n            centers.append((xx,y[i]))\n    # Truncate or randomly sample if too many\n    if seed is not None:\n        np.random.seed(seed)\n    if len(centers) > n:\n        idx = np.random.choice(len(centers), n, replace=False)\n        centers = [centers[i] for i in idx]\n    elif len(centers) < n:\n        # Add random points to balance\n        for _ in range(n - len(centers)):\n            centers.append((padding + (1-2*padding)*np.random.rand(),\n                            padding + (1-2*padding)*np.random.rand()))\n    return np.array(centers)\n\ndef arrange_initial(n, padding=0.07, seed=None):\n    centers = make_hex_grid(n, padding=padding, seed=seed)\n    radii = np.ones(n) * 0.035\n    return centers, radii\n\ndef constraint_no_overlap(vars, n):\n    \"\"\"\n    vars = [x0,y0,r0, x1,y1,r1, ...]\n    Returns array of min-distances between all pairs, must be >=0.\n    \"\"\"\n    res = []\n    centers = vars[:-n].reshape((n,2))\n    radii = vars[-n:]\n    for i in range(n):\n        for j in range(i+1,n):\n            d = np.linalg.norm(centers[i]-centers[j])\n            res.append( d - (radii[i]+radii[j]) )\n    return np.array(res)\n\ndef constraint_in_square(vars, n):\n    \"\"\"\n    Returns constraints for all circles to be inside square [0,1]^2.\n    For each circle, x-r >= 0, x+r <= 1, y-r >=0, y+r <=1\n    \"\"\"\n    centers = vars[:-n].reshape((n,2))\n    radii = vars[-n:]\n    res = []\n    x = centers[:,0]\n    y = centers[:,1]\n    res.extend( x - radii )         # >= 0\n    res.extend( 1 - (x + radii) )   # >= 0\n    res.extend( y - radii )         # >= 0\n    res.extend( 1 - (y + radii) )   # >= 0\n    return np.array(res)\n\ndef objective(vars, n):\n    \"\"\"Negative sum of radii (as we minimize)\"\"\"\n    radii = vars[-n:]\n    return -np.sum(radii)\n\ndef run_packing():\n    n = 26\n    rmin = 0.01\n    rmax = 0.22\n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n    seeds = [0, 99, 123, 2021, 42]  # 5 runs\n    for seed in seeds:\n        # Initial guess\n        centers, radii = arrange_initial(n, padding=0.062, seed=seed)\n        x0 = np.concatenate([centers.ravel(), radii])\n\n        # Bounds\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0,1.0)) # x\n            bounds.append((0.0,1.0)) # y\n        for i in range(n):\n            bounds.append((rmin, rmax))\n\n        cons = []\n        cons.append({'type':'ineq','fun':constraint_no_overlap, 'args':(n,)})\n        cons.append({'type':'ineq','fun':constraint_in_square, 'args':(n,)})\n\n        result = minimize(objective, x0, args=(n,),\n                          method='SLSQP',\n                          bounds=bounds,\n                          constraints=cons,\n                          options={'maxiter':1200,'ftol':1e-8,'disp':False})\n\n        if not result.success:\n            continue\n        xopt = result.x\n        centers_ = xopt[:-n].reshape((n,2))\n        radii_ = xopt[-n:]\n        sum_radii_ = np.sum(radii_)\n        # Secondary fine-tune polish run\n        res2 = minimize(objective, xopt, args=(n,),\n                        method='SLSQP',\n                        bounds=bounds,\n                        constraints=cons,\n                        options={'maxiter':120, 'ftol':1e-10, 'disp':False})\n        if res2.success and -res2.fun > sum_radii_:\n            xopt = res2.x\n            centers_ = xopt[:-n].reshape((n,2))\n            radii_ = xopt[-n:]\n            sum_radii_ = np.sum(radii_)\n        if sum_radii_ > best_sum:\n            best_sum = sum_radii_\n            best_centers = centers_.copy()\n            best_radii = radii_.copy()\n    if best_centers is None:\n        # fallback: last try\n        best_centers = centers\n        best_radii = radii\n        best_sum = np.sum(best_radii)\n    return best_centers, best_radii, best_sum\n",
    "evaluation": {
      "fitness": 2.6203226098795556,
      "additional_data": {
        "sum_radii": "2.620323",
        "target_ratio": "0.994430",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 34,
    "parent_id": 19,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n    max_trials = 500\n    seed = 42\n    np.random.seed(seed)\n\n    # Helper: finds maximal radius at (x,y) w.r.t. other circles and square\n    def max_feasible_radius(x, y, centers, radii, margin=1e-5):\n        # Bound by square\n        r_b = min(x,1-x, y,1-y)\n        if len(centers) > 0:\n            dists = np.hypot(centers[:,0]-x, centers[:,1]-y) - radii\n            r_b = min(r_b, *dists)\n        return max(r_b-margin, 0.0)\n\n    # Constructively place circles, one at a time (greedily largest first)\n    centers = []\n    radii = []\n    for k in range(n):\n        best_r = 0\n        best_pos = None\n        # Search for good spot: try many random points within square, pick largest feasible\n        trials = max_trials + 400*(k>16)\n        for _ in range(trials):\n            x = np.random.uniform(0,1)\n            y = np.random.uniform(0,1)\n            r = max_feasible_radius(x, y, np.array(centers), np.array(radii))\n            if r > best_r:\n                best_r = r\n                best_pos = (x,y)\n        # If no non-zero possible, reduce margin and try again\n        if best_r < 1e-4:\n            # Try to place a tiny circle in a gap\n            for _ in range(2000):\n                x = np.random.uniform(0,1)\n                y = np.random.uniform(0,1)\n                r = max_feasible_radius(x, y, np.array(centers), np.array(radii), margin=0)\n                if r > best_r:\n                    best_r = r\n                    best_pos = (x,y)\n            if best_r < 2e-5:\n                # Should not happen for n=26, but in pathological case pick a random position and tiny radius\n                best_r = 0.008\n                best_pos = (np.random.uniform(0,1), np.random.uniform(0,1))\n        centers.append(best_pos)\n        radii.append(best_r)\n    centers = np.array(centers)\n    radii = np.array(radii)\n\n    # Now locally optimize positions & radii for maximal sum with constraints\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    cons = []\n    # Boundary & positivity\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]-x[2*n+i]},              # x - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i] - x[2*n+i]},        # x + r <= 1\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},          # y - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},      # y + r <= 1\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.0075},            # r >= min radius\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.20 - x[2*n+i]},              # r <= max radius\n        ]\n    # No overlap\n    epsilon = 1e-5\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type':'ineq',\n                'fun': lambda x, i=i, j=j:\n                        (np.hypot(x[2*i]-x[2*j], x[2*i+1]-x[2*j+1]) -\n                         (x[2*n+i]+x[2*n+j] + epsilon))\n            })\n\n    def objective(x):  # maximize sum of radii\n        return -np.sum(x[2*n:])\n\n    # Warm up: use fewer iterations at first, then tighten approach\n    res = minimize(objective, x0, constraints=cons, method='SLSQP',\n                   options={'ftol':1e-6, 'maxiter':1200, 'disp': False})\n\n    # Multistart: perturb, re-optimize, take best\n    xbest = res.x\n    fbest = -res.fun\n\n    for i in range(2):\n        jitter = 0.012 if i == 0 else 0.027\n        xstart = xbest.copy()\n        xstart[:2*n] += (np.random.rand(2*n)-0.5)*jitter\n        res2 = minimize(objective, xstart, constraints=cons, method='SLSQP',\n                        options={'ftol':1e-7, 'maxiter':1500, 'disp': False})\n        if res2.success and -res2.fun > fbest:\n            xbest = res2.x\n            fbest = -res2.fun\n\n    centers = xbest[:2*n].reshape(n,2)\n    radii = xbest[2*n:]\n    sum_radii = np.sum(radii)\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 2.473261726285412,
      "additional_data": {
        "sum_radii": "2.473262",
        "target_ratio": "0.938619",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 35,
    "parent_id": 31,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n_circles = 26\n    # Parameters for constructive pack\n    grid_N = 28   # grid granularity (# points per side)\n    r_min = 0.008\n    r_max = 0.17\n    epsilon = 1e-8\n\n    centers = []\n    radii = []\n\n    # Dense packing greedy routine\n    def find_next_circle(existing_centers, existing_radii):\n        grid1d = np.linspace(r_min, 1 - r_min, grid_N)\n        grid = np.array(np.meshgrid(grid1d, grid1d)).reshape(2, -1).T\n        max_r = 0\n        best_xy = None\n        for pt in grid:\n            # Find largest feasible radius at pt\n            # Distance to square edge\n            to_edge = min(pt[0], pt[1], 1-pt[0], 1-pt[1])\n            # Distance to prior circles\n            if len(existing_centers) == 0:\n                nearest = np.inf\n            else:\n                dists = np.linalg.norm(existing_centers - pt, axis=1)\n                nearest = np.min(dists - np.array(existing_radii))\n            candid_r = min(to_edge, nearest)\n            if candid_r > max_r + 1e-10 and candid_r > r_min:\n                max_r = candid_r\n                best_xy = pt\n        if best_xy is not None:\n            return best_xy, max(max_r, r_min)\n        else:\n            # fallback: pick anywhere with r_min\n            for pt in grid:\n                if all(np.linalg.norm(np.array(pt) - np.array(c), axis=-1) >= r_min + rr - epsilon\n                       for c, rr in zip(existing_centers, existing_radii)):\n                    return pt, r_min\n            # should not occur unless grid is coarse!\n            return np.random.uniform(r_min,1-r_min,2), r_min\n\n    # -- Greedily add circles\n    for _ in range(n_circles):\n        xy, r = find_next_circle(np.array(centers) if len(centers)>0 else np.zeros((0,2)), radii)\n        centers.append(xy)\n        radii.append(r)\n\n    centers = np.array(centers)\n    radii = np.array(radii)\n    # Possibly shuffle order to break patterns (can help local opt)\n    shuff = np.argsort(-radii + 0.02 * np.random.rand(n_circles))\n    centers = centers[shuff]\n    radii = radii[shuff]\n\n    # -- Local optimization (positions+radii)\n    n = n_circles\n    def obj(x):\n        return -np.sum(x[2*n:])  # maximize total radii\n\n    # Constraints\n    cons = []\n    # Bounds: stay in square (center +/- radius)\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},              # x - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]   - x[2*n+i]},          # 1 - x - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},              # y - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},          # 1 - y - r >=0\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - r_min},                 # r >= r_min\n            {'type': 'ineq', 'fun': lambda x, i=i: r_max - x[2*n+i]},                 # r <= r_max\n        ]\n    # Non-overlapping: center distance >= sum of radii\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i]-x[2*j], x[2*i+1]-x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + epsilon)\n                )\n            })\n\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # multi-start local optimization for robustness\n    best_x, best_fit = x0, np.sum(radii)\n    for seed in range(4):\n        xstart = x0.copy()\n        np.random.seed(100+seed)\n        # Small jitter to escape bad local minima\n        xstart[:2*n] += (np.random.rand(2*n) - 0.5) * 0.011\n        xstart[2*n:] += (np.random.rand(n) - 0.5) * 0.009\n        xstart[2*n:] = np.clip(xstart[2*n:], r_min, r_max)\n        res = minimize(\n            obj, xstart, constraints=cons, method='SLSQP',\n            options={'ft",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 36,
    "parent_id": 19,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    def alt_hex_coords(num, r_min=0.0385):\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx%2 else 0) + (max(rows)-nrow)/2*dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    # initial guess\n    r0 = 0.0365\n    r_min_grid = r0 + 0.0025\n    centers0 = alt_hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    # constraints\n    cons = []\n    # boundary + radius bounds\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.008},\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.16 - x[2*n+i]},\n        ]\n    # non-overlap (tighter epsilon)\n    epsilon = 1e-5\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + epsilon)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n)-0.5) * jitter\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-9, 'maxiter':4000, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    # multi-start refinement\n    xs, fits = [], []\n    xbest, fbest = optimize_once(x0, seed=None, jitter=0.0)\n    xs.append(xbest); fits.append(fbest)\n    for idx, jit in enumerate([0.012,0.015,0.025,0.030,0.040]):\n        xtry, ftry = optimize_once(xbest, seed=100+idx, jitter=jit)\n        xs.append(xtry); fits.append(ftry)\n    ib = int(np.argmax(fits))\n    xopt = xs[ib]\n    centers = xopt[:2*n].reshape(n,2)\n    radii   = xopt[2*n:]\n\n    # greedy inflation step\n    def inflate(centers, radii, iterations=3, eps=1e-6):\n        n = len(radii)\n        for _ in range(iterations):\n            for i in range(n):\n                x_i, y_i = centers[i]\n                # boundary slack\n                r_max = min(x_i, 1-x_i, y_i, 1-y_i)\n                # neighbor slack\n                for j in range(n):\n                    if i == j: continue\n                    d = np.hypot(x_i-centers[j,0], y_i-centers[j,1]) - radii[j]\n                    if d < r_max:\n                        r_max = d\n                radii[i] = max(radii[i], max(0.0, r_max - eps))\n        return radii\n\n    radii = inflate(centers, radii, iterations=5)\n    sum_radii = float(np.sum(radii))\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.6306326112121634,
      "additional_data": {
        "sum_radii": "2.630633",
        "target_ratio": "0.998343",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 37,
    "parent_id": 36,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n    square = np.array([[0,0], [1,0], [1,1], [0,1]])\n    np.random.seed(42)\n\n    # Evaluate if a candidate circle is feasible (inside box, non-overlapping others)\n    def is_feasible(center, radius, centers, radii, min_radius=0.007):\n        x, y = center\n        # Inside box\n        if (x-radius < 0) or (x+radius > 1) or (y-radius < 0) or (y+radius > 1):\n            return False\n        if radius < min_radius or radius > 0.24:\n            return False\n        if centers.shape[0] == 0:\n            return True\n        # No overlap\n        dists = np.linalg.norm(centers - center, axis=1)\n        if np.any(dists < (radii + radius - 1e-10)):\n            return False\n        return True\n\n    # For a given point, what's the max feasible radius (given others)\n    def max_radius_for_point(point, centers, radii):\n        x, y = point\n        # Boundary max\n        boundary_max = min(x, 1-x, y, 1-y)\n        # Non-overlap max\n        if centers.shape[0] > 0:\n            dists = np.linalg.norm(centers - point, axis=1) - radii\n            neighbor_max = np.min(dists) if np.all(dists > 0) else 0.0\n            return max(0.0, min(boundary_max, neighbor_max))\n        else:\n            return max(0.0, boundary_max)\n\n    # For a given candidate point set, greedily pack circles sequentially\n    def greedy_sequential_placement(points, n_circles, min_radius=0.007):\n        centers = []\n        radii = []\n        used = np.zeros(len(points), dtype=bool)\n        for i in range(n_circles):\n            best_r = 0\n            best_p = None\n            best_idx = None\n            # Try each unused grid location\n            for idx, pt in enumerate(points):\n                if used[idx]:\n                    continue\n                r = max_radius_for_point(pt, np.array(centers) if centers else np.zeros((0,2)), np.array(radii) if radii else np.zeros(0))\n                if r > best_r + 1e-10 and r > min_radius:\n                    best_r = r\n                    best_p = pt\n                    best_idx = idx\n            if best_p is not None:\n                centers.append(np.array(best_p))\n                radii.append(best_r)\n                used[best_idx] = True\n            else:\n                # If stuck, try to fill remaining randomly (should rarely happen)\n                trials = 0\n                while trials < 1000:\n                    trial_pt = np.random.uniform(0.0+min_radius, 1.0-min_radius, size=2)\n                    r = max_radius_for_point(trial_pt, np.array(centers), np.array(radii))\n                    if r > min_radius:\n                        centers.append(trial_pt)\n                        radii.append(r)\n                        break\n                    trials += 1\n                else:\n                    # Give up\n                    break\n        return np.array(centers), np.array(radii)\n\n    # Generate candidate grid (staggered hex plus edge points)\n    def make_candidate_grid(npoints=33, border_points=11):\n        # Staggered hex grid in the interior\n        ys = np.linspace(0.03,0.97,npoints)\n        xs = np.linspace(0.03,0.97,npoints)\n        points = []\n        for i,y in enumerate(ys):\n            offs = (0.5*(xs[1]-xs[0]) if i%2 else 0.0)\n            for x in xs:\n                x2 = x + offs\n                if x2>=0.02 and x2<=0.98:\n                    points.append((x2,y))\n        # Add a dense border grid, for edge packing\n        border_lin = np.linspace(0.013,0.987,border_points)\n        for t in border_lin:\n            points.append((t,0.013))\n            points.append((t,0.987))\n            points.append((0.013,t))\n            points.append((0.987,t))\n        return np.array(points)\n\n    candidate_grid = make_candidate_grid()\n\n    # Try several random orderings and subsets for robust greedy packing\n    best_total = 0\n    best_centers = None\n    best_radii = None\n    for trial in range(14):\n        shuffled = candidate_grid.copy()\n        np.random.shuffle(shuffled)\n        if trial < 10:\n            use_points = shuffled\n        else:\n            # Try a couple smaller grid subsets\n            use_points = candidate_grid[np.random.choice(np.arange(len(candidate_grid)), size=72, replace=False)]\n        centers, radii = greedy_sequential_placement(use_points, n, min_radius=0.0095 + 0.0022*np.random.beta(0.5,0.6))\n        s = np.sum(radii)\n        if len(centers)==n and s > best_total+1e-8:\n            best_total = s\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n\n    # If failed, fall back on grid-based (shouldn't happen)\n    if best_centers is None:\n        centers, radii = greedy_sequential_placement(candidate_grid, n, min_radius=0.012)\n       ",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 38,
    "parent_id": 37,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n    square = np.array([[0,0], [1,0], [1,1], [0,1]])\n    np.random.seed(42)\n\n    def is_feasible(center, radius, centers, radii, min_radius=0.007):\n        x, y = center\n        if (x-radius < 0) or (x+radius > 1) or (y-radius < 0) or (y+radius > 1):\n            return False\n        if radius < min_radius or radius > 0.24:\n            return False\n        if centers.shape[0] == 0:\n            return True\n        dists = np.linalg.norm(centers - center, axis=1)\n        if np.any(dists < (radii + radius - 1e-10)):\n            return False\n        return True\n\n    def max_radius_for_point(point, centers, radii):\n        x, y = point\n        boundary_max = min(x, 1-x, y, 1-y)\n        if centers.shape[0] > 0:\n            dists = np.linalg.norm(centers - point, axis=1) - radii\n            neighbor_max = np.min(dists) if np.all(dists > 0) else 0.0\n            return max(0.0, min(boundary_max, neighbor_max))\n        else:\n            return max(0.0, boundary_max)\n\n    def greedy_sequential_placement(points, n_circles, min_radius=0.0075):\n        centers = []\n        radii = []\n        used = np.zeros(len(points), dtype=bool)\n        for i in range(n_circles):\n            best_r = 0\n            best_p = None\n            best_idx = None\n            for idx, pt in enumerate(points):\n                if used[idx]:\n                    continue\n                r = max_radius_for_point(pt, np.array(centers) if centers else np.zeros((0,2)), np.array(radii) if radii else np.zeros(0))\n                if r > best_r + 1e-10 and r > min_radius:\n                    best_r = r\n                    best_p = pt\n                    best_idx = idx\n            if best_p is not None:\n                centers.append(np.array(best_p))\n                radii.append(best_r)\n                used[best_idx] = True\n            else:\n                # Try to fill remaining randomly (rare)\n                trials = 0\n                while trials < 1000:\n                    trial_pt = np.random.uniform(0.0+min_radius, 1.0-min_radius, size=2)\n                    r = max_radius_for_point(trial_pt, np.array(centers), np.array(radii))\n                    if r > min_radius:\n                        centers.append(trial_pt)\n                        radii.append(r)\n                        break\n                    trials += 1\n                else:\n                    break\n        return np.array(centers), np.array(radii)\n\n    def make_candidate_grid(npoints=37, border_points=14):\n        ys = np.linspace(0.025,0.975,npoints)\n        xs = np.linspace(0.025,0.975,npoints)\n        points = []\n        for i,y in enumerate(ys):\n            offs = (0.5*(xs[1]-xs[0]) if i%2 else 0.0)\n            for x in xs:\n                x2 = x + offs\n                if x2>=0.018 and x2<=0.982:\n                    points.append((x2,y))\n        # Denser border grid for edges\n        border_lin = np.linspace(0.009,0.991,border_points)\n        for t in border_lin:\n            points.append((t,0.009))\n            points.append((t,0.991))\n            points.append((0.009,t))\n            points.append((0.991,t))\n        return np.array(points)\n\n    candidate_grid = make_candidate_grid()\n\n    best_total = 0\n    best_centers = None\n    best_radii = None\n    for trial in range(16):\n        shuffled = candidate_grid.copy()\n        np.random.shuffle(shuffled)\n        if trial < 12:\n            use_points = shuffled\n        else:\n            use_points = candidate_grid[np.random.choice(np.arange(len(candidate_grid)), size=86, replace=False)]\n        centers, radii = greedy_sequential_placement(\n            use_points, n,\n            min_radius=0.0088 + 0.0016*np.random.beta(0.4,0.7)\n        )\n        s = np.sum(radii)\n        if len(centers)==n and s > best_total+1e-8:\n            best_total = s\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n\n    if best_centers is None:\n        centers, radii = greedy_sequential_placement(candidate_grid, n, min_radius=0.0087)\n        best_centers = centers\n        best_radii = radii\n\n    # Compute sum_radii\n    sum_radii = np.sum(best_radii)\n    return np.array(best_centers), np.array(best_radii), float(sum_radii)\n",
    "evaluation": {
      "fitness": 1.382689437704629,
      "additional_data": {
        "sum_radii": "1.382689",
        "target_ratio": "0.524740",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 39,
    "parent_id": 15,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef initial_hexgrid(n, margin=0.03):\n    best_diff = 1e9\n    best_rows, best_cols = None, None\n    for rows in range(4, 9):\n        cols = int(np.ceil(n / rows))\n        diff = abs(rows - cols * np.sqrt(3)/2)\n        if diff < best_diff:\n            best_diff, best_rows, best_cols = diff, rows, cols\n    rows, cols = best_rows, best_cols\n\n    dy = (1 - 2*margin) / (rows - 1) if (rows-1)>0 else 1\n    dx = (1 - 2*margin) / (cols - 1) if (cols-1)>0 else 1\n    centers = []\n    for r in range(rows):\n        y = margin + r * dy\n        shift = 0.5*dx if r % 2 == 1 and cols > 1 else 0\n        for c in range(cols):\n            x = margin + c * dx + shift\n            if 0 <= x <= 1 and 0 <= y <= 1:\n                centers.append([x, y])\n    centers = np.array(centers)\n    if len(centers) > n:\n        centers = centers[:n]\n    elif len(centers) < n:\n        extra = n - len(centers)\n        extras = margin + (1-2*margin)*np.random.rand(extra,2)\n        centers = np.vstack([centers, extras])\n    return centers\n\ndef pack_objective(x, n):\n    return -np.sum(x[2::3])\n\ndef gen_constraints(n):\n    constraints = []\n    def make_in_square(idx):\n        return [\n            {'type':'ineq', 'fun': lambda x, idx=idx: x[3*idx]     - x[3*idx+2]},   # x - r >= 0\n            {'type':'ineq', 'fun': lambda x, idx=idx: 1 - x[3*idx] - x[3*idx+2]},  # 1-x - r >= 0\n            {'type':'ineq', 'fun': lambda x, idx=idx: x[3*idx+1]   - x[3*idx+2]},  # y - r >= 0\n            {'type':'ineq', 'fun': lambda x, idx=idx: 1 - x[3*idx+1] - x[3*idx+2]},# 1-y - r >= 0\n            {'type':'ineq', 'fun': lambda x, idx=idx: x[3*idx+2]},                # r >= 0\n            {'type':'ineq', 'fun': lambda x, idx=idx: 0.30 - x[3*idx+2]}          # r <= 0.30\n        ]\n    def make_nonoverlap(i,j):\n        return {\n            'type':'ineq',\n            'fun': lambda x, i=i, j=j: (\n                np.linalg.norm(x[3*i:3*i+2] - x[3*j:3*j+2]) - (x[3*i+2] + x[3*j+2]) + 1e-5\n            )\n        }\n    for idx in range(n):\n        constraints += make_in_square(idx)\n    for i in range(n):\n        for j in range(i+1, n):\n            constraints.append(make_nonoverlap(i,j))\n    return constraints\n\ndef circles_valid(centers, radii):\n    n = len(centers)\n    # Non-negative radii, inside box\n    if np.any(radii < 0): return False\n    if np.any(centers[:,0]-radii < -1e-8): return False\n    if np.any(centers[:,0]+radii > 1+1e-8): return False\n    if np.any(centers[:,1]-radii < -1e-8): return False\n    if np.any(centers[:,1]+radii > 1+1e-8): return False\n    # No overlaps\n    for i in range(n):\n        for j in range(i+1, n):\n            dist = np.linalg.norm(centers[i]-centers[j])\n            if dist < (radii[i]+radii[j] - 1e-8):\n                return False\n    return True\n\ndef apply_postprocess(centers, radii, max_iter=8):\n    n = len(centers)\n    # Shrink as needed and clip into bounding box\n    radii = np.copy(radii)\n    for _ in range(max_iter):\n        # Clamp to box\n        radii = np.minimum(radii, centers[:,0])\n        radii = np.minimum(radii, 1 - centers[:,0])\n        radii = np.minimum(radii, centers[:,1])\n        radii = np.minimum(radii, 1 - centers[:,1])\n        # Clamp to max 0.30\n        radii = np.minimum(radii, 0.30)\n        # Clamp to min 1e-5\n        radii = np.maximum(radii, 1e-5)\n        # Reduce radii for overlap\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = radii[i] + radii[j] - dist\n                if overlap > 0:\n                    # Reduce both radii proportionally\n                    reduction = 0.5*overlap + 1e-6\n                    radii[i] -= reduction\n                    radii[j] -= reduction\n                    radii[i] = max(radii[i], 1e-5)\n                    radii[j] = max(r",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 40,
    "parent_id": 22,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Add three more corner circles (for a total of 4), each at [p,p], [1-p,p], [p,1-p], [1-p,1-p]\n    - Remove 3 from outer ring (so: outer ring 13), keep total n=26\n    - Assign slightly bigger radii to outer ring, smaller to corners\n    - Relax overlap shrinkage a bit (0.985 -> 0.99)\n    - Add final \"grow\" pass to maximize sum\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Inner ring of 8\n    inner_ring_r = 0.25\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Outer ring of 13 (removed 3 to place 3 more in corners)\n    outer_ring_r = 0.40\n    for i in range(13):\n        angle = 2 * np.pi * i / 13\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # Four corners (must be within [r,r], [1-r,r], etc)\n    p = 0.065  # initial guess, will shrink as needed\n    corners = [\n        [p, p], \n        [1 - p, p], \n        [1 - p, 1 - p], \n        [p, 1 - p],\n    ]\n    for k in range(4):\n        centers[22 + k] = corners[k]\n    \n    # Initial radii: try to fill maximally\n    radii = np.ones(n) * 0.073\n    radii[0] = 0.083  # center\n    for i in range(1, 9):\n        radii[i] = 0.075  # inner ring\n    for i in range(9, 22):\n        radii[i] = 0.072  # outer ring\n    for i in range(22, 26):\n        radii[i] = 0.063  # corners, smaller\n    \n    # Border constraint pass\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n    \n    # Iterative overlap resolution\n    for _ in range(9):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = centers[i] - centers[j]\n                d = np.hypot(dx, dy)\n                if d < 1e-12:\n                    s = 0.5\n                else:\n                    s = min(1.0, (d * 0.99) / (radii[i] + radii[j]))\n                if s < 1.0:\n                    if radii[i] < radii[j]:\n                        radii[i] *= s\n                    else:\n                        radii[j] *= s\n        # Border constraint again\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n    \n    # Final grow step: try to increase radii a tiny bit if possible\n    grow_factor = 1.001\n    for k in range(3):  # do 3 rounds\n        for i in range(n):\n            old_r = radii[i]\n            max_r = min(centers[i][0], centers[i][1], 1 - centers[i][0], 1 - centers[i][1])\n            candidate_r = min(old_r * grow_factor, max_r)\n            valid = True\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.hypot(*(centers[i] - centers[j]))\n                if d < candidate_r + radii[j] - 1e-10:\n                    valid = False\n                    break\n            if valid:\n                radii[i] = candidate_r\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.8766186148709987,
      "additional_data": {
        "sum_radii": "1.876619",
        "target_ratio": "0.712189",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 41,
    "parent_id": 23,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved: Construct arrangement of 26 circles in unit square to maximize sum of radii.\n    (Small iterative improvement over provided baseline.)\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles: push slightly farther out\n    r1 = 0.283  # was 0.275\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r1 * np.cos(angle), 0.5 + r1 * np.sin(angle)]\n    \n    # Ring of 16 circles, closer to the edge. Use gentler jitter.\n    r2 = 0.46  # was 0.45\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        jitter_scale = 0.004  # smaller jitter\n        jitter = jitter_scale * np.array([np.sin(angle*3.2), np.cos(angle*2.3)])\n        centers[i + 9] = [0.5 + r2 * np.cos(angle), 0.5 + r2 * np.sin(angle)]\n        centers[i + 9] += jitter\n    \n    # 26th circle: adjust y-position to optimize fit\n    centers[25] = [0.5, 0.117]  # was 0.12, now nudged down a bit\n    \n    # Start with radii: slightly increased guess\n    radii = np.full(n, 0.115)\n    \n    # More passes for finer adjustment\n    num_passes = 24  # was 17\n    \n    # Use a slightly tighter overlap factor\n    shrink_factor = 0.996  # was 0.994\n    \n    for _ in range(num_passes):\n        # Limit by distance to square borders\n        for i in range(n):\n            x, y = centers[i]\n            max_r_border = min(x, y, 1 - x, 1 - y)\n            if radii[i] > max_r_border:\n                radii[i] = max_r_border\n\n        # Limit by distance to other circles (minimize overlap)\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                eps = 1e-13\n                if dist < eps:\n                    scale = 0.5\n                else:\n                    scale = min(1.0, (dist * shrink_factor) / (radii[i] + radii[j]) )\n                if scale < 1.0:\n                    r_sum = radii[i] + radii[j]\n                    if r_sum > 0:\n                        ratio_i = radii[i] / r_sum\n                        ratio_j = radii[j] / r_sum\n                        radii[i] = ratio_i * dist * shrink_factor\n                        radii[j] = ratio_j * dist * shrink_factor\n\n    # Final expansion: greedy, each radius increases individually (largest first)\n    for idx in np.argsort(-radii):\n        max_r = min(centers[idx][0], centers[idx][1], 1-centers[idx][0], 1-centers[idx][1])\n        for j in range(n):\n            if j == idx:\n                continue\n            dist = np.linalg.norm(centers[idx] - centers[j])\n            if dist - radii[j] < max_r:\n                max_r = dist - radii[j]\n        max_r = max(max_r, 0.0)\n        radii[idx] = min(radii[idx], max_r)\n    \n    # Additional pass: expand smallest circles last, to fill remaining gaps\n    for idx in np.argsort(radii):\n        max_r = min(centers[idx][0], centers[idx][1], 1-centers[idx][0], 1-centers[idx][1])\n        for j in range(n):\n            if j == idx:\n                continue\n            dist = np.linalg.norm(centers[idx] - centers[j])\n            if dist - radii[j] < max_r:\n                max_r = dist - radii[j]\n        max_r = max(max_r, 0.0)\n        radii[idx] = min(radii[idx], max_r)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.9788903201244996,
      "additional_data": {
        "sum_radii": "1.978890",
        "target_ratio": "0.751002",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 42,
    "parent_id": 23,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved iterative arrangement of 26 circles in unit square maximizing sum of radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Ring of 8 circles, first shell\n    r1 = 0.275\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r1 * np.cos(angle), 0.5 + r1 * np.sin(angle)]\n\n    # Ring of 16 circles, near edge\n    r2 = 0.45\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        jitter = 0.007 * np.array([np.sin(angle*3.2), np.cos(angle*2.3)])\n        centers[i + 9] = [0.5 + r2 * np.cos(angle), 0.5 + r2 * np.sin(angle)]\n        centers[i + 9] += jitter\n\n    # 26th circle (bottom wedge), nudged slightly lower to make expansion more feasible\n    centers[25] = [0.5, 0.09]\n\n    # Start with slightly larger initial radii for the outermost ring\n    radii = np.full(n, 0.11)\n    for i in range(9, 25):   # outermost 16 ring\n        radii[i] = 0.1165\n    for i in range(1, 9):    # inner 8 ring\n        radii[i] = 0.1125\n    radii[0] = 0.107      # central circle\n    radii[25] = 0.105     # bottom wedge\n\n    num_passes = 22   # increased for finer converged adjustment\n    for _ in range(num_passes):\n        # limit by border\n        for i in range(n):\n            x, y = centers[i]\n            max_r_border = min(x, y, 1 - x, 1 - y)\n            if radii[i] > max_r_border:\n                radii[i] = max_r_border\n\n        # limit by pairwise overlaps, use slightly closer (0.996) fudge factor\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                eps = 1e-13\n                if dist < eps:\n                    scale = 0.5\n                else:\n                    scale = min(1.0, (dist * 0.996) / (radii[i] + radii[j]))\n                if scale < 1.0:\n                    r_sum = radii[i] + radii[j]\n                    if r_sum > 0:\n                        ratio_i = radii[i] / r_sum\n                        ratio_j = radii[j] / r_sum\n                        radii[i] = ratio_i * dist * 0.996\n                        radii[j] = ratio_j * dist * 0.996\n\n    # Final greedy: expand smallest radii first (those most squeezed)\n    for idx in np.argsort(radii):\n        max_r = min(centers[idx][0], centers[idx][1], 1-centers[idx][0], 1-centers[idx][1])\n        for j in range(n):\n            if j == idx:\n                continue\n            dist = np.linalg.norm(centers[idx] - centers[j])\n            if dist - radii[j] < max_r:\n                max_r = dist - radii[j]\n        max_r = max(max_r, 0.0)\n        radii[idx] = min(radii[idx], max_r * 0.996)\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.021714799335283,
      "additional_data": {
        "sum_radii": "2.021715",
        "target_ratio": "0.767254",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 43,
    "parent_id": 23,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct arrangement of 26 circles in unit square to maximize sum of radii.\n    Small improvements to ring placement, jitter, and post-pass radii adjustment.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # First ring of 8 circles\n    r1 = 0.275\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r1 * np.cos(angle), 0.5 + r1 * np.sin(angle)]\n    \n    # Second ring of 16, even closer to the border\n    r2 = 0.462  # increased from 0.45\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        jitter = 0.012 * np.array([np.sin(angle*3.2), np.cos(angle*2.3)])  # increased jitter\n        centers[i + 9] = [0.5 + r2 * np.cos(angle), 0.5 + r2 * np.sin(angle)]\n        centers[i + 9] += jitter\n\n    # Wedge circle, move it further down\n    centers[25] = [0.5, 0.08]  # moved from 0.12 to 0.08\n\n    # Liberal initial radii\n    radii = np.full(n, 0.115)\n    \n    # More passes for finer adjustment\n    num_passes = 23  # increased from 17\n    for _ in range(num_passes):\n        # Limit by distance to square borders\n        for i in range(n):\n            x, y = centers[i]\n            max_r_border = min(x, y, 1 - x, 1 - y)\n            if radii[i] > max_r_border:\n                radii[i] = max_r_border\n    \n        # Limit by distance to other circles (minimize overlap)\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                eps = 1e-13\n                if dist < eps:\n                    scale = 0.5  # in rare pathological case\n                else:\n                    scale = min(1.0, (dist * 0.994) / (radii[i] + radii[j]) )\n                if scale < 1.0:\n                    r_sum = radii[i] + radii[j]\n                    if r_sum > 0:\n                        ratio_i = radii[i] / r_sum\n                        ratio_j = radii[j] / r_sum\n                        radii[i] = ratio_i * dist * 0.994\n                        radii[j] = ratio_j * dist * 0.994\n\n    # Final expansion, two passes: descending then ascending order\n    sort_order = np.argsort(-radii)\n    for ordering in [sort_order, sort_order[::-1]]:\n        for idx in ordering:\n            max_r = min(centers[idx][0], centers[idx][1], 1-centers[idx][0], 1-centers[idx][1])\n            for j in range(n):\n                if j == idx:\n                    continue\n                dist = np.linalg.norm(centers[idx] - centers[j])\n                if dist - radii[j] < max_r:\n                    max_r = dist - radii[j]\n            max_r = max(max_r, 0.0)\n            radii[idx] = min(radii[idx], max_r)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.9687547448220037,
      "additional_data": {
        "sum_radii": "1.968755",
        "target_ratio": "0.747156",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 44,
    "parent_id": 36,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    def alt_hex_coords(num, r_min=0.0383):\n        # Slightly tighter packing compared to previous code\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx%2 else 0) + (max(rows)-nrow)/2*dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    # initial guess with slightly smaller r0 and r_min_grid (to allow tighter packing at start)\n    r0 = 0.0362\n    r_min_grid = r0 + 0.0022\n    centers0 = alt_hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    # constraints\n    cons = []\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.008},\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.16 - x[2*n+i]},\n        ]\n    epsilon = 1e-5\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + epsilon)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n)-0.5) * jitter\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-10, 'maxiter':4200, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    # multi-start refinement with slightly more aggressive jitters\n    xs, fits = [], []\n    xbest, fbest = optimize_once(x0, seed=None, jitter=0.0)\n    xs.append(xbest); fits.append(fbest)\n    for idx, jit in enumerate([0.013,0.017,0.025,0.032,0.040]):\n        xtry, ftry = optimize_once(xbest, seed=100+idx, jitter=jit)\n        xs.append(xtry); fits.append(ftry)\n    ib = int(np.argmax(fits))\n    xopt = xs[ib]\n    centers = xopt[:2*n].reshape(n,2)\n    radii   = xopt[2*n:]\n\n    # Improved greedy inflation: bisection search for each circle for highest valid radius\n    def can_place_radius(i, r_new, centers, radii, n):\n        x_i, y_i = centers[i]\n        # boundary\n        if x_i - r_new < 0 or x_i + r_new > 1: return False\n        if y_i - r_new < 0 or y_i + r_new > 1: return False\n        for j in range(n):\n            if i == j: continue\n            d = np.hypot(x_i - centers[j,0], y_i - centers[j,1])\n            if d < (r_new + radii[j] + 1e-7):\n                return False\n        return True\n\n    def inflate_bisect(centers, radii, iterations=6, eps=1e-8):\n        n = len(radii)\n        order = np.arange(n)\n        # Take a copy so we don't mutate input\n        radii = radii.copy()\n        for _ in range(iterations):\n            np.random.shuffle(order)\n            for i in order:\n                # Compute largest possible radius for circle i\n                x_i, y_i = centers[i]\n                # Upper bound = min distance to any boundary or neighbor\n                bd_max = min(x_i, 1-x_i, y_i, 1-y_i)\n                nb_max = bd_max\n                for j in range(n):\n                    if i == j: continue\n                    d = np.hypot(x_i-centers[j,0], y_i-centers[j,1]) - radii[j]\n                    if d < nb_max:\n                        nb_max = d\n                r_lo = radii[i]\n                # Exclude negative or zero\n                r_hi = max(nb_max-eps, r_lo+1e-7)\n                # Bisection search\n                for _ in range(20):\n                    r_m = 0.5",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 45,
    "parent_id": 8,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Improved: 26 circles in square - add 4 near-corner circles,\n    adjust outer ring, more aggressive initial radii.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Inner ring of 8\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [\n            0.5 + 0.25 * np.cos(angle),\n            0.5 + 0.25 * np.sin(angle)\n        ]\n    \n    # Outer ring of 12 (reduce from 16 to 12 to allow corners)\n    for i in range(12):\n        angle = 2 * np.pi * i / 12\n        centers[i + 9] = [\n            0.5 + 0.37 * np.cos(angle),\n            0.5 + 0.37 * np.sin(angle)\n        ]\n    \n    # Four \"corner\" circles closer to actual corners\n    corner_shifts = [ (0.15, 0.15), (0.85, 0.15), (0.85, 0.85), (0.15, 0.85) ]\n    for idx, (x, y) in enumerate(corner_shifts):\n        centers[21 + idx] = [x, y]\n    \n    # One extra circle near top center\n    centers[25] = [0.5, 0.93]\n    \n    # Start with larger radii for initial guess\n    radii = np.full(n, 0.11)\n    \n    # More shrink passes for better packing (from 8 to 12)\n    num_passes = 12\n    for _ in range(num_passes):\n        # Border constraint\n        for i in range(n):\n            x, y = centers[i]\n            max_r_border = min(x, y, 1 - x, 1 - y)\n            if radii[i] > max_r_border:\n                radii[i] = max_r_border\n\n        # Pairwise overlap constraint\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if dist < 1e-12: # protect pathological case\n                    scale = 0.5\n                else:\n                    scale = min(1.0, (dist * 0.99) / (radii[i] + radii[j]))\n                if scale < 1.0:\n                    r_sum = radii[i] + radii[j]\n                    if r_sum > 0:\n                        ratio_i = radii[i] / r_sum\n                        ratio_j = radii[j] / r_sum\n                        # shrink both radii proportionally\n                        radii[i] = ratio_i * dist * 0.99\n                        radii[j] = ratio_j * dist * 0.99\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.729295458178224,
      "additional_data": {
        "sum_radii": "1.729295",
        "target_ratio": "0.656279",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 46,
    "parent_id": 20,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Initial guess: hexagonal-ish grid, jittered\n    rows = 5\n    cols = 6\n    x_grid = np.linspace(0.12, 0.88, cols)\n    y_grid = np.linspace(0.12, 0.88, rows)\n    xv, yv = np.meshgrid(x_grid, y_grid)\n    xy = np.column_stack([xv.ravel(), yv.ravel()])\n    # Select 26 points (grid gives 30, pick closest 26 to center)\n    dists = np.linalg.norm(xy - 0.5, axis=1)\n    idxs = np.argsort(dists)[:n]\n    centers_init = xy[idxs]\n    # Add random small perturbations\n    centers_init += (np.random.rand(n,2)-0.5)*0.07\n\n    # Initial radii: all small\n    radii_init = np.full(n, 0.12)\n\n    # Flatten variables: [x0,y0, x1,y1, ..., xn-1,yn-1, r0, r1, ..., rn-1]\n    x0 = np.concatenate([centers_init.ravel(), radii_init])\n\n    # Constraints:\n    cons = []\n\n    # Boundary constraints: all circles within unit square\n    for i in range(n):\n        def cons_xi(x, i=i):\n            return x[2*i] - x[n*2 + i]   # x_i - r_i >= 0\n        cons.append({'type': 'ineq', 'fun': cons_xi})\n        def cons_xi2(x, i=i):\n            return 1. - (x[2*i] + x[n*2 + i])  # 1 - (x_i + r_i) >= 0\n        cons.append({'type': 'ineq', 'fun': cons_xi2})\n        def cons_yi(x, i=i):\n            return x[2*i+1] - x[n*2 + i]       # y_i - r_i >= 0\n        cons.append({'type': 'ineq', 'fun': cons_yi})\n        def cons_yi2(x, i=i):\n            return 1. - (x[2*i+1] + x[n*2 + i])# 1 - (y_i + r_i) >= 0\n        cons.append({'type': 'ineq', 'fun': cons_yi2})\n\n    # Non-overlapping constraints\n    for i in range(n):\n        for j in range(i+1, n):\n            def cons_sep(x, i=i, j=j):\n                xi = x[2*i]\n                yi = x[2*i+1]\n                xj = x[2*j]\n                yj = x[2*j+1]\n                ri = x[n*2 + i]\n                rj = x[n*2 + j]\n                center_dist_sq = (xi-xj)**2 + (yi-yj)**2\n                min_dist = ri + rj\n                # (distance between centers) - (sum of radii) >= 0\n                return (center_dist_sq - (min_dist**2))\n            cons.append({'type': 'ineq', 'fun': cons_sep})\n\n    # Radii must be >= small positive threshold (not degenerate), but solver works better if lower bound is set in bounds\n    bounds = []\n    for i in range(n):\n        # center x\n        bounds.append((0.0,1.0))\n        # center y\n        bounds.append((0.0,1.0))\n    for i in range(n):\n        bounds.append((0.002, 0.25)) # reasonable radii range\n\n    # Objective: maximize sum of radii\n    def obj(x):\n        return -np.sum(x[n*2:])\n\n    options = dict(maxiter=500, disp=False)\n\n    res = minimize(obj, x0, method='SLSQP', bounds=bounds, constraints=cons, options=options)\n\n    if not res.success:\n        # Fallback to original\n        centers = centers_init\n        radii = radii_init\n    else:\n        x_opt = res.x\n        centers = x_opt[:n*2].reshape(n,2)\n        radii = x_opt[n*2:]\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.593297812463398,
      "additional_data": {
        "sum_radii": "2.593298",
        "target_ratio": "0.984174",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 47,
    "parent_id": 41,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    np.random.seed(12345)\n    n = 26\n    # Base ring arrangement: 1 center, ring of 8, ring of 17\n    centers0 = np.zeros((n, 2))\n    centers0[0] = [0.5, 0.5]\n    r1 = 0.25\n    for j in range(8):\n        ang = 2 * np.pi * j / 8\n        centers0[1 + j] = [0.5 + r1 * np.cos(ang), 0.5 + r1 * np.sin(ang)]\n    r2 = 0.45\n    for k in range(17):\n        ang = 2 * np.pi * k / 17\n        centers0[9 + k] = [0.5 + r2 * np.cos(ang), 0.5 + r2 * np.sin(ang)]\n\n    def adjust_radii(centers):\n        # Greedy radius adjustment: shrink for conflicts, then expand\n        radii = np.full(n, 0.05)\n        num_passes = 25\n        shrink_factor = 0.995\n        for _ in range(num_passes):\n            # enforce border\n            for i in range(n):\n                x, y = centers[i]\n                rb = min(x, y, 1 - x, 1 - y)\n                if radii[i] > rb:\n                    radii[i] = rb\n            # enforce pairwise\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d = np.linalg.norm(centers[i] - centers[j])\n                    if d < 1e-12:\n                        continue\n                    overlap = radii[i] + radii[j] - d\n                    if overlap > 0:\n                        scale = (d * shrink_factor) / (radii[i] + radii[j])\n                        radii[i] *= scale\n                        radii[j] *= scale\n        # greedy expansion by descending size\n        for idx in np.argsort(-radii):\n            x, y = centers[idx]\n            maxr = min(x, y, 1 - x, 1 - y)\n            for j in range(n):\n                if j == idx: continue\n                d = np.linalg.norm(centers[idx] - centers[j]) - radii[j]\n                if d < maxr:\n                    maxr = d\n            if maxr > 0:\n                radii[idx] = maxr\n        # one more pass expanding smallest\n        for idx in np.argsort(radii):\n            x, y = centers[idx]\n            maxr = min(x, y, 1 - x, 1 - y)\n            for j in range(n):\n                if j == idx: continue\n                d = np.linalg.norm(centers[idx] - centers[j]) - radii[j]\n                if d < maxr:\n                    maxr = d\n            if maxr > 0:\n                radii[idx] = maxr\n        return radii\n\n    best_sum = 0.0\n    best_centers = centers0.copy()\n    best_radii = np.full(n, 0.0)\n\n    # Multi-start perturbation\n    for t in range(60):\n        # small random jitter to escape plateaus\n        jitter = np.random.normal(scale=0.01, size=(n, 2))\n        centers = centers0 + jitter\n        centers = np.clip(centers, 0.0, 1.0)\n        radii = adjust_radii(centers)\n        s = radii.sum()\n        if s > best_sum:\n            best_sum = s\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n\n    return best_centers, best_radii, best_sum\n",
    "evaluation": {
      "fitness": 2.0676209722637418,
      "additional_data": {
        "sum_radii": "2.067621",
        "target_ratio": "0.784676",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 48,
    "parent_id": 22,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement on previous solution:\n    - Slightly \"loosen\" pairwise shrink factor for gentler fits.\n    - Reduce outer ring radius for more even crowding.\n    - Adjust position/radius of the 26th circle to not force excessive shrinkage elsewhere.\n    - More passes for finer equilibrium.\n    - Average shrink in overlaps to break symmetry.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles\n    inner_ring_r = 0.255  # slightly increased, allows slight 'push'\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Outer ring of 16 circles\n    outer_ring_r = 0.382  # smaller than prev 0.40, relieves border crowding\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # One additional circle: try placing it near the least crowded edge\n    # (choose bottom edge, horizontally centered)\n    # You could check space, but let's try a compromise value\n    corner_idx = 25\n    corner_pos = [0.5, 0.09]  # horizontally centered at bottom\n    centers[corner_idx] = corner_pos\n\n    # Initial radii: slightly increased, expect shrinkage\n    radii = np.ones(n) * 0.071\n    radii[0] = 0.084  # center bigger\n    for i in range(1, 9):\n        radii[i] = 0.074  # inner ring\n    for i in range(9, 25):\n        radii[i] = 0.067  # outer ring smaller\n    radii[corner_idx] = 0.072  # edge circle medium size\n\n    # First pass: border limits\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    # Iterative passes\n    passes = 12  # more passes for better relaxation\n    for _ in range(passes):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = centers[i] - centers[j]\n                d = np.hypot(dx, dy)\n                if d < 1e-12:\n                    s = 0.5\n                else:\n                    s = min(1.0, (d * 0.9925) / (radii[i] + radii[j]))  # gentler shrink\n                if s < 1.0:\n                    # Average shrink to break symmetry\n                    if radii[i] < radii[j]:\n                        radii[i] *= s ** 0.55\n                        radii[j] *= s ** 0.45\n                    else:\n                        radii[j] *= s ** 0.55\n                        radii[i] *= s ** 0.45\n        # Border constraint after each pass\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    # Final cleanup pass\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.6005217155617666,
      "additional_data": {
        "sum_radii": "1.600522",
        "target_ratio": "0.607409",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 49,
    "parent_id": 48,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    np.random.seed(0)\n    n = 26\n    centers = []\n    radii = []\n    # Greedy insert: at each step, sample points and place the largest possible circle\n    for _ in range(n):\n        best_r = 0.0\n        best_xy = (0.5, 0.5)\n        # Sample a batch of candidates\n        pts = np.random.rand(5000, 2)\n        for x, y in pts:\n            # max radius by boundaries\n            r = min(x, 1 - x, y, 1 - y)\n            # shrink by existing circles\n            for (xi, yi), ri in zip(centers, radii):\n                d = np.hypot(x - xi, y - yi) - ri\n                if d < r:\n                    r = d\n                    if r <= best_r:\n                        break\n            if r > best_r:\n                best_r = r\n                best_xy = (x, y)\n        centers.append(best_xy)\n        radii.append(best_r if best_r > 0 else 1e-6)\n\n    centers = np.array(centers)\n    radii = np.array(radii)\n\n    # Local hill-climb: random tweaks to a single circle, accept if sum(radii) increases\n    for _ in range(2000):\n        i = np.random.randint(n)\n        old_x, old_y = centers[i]\n        old_r = radii[i]\n        # propose small shift and radius change\n        dx, dy = (np.random.rand(2) - 0.5) * 0.04\n        new_x = np.clip(old_x + dx, 0, 1)\n        new_y = np.clip(old_y + dy, 0, 1)\n        # propose small scale\n        scale = 1.0 + (np.random.rand() - 0.5) * 0.1\n        new_r = old_r * scale\n        # boundary constraint\n        new_r = min(new_r, new_x, 1 - new_x, new_y, 1 - new_y)\n        if new_r <= 0:\n            continue\n        # neighbor constraints\n        for j in range(n):\n            if j == i:\n                continue\n            cjx, cjy = centers[j]\n            rj = radii[j]\n            d = np.hypot(new_x - cjx, new_y - cjy) - rj\n            if d < new_r:\n                new_r = d\n                if new_r <= 0:\n                    break\n        if new_r <= 0:\n            continue\n        # accept if improves\n        old_sum = radii.sum()\n        radii[i] = new_r\n        centers[i] = [new_x, new_y]\n        if radii.sum() < old_sum:\n            # revert\n            radii[i] = old_r\n            centers[i] = [old_x, old_y]\n\n    sum_radii = radii.sum()\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.440214032154356,
      "additional_data": {
        "sum_radii": "1.440214",
        "target_ratio": "0.546571",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 50,
    "parent_id": 36,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    np.random.seed(1337)\n    n_circ = 26\n    square_size = 1.0\n\n    def circle_valid(xy, r, centers, radii):\n        # Returns True if circle at xy,r is non-overlapping with others and inside [0,1]^2\n        if r < 1e-5 or xy[0] - r < 0 or xy[1] - r < 0 or xy[0] + r > 1 or xy[1] + r > 1:\n            return False\n        if len(centers) == 0: return True\n        d = np.linalg.norm(centers - xy, axis=1)\n        return np.all(d >= radii + r - 1e-10)\n\n    def maximal_radius_at(xy, centers, radii):\n        # For a point within the square, get largest radius without overlap\n        dist_bnds = [xy[0], 1-xy[0], xy[1], 1-xy[1]]\n        r_bnd = min(dist_bnds)\n        if len(centers) == 0:\n            return r_bnd\n        dists = np.linalg.norm(centers - xy, axis=1) - radii\n        r = min(r_bnd, np.min(dists))\n        return max(r, 0.)\n\n    # ---- Step 1: Seed boundary/anchor circles in corners and sides ----\n    anchor_pos = [\n        (0,0), (1,0), (1,1), (0,1),         # corners\n        (0.5,0), (1,0.5), (0.5,1), (0,0.5), # edge midpoints\n        (0.25,0), (0.75,0), (1,0.25), (1,0.75), (0.75,1), (0.25,1), (0,0.75), (0,0.25) # quarter edge points\n    ]\n    # We'll take only as many as we want (say, 8\u201316), rest will be greedy\n    seed_N = 12 # <= n_circ\n    anchor_pos = np.array(anchor_pos[:seed_N])\n    # Compute max possible radii for the anchor points\n    r_seed = []\n    for xy in anchor_pos:\n        r = maximal_radius_at(xy, np.empty((0,2)), np.empty((0,)))\n        # discount a tiny bit to avoid touching walls\n        r *= 0.98\n        r_seed.append(r)\n    centers = anchor_pos.copy()\n    radii = np.array(r_seed)\n\n    # ---- Step 2: Add circles incrementally in largest voids ----\n    samples_per_circle = 3200\n    for _ in range(n_circ-seed_N):\n        # Sample lots of candidate positions for the next circle\n        cands_xy = np.random.rand(samples_per_circle,2) * (1 - 0.04) + 0.02\n        cands_r = np.array([\n            maximal_radius_at(xy, centers, radii) for xy in cands_xy\n        ])\n        # Sometimes, all radius are near zero so reject low r\n        if np.max(cands_r) < 1e-3:\n            # Can't pack more\n            break\n        # Get the best candidates\n        idx = np.argsort(-cands_r)[:4]\n        best_r = cands_r[idx[0]]\n        best_xy = cands_xy[idx[0]]\n        # try a local \"hillclimbing\" for each of these best ones\n        def obj_local(x):\n            # x = [x, y], maximize possible radius\n            return -maximal_radius_at(x, centers, radii)\n        opt = minimize(obj_local, best_xy, bounds=[(0,1),(0,1)], method='L-BFGS-B')\n        new_xy = opt.x\n        new_r = maximal_radius_at(new_xy, centers, radii)\n        if new_r < 1e-4:\n            continue\n        centers = np.vstack([centers, new_xy])\n        radii   = np.append(radii, new_r * 0.99) # small margin\n\n    # ---- Step 3: Joint global optimization (all circles at once) ----\n    n = centers.shape[0]\n    # n might be < n_circ due to impossibility; ensure output is 26 by adding tiny circles\n    if n < n_circ:\n        extra_centers = np.random.rand(n_circ-n,2)*0.8 + 0.1\n        extra_radii = np.full(n_circ-n, 0.009)\n        centers = np.vstack([centers, extra_centers])\n        radii   = np.append(radii, extra_radii)\n    else:\n        centers = centers[:n_circ]\n        radii   = radii[:n_circ]\n    n = n_circ\n\n    x0 = np.concatenate([centers.reshape(-1), radii])\n    bounds = []\n    for i in range(n):\n        bounds.extend([[0.0, 1.0], [0.0, 1.0]])\n    for i in range(n):\n        bounds.append([0.006, 0.16]) # radii bounds\n\n    def cons_fun(x):\n        cons = []\n        # inside square\n        for i in range(n):\n            xi, yi = x[2",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 51,
    "parent_id": 47,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    np.random.seed(12345)\n    n = 26\n    # Improved: 1 center, ring of 8, ring of 17 (outermost just fitting inside unit square)\n    centers0 = np.zeros((n, 2))\n    centers0[0] = [0.5, 0.5]\n    r1 = 0.254  # Slightly bigger inner ring\n    for j in range(8):\n        ang = 2 * np.pi * j / 8\n        centers0[1 + j] = [0.5 + r1 * np.cos(ang), 0.5 + r1 * np.sin(ang)]\n    # Place 17 on a slightly larger outer ring\n    r2 = 0.454  # closer to the maximal possible to fit in corners\n    for k in range(17):\n        ang = 2 * np.pi * k / 17\n        # Edge nudge: nudge corner ones towards extreme edge\n        edge_nudge = 0.01 if (np.abs(np.cos(ang)) > 0.95 or np.abs(np.sin(ang)) > 0.95) else 0.0\n        centers0[9 + k] = [\n            0.5 + (r2 + edge_nudge) * np.cos(ang),\n            0.5 + (r2 + edge_nudge) * np.sin(ang)\n        ]\n\n    def adjust_radii(centers):\n        radii = np.full(n, 0.048)\n        num_passes = 30\n        shrink_factor = 0.993\n        for _ in range(num_passes):\n            # enforce border\n            for i in range(n):\n                x, y = centers[i]\n                rb = min(x, y, 1 - x, 1 - y)\n                if radii[i] > rb:\n                    radii[i] = rb\n            # enforce pairwise\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d = np.linalg.norm(centers[i] - centers[j])\n                    if d < 1e-12:\n                        continue\n                    overlap = radii[i] + radii[j] - d\n                    if overlap > 0:\n                        scale = (d * shrink_factor) / (radii[i] + radii[j])\n                        radii[i] *= scale\n                        radii[j] *= scale\n        # Greedy expansion by descending size; do multiple passes\n        for _ in range(3):\n            for idx in np.argsort(-radii):\n                x, y = centers[idx]\n                maxr = min(x, y, 1 - x, 1 - y)\n                for j in range(n):\n                    if j == idx: continue\n                    d = np.linalg.norm(centers[idx] - centers[j]) - radii[j]\n                    if d < maxr:\n                        maxr = d\n                if maxr > 0:\n                    radii[idx] = maxr\n        # expand smallest several more passes\n        for _ in range(2):\n            for idx in np.argsort(radii):\n                x, y = centers[idx]\n                maxr = min(x, y, 1 - x, 1 - y)\n                for j in range(n):\n                    if j == idx: continue\n                    d = np.linalg.norm(centers[idx] - centers[j]) - radii[j]\n                    if d < maxr:\n                        maxr = d\n                if maxr > 0:\n                    radii[idx] = maxr\n        return radii\n\n    best_sum = 0.0\n    best_centers = centers0.copy()\n    best_radii = np.full(n, 0.0)\n\n    # Multi-start perturbation with more trials and slightly increased jitter\n    for t in range(100):\n        jitter = np.random.normal(scale=0.014, size=(n, 2))\n        centers = centers0 + jitter\n        centers = np.clip(centers, 0.0, 1.0)\n        radii = adjust_radii(centers)\n        s = radii.sum()\n        if s > best_sum:\n            best_sum = s\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n\n    return best_centers, best_radii, best_sum\n",
    "evaluation": {
      "fitness": 1.9939305231156945,
      "additional_data": {
        "sum_radii": "1.993931",
        "target_ratio": "0.756710",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 52,
    "parent_id": 36,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    def alt_hex_coords(num, r_min=0.0385):\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx%2 else 0) + (max(rows)-nrow)/2*dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    r0 = 0.0365\n    r_min_grid = r0 + 0.0025\n    centers0 = alt_hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    cons = []\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},            # x - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},       # 1 - x - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},            # y - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},        # 1 - y - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.008},               # r >= 0.008\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.16 - x[2*n+i]},                # r <= 0.16\n        ]\n    # non-overlap (smaller epsilon)\n    epsilon = 5e-6\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + epsilon)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n)-0.5) * jitter\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':3e-10, 'maxiter':6000, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    # Try more multi-starts with broader jitters\n    xs, fits = [], []\n    jitters = [0.011,0.012,0.013,0.017,0.018,0.021,0.025,0.030,0.033,0.040,0.049]\n    xbest, fbest = optimize_once(x0, seed=None, jitter=0.0)\n    xs.append(xbest); fits.append(fbest)\n    for idx, jit in enumerate(jitters):\n        xtry, ftry = optimize_once(xbest, seed=127+idx, jitter=jit)\n        xs.append(xtry); fits.append(ftry)\n    ib = int(np.argmax(fits))\n    xopt = xs[ib]\n    centers = xopt[:2*n].reshape(n,2)\n    radii   = xopt[2*n:]\n\n    # Improved greedy inflation with more iterations, decaying epsilon\n    def inflate(centers, radii, outer_iter=16, eps0=1e-5, fine_iter=3):\n        n = len(radii)\n        centers = centers.copy()\n        radii   = radii.copy()\n        for it in range(outer_iter):\n            eps = eps0 * (0.6**it)\n            for i in range(n):\n                x_i, y_i = centers[i]\n                # boundary slack\n                r_max = min(x_i, 1-x_i, y_i, 1-y_i)\n                # neighbor slack\n                for j in range(n):\n                    if i == j: continue\n                    d = np.hypot(x_i-centers[j,0], y_i-centers[j,1]) - radii[j]\n                    if d < r_max:\n                        r_max = d\n                # Don't reduce a circle's radius;\n                if r_max - eps > radii[i]:\n                    radii[i] = r_max - eps\n        # Final very fine pass\n        for _ in range(fine_iter):\n            for i in range(n):\n                x_i, y_i = centers[i]\n                r_max = min(x_i, 1-x_i, y_i, 1-y_i)\n                for j in range(n):\n                    if i == j: continue\n                    d = np.hypot(x_i-centers[j,0], y_i-centers[j,1]) - radii[j]\n                    if d < r_max:\n                        r_max = d\n                if r_max - 2e-7 > radii[i]:\n                    radi",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 53,
    "parent_id": 48,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - Increase relaxation passes from 12 to 18 for finer convergence.\n    - Outer ring slightly farther out for better edge use.\n    - Edge (26th) circle now at [0.72, 0.075] to fill an underused region (more asymmetric).\n    - More varied initial radii: slightly bigger center, slightly smaller inner / larger outer, bonus edge circle moderate.\n    - Slightly more aggressive shrinkage in overlap (0.991, up from 0.9925).\n    - Post-processing min radius check to avoid collapse in rare cases.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles\n    inner_ring_r = 0.240  # a touch closer in for more outer space\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Outer ring of 16 circles\n    outer_ring_r = 0.387  # pushed slightly outward\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # One additional circle: try placing at [0.72, 0.075] (off-center bottom edge)\n    corner_idx = 25\n    corner_pos = [0.72, 0.075]\n    centers[corner_idx] = corner_pos\n\n    # Initial radii: more variation\n    radii = np.ones(n) * 0.069\n    radii[0] = 0.087   # center\n    for i in range(1, 9):\n        radii[i] = 0.070   # inner ring\n    for i in range(9, 25):\n        radii[i] = 0.064   # outer ring, slightly smaller\n    radii[corner_idx] = 0.071  # corner circle\n\n    # Border constraining\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    # More passes for better equilibrium\n    passes = 18\n    for _ in range(passes):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = centers[i] - centers[j]\n                d = np.hypot(dx, dy)\n                if d < 1e-12:\n                    s = 0.5\n                else:\n                    s = min(1.0, (d * 0.991) / (radii[i] + radii[j]))  # slightly more aggressive\n                if s < 1.0:\n                    # Rotate shrink exponents for asymmetry\n                    if i % 2 == 0:\n                        radii[i] *= s ** 0.54\n                        radii[j] *= s ** 0.46\n                    else:\n                        radii[j] *= s ** 0.54\n                        radii[i] *= s ** 0.46\n        # Border constraint each pass\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n            # Prevent numerical collapse\n            radii[i] = max(radii[i], 1e-6)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.7047053614264187,
      "additional_data": {
        "sum_radii": "1.704705",
        "target_ratio": "0.646947",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 54,
    "parent_id": 51,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    np.random.seed(12345)\n    n = 26\n    centers0 = np.zeros((n, 2))\n    # 1 center, 8 inner, 16 outer, 1 explicit corner at (0,0)\n    centers0[0] = [0.5, 0.5]\n    r1 = 0.240\n    for j in range(8):\n        ang = 2 * np.pi * j / 8\n        centers0[1 + j] = [0.5 + r1 * np.cos(ang), 0.5 + r1 * np.sin(ang)]\n    r2 = 0.454\n    for k in range(16):\n        ang = 2 * np.pi * k / 16\n        edge_nudge = 0.019 if (np.abs(np.cos(ang)) > 0.94 or np.abs(np.sin(ang)) > 0.94) else 0.0\n        centers0[9 + k] = [\n            0.5 + (r2 + edge_nudge) * np.cos(ang),\n            0.5 + (r2 + edge_nudge) * np.sin(ang)\n        ]\n    # place a circle directly in the lower left corner\n    centers0[-1] = [0.04, 0.04]  # small offset so it fits entirely in square\n\n    def adjust_radii(centers):\n        radii = np.full(n, 0.046)\n        num_passes = 33\n        shrink_factor = 0.995\n        for _ in range(num_passes):\n            # enforce border\n            for i in range(n):\n                x, y = centers[i]\n                rb = min(x, y, 1 - x, 1 - y)\n                if radii[i] > rb:\n                    radii[i] = rb\n            # enforce pairwise\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d = np.linalg.norm(centers[i] - centers[j])\n                    if d < 1e-12:\n                        continue\n                    overlap = radii[i] + radii[j] - d\n                    if overlap > 0:\n                        scale = (d * shrink_factor) / (radii[i] + radii[j])\n                        radii[i] *= scale\n                        radii[j] *= scale\n        # Greedy expansion by descending size; do more passes\n        for _ in range(5):\n            for idx in np.argsort(-radii):\n                x, y = centers[idx]\n                maxr = min(x, y, 1 - x, 1 - y)\n                for j in range(n):\n                    if j == idx: continue\n                    d = np.linalg.norm(centers[idx] - centers[j]) - radii[j]\n                    if d < maxr:\n                        maxr = d\n                if maxr > 0:\n                    radii[idx] = maxr\n        # expand smallest several more passes\n        for _ in range(4):\n            for idx in np.argsort(radii):\n                x, y = centers[idx]\n                maxr = min(x, y, 1 - x, 1 - y)\n                for j in range(n):\n                    if j == idx: continue\n                    d = np.linalg.norm(centers[idx] - centers[j]) - radii[j]\n                    if d < maxr:\n                        maxr = d\n                if maxr > 0:\n                    radii[idx] = maxr\n        return radii\n\n    best_sum = 0.0\n    best_centers = centers0.copy()\n    best_radii = np.full(n, 0.0)\n\n    for t in range(200):\n        jitter = np.random.normal(scale=0.012, size=(n, 2))\n        centers = centers0 + jitter\n        centers = np.clip(centers, 0.0, 1.0)\n        # always put last circle back into \"corner\" so it doesn't jitter out of bounds\n        centers[-1] = [0.04, 0.04]\n        radii = adjust_radii(centers)\n        s = radii.sum()\n        if s > best_sum:\n            best_sum = s\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n\n    return best_centers, best_radii, best_sum\n",
    "evaluation": {
      "fitness": 1.962131441704261,
      "additional_data": {
        "sum_radii": "1.962131",
        "target_ratio": "0.744642",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 55,
    "parent_id": 6,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import basinhopping, minimize\n\ndef run_packing():\n    n = 26\n\n    # initial hex-like seed\n    def hex_coords(num, r_min=0.032):\n        rows = [4,6,6,6,4]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows) - 1)\n        dy = (1 - 2*r_min) / (len(rows) - 1)\n        y = r_min\n        for nrow in rows:\n            offset = (max(rows) - nrow) / 2 * dx\n            for j in range(nrow):\n                coords.append([r_min + offset + j*dx, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    centers0 = hex_coords(n)\n    np.random.seed(42)\n    centers0 += (np.random.rand(n,2) - 0.5) * 0.08\n    radii0 = np.full(n, 0.032)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    # bounds for x,y in [0,1], radii in [0.005,0.2]\n    bounds = [(0,1)]*(2*n) + [(0.005,0.2)]*n\n\n    # penalized objective: maximize sum(r) minus heavy penalty for overlaps/outside\n    def obj(x):\n        c = x[:2*n].reshape(n,2)\n        r = x[2*n:]\n        sumr = np.sum(r)\n        # outside-square penalty\n        dxl = r - c[:,0]; dxh = c[:,0] + r - 1\n        dyl = r - c[:,1]; dyh = c[:,1] + r - 1\n        pen = np.sum(np.clip(dxl,0,None)**2 + np.clip(dxh,0,None)**2 +\n                     np.clip(dyl,0,None)**2 + np.clip(dyh,0,None)**2)\n        # overlap penalty\n        XX = c[:,0][:,None] - c[:,0][None,:]\n        YY = c[:,1][:,None] - c[:,1][None,:]\n        D = np.sqrt(XX**2 + YY**2)\n        Rsum = r[:,None] + r[None,:]\n        mask = (Rsum > D)\n        pen += np.sum((Rsum[mask] - D[mask])**2) * 0.5\n        return -sumr + 1e4 * pen\n\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"bounds\": bounds,\n        \"options\": {\"ftol\":1e-5, \"maxiter\":500}\n    }\n\n    # global search with basinhopping to escape local minima\n    bh = basinhopping(obj, x0,\n                      minimizer_kwargs=minimizer_kwargs,\n                      niter=20, T=1.0, stepsize=0.03,\n                      disp=False)\n    x_best = bh.x\n\n    # final local polish with SLSQP under explicit constraints\n    cons = []\n    slack = 1e-8\n    # boundary constraints\n    for i in range(n):\n        cons += [\n            {'type':'ineq', 'fun': lambda x,i=i: x[2*n + i] - x[2*i]},\n            {'type':'ineq', 'fun': lambda x,i=i: 1 - x[2*i] - x[2*n + i]},\n            {'type':'ineq', 'fun': lambda x,i=i: x[2*i+1] - x[2*n + i]},\n            {'type':'ineq', 'fun': lambda x,i=i: 1 - x[2*i+1] - x[2*n + i]}\n        ]\n    # non-overlap constraints\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type':'ineq',\n                'fun': lambda x,i=i,j=j: np.hypot(\n                    x[2*i] - x[2*j], x[2*i+1] - x[2*j+1]\n                ) - (x[2*n+i] + x[2*n+j] + slack)\n            })\n\n    def obj2(x):\n        return -np.sum(x[2*n:])\n    res2 = minimize(obj2, x_best, method='SLSQP',\n                    constraints=cons,\n                    options={'ftol':1e-8, 'maxiter':500})\n    x_final = res2.x if res2.success else x_best\n\n    centers = x_final[:2*n].reshape((n,2))\n    radii = x_final[2*n:]\n    sum_radii = float(np.sum(radii))\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "invalid",
        "error": "Invalid packing (overlaps or out of bounds)"
      }
    }
  },
  {
    "id": 56,
    "parent_id": 48,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles\n    inner_ring_r = 0.26\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Outer ring of 16 circles\n    outer_ring_r = 0.39\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # One additional circle near bottom edge\n    corner_idx = 25\n    centers[corner_idx] = [0.5, 0.085]\n\n    # Initial radii\n    radii = np.ones(n) * 0.073\n    radii[0] = 0.086\n    radii[1:9] = 0.076\n    radii[9:25] = 0.070\n    radii[corner_idx] = 0.074\n\n    # Enforce border constraints initially\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    # Iterative shrink-relax passes\n    passes = 16\n    for _ in range(passes):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = centers[i] - centers[j]\n                d = np.hypot(dx, dy)\n                if d < 1e-12:\n                    s = 0.5\n                else:\n                    s = min(1.0, (d * 0.995) / (radii[i] + radii[j]))\n                if s < 1.0:\n                    if radii[i] < radii[j]:\n                        radii[i] *= s ** 0.53\n                        radii[j] *= s ** 0.47\n                    else:\n                        radii[j] *= s ** 0.53\n                        radii[i] *= s ** 0.47\n        # Border constraint after each pass\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    # Final border cleanup\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    # Greedy local enlargement\n    for _ in range(2):\n        for i in range(n):\n            xi, yi = centers[i]\n            max_r = min(xi, yi, 1 - xi, 1 - yi)\n            for j in range(n):\n                if j == i: continue\n                dx, dy = xi - centers[j,0], yi - centers[j,1]\n                dij = np.hypot(dx, dy)\n                max_r = min(max_r, dij - radii[j])\n            if max_r > radii[i]:\n                radii[i] = max_r\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.9199871222058276,
      "additional_data": {
        "sum_radii": "1.919987",
        "target_ratio": "0.728648",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 57,
    "parent_id": 43,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small improvements: move wedge, adjust ring radius, modify jitter, expand relaxation passes.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # First ring of 8 circles\n    r1 = 0.275\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + r1 * np.cos(angle), 0.5 + r1 * np.sin(angle)]\n    \n    # Second ring of 16, pushed closer to the border\n    r2 = 0.468\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        # Slightly modify jitter to fill convex areas better\n        jitter = 0.014 * np.array([np.sin(angle*2.9 + 0.4), np.cos(angle*2.5 - 0.7)])\n        centers[i + 9] = [0.5 + r2 * np.cos(angle), 0.5 + r2 * np.sin(angle)]\n        centers[i + 9] += jitter\n\n    # Move the wedge circle closer to the bottom-left corner\n    centers[25] = [0.12, 0.12]\n\n    # Slightly larger initial radii\n    radii = np.full(n, 0.119)\n    \n    # More relaxation passes\n    num_passes = 28\n    for _ in range(num_passes):\n        # Limit by distance to square borders\n        for i in range(n):\n            x, y = centers[i]\n            max_r_border = min(x, y, 1 - x, 1 - y)\n            if radii[i] > max_r_border:\n                radii[i] = max_r_border\n    \n        # Limit by distance to other circles (prevent overlap)\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                eps = 1e-13\n                if dist < eps:\n                    scale = 0.5\n                else:\n                    scale = min(1.0, (dist * 0.994) / (radii[i] + radii[j]) )\n                if scale < 1.0:\n                    r_sum = radii[i] + radii[j]\n                    if r_sum > 0:\n                        ratio_i = radii[i] / r_sum\n                        ratio_j = radii[j] / r_sum\n                        radii[i] = ratio_i * dist * 0.994\n                        radii[j] = ratio_j * dist * 0.994\n\n    # Final expansion, two passes: descending then ascending order\n    sort_order = np.argsort(-radii)\n    for ordering in [sort_order, sort_order[::-1]]:\n        for idx in ordering:\n            max_r = min(centers[idx][0], centers[idx][1], 1-centers[idx][0], 1-centers[idx][1])\n            for j in range(n):\n                if j == idx:\n                    continue\n                dist = np.linalg.norm(centers[idx] - centers[j])\n                if dist - radii[j] < max_r:\n                    max_r = dist - radii[j]\n            max_r = max(max_r, 0.0)\n            radii[idx] = min(radii[idx], max_r)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.9057738835443985,
      "additional_data": {
        "sum_radii": "1.905774",
        "target_ratio": "0.723254",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 58,
    "parent_id": 47,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    np.random.seed(4321)\n    n = 26\n\n    def compute_radii(centers):\n        # initialize radii to border distance\n        radii = np.array([min(x, y, 1 - x, 1 - y) for x, y in centers])\n        # iterative relaxation to remove overlaps\n        for _ in range(80):\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d = np.linalg.norm(centers[i] - centers[j])\n                    if radii[i] + radii[j] > d:\n                        if d > 1e-12:\n                            scale = d / (radii[i] + radii[j])\n                        else:\n                            scale = 0.0\n                        radii[i] *= scale\n                        radii[j] *= scale\n            # enforce border\n            for i in range(n):\n                x, y = centers[i]\n                rb = min(x, y, 1 - x, 1 - y)\n                if radii[i] > rb:\n                    radii[i] = rb\n        # greedy expansion largest-first\n        for idx in np.argsort(-radii):\n            x, y = centers[idx]\n            maxr = min(x, y, 1 - x, 1 - y)\n            for j in range(n):\n                if j == idx: continue\n                d = np.linalg.norm(centers[idx] - centers[j]) - radii[j]\n                if d < maxr:\n                    maxr = d\n            radii[idx] = max(0.0, maxr)\n        return radii\n\n    # build initial seed patterns\n    seeds = []\n    # 1) concentric rings\n    c0 = np.zeros((n, 2))\n    c0[0] = [0.5, 0.5]\n    r1, r2 = 0.2, 0.45\n    for j in range(8):\n        ang = 2 * np.pi * j / 8\n        c0[1 + j] = [0.5 + r1 * np.cos(ang), 0.5 + r1 * np.sin(ang)]\n    for k in range(17):\n        ang = 2 * np.pi * k / 17\n        c0[9 + k] = [0.5 + r2 * np.cos(ang), 0.5 + r2 * np.sin(ang)]\n    seeds.append(np.clip(c0, 0.0, 1.0))\n    # 2) quasi-hex grid\n    gx = np.linspace(0.1, 0.9, 7)\n    gy = np.linspace(0.1, 0.9, 6)\n    grid = []\n    toggle = False\n    for y in gy:\n        row = list(gx + (0.05 if toggle else 0.0))\n        toggle = not toggle\n        for x in row:\n            if len(grid) < n:\n                grid.append([x, y])\n    seeds.append(np.array(grid))\n    # 3) uniform random\n    seeds.append(np.random.rand(n, 2))\n\n    best_sum = 0.0\n    best_centers = None\n    best_radii = None\n\n    # simulated annealing on centers\n    for centers0 in seeds:\n        centers = centers0.copy()\n        radii = compute_radii(centers)\n        curr_sum = radii.sum()\n        if curr_sum > best_sum:\n            best_sum, best_centers, best_radii = curr_sum, centers.copy(), radii.copy()\n\n        T0 = 0.02\n        temp = T0\n        max_steps = 3000\n        for step in range(max_steps):\n            i = np.random.randint(n)\n            old = centers[i].copy()\n            sigma = 0.06 * (1 - step / max_steps)\n            centers[i] += np.random.normal(scale=sigma, size=2)\n            centers[i] = np.clip(centers[i], 0.0, 1.0)\n            new_radii = compute_radii(centers)\n            new_sum = new_radii.sum()\n            delta = new_sum - curr_sum\n            if delta > 0 or np.random.rand() < np.exp(delta / temp):\n                curr_sum = new_sum\n                radii = new_radii\n                if new_sum > best_sum:\n                    best_sum, best_centers, best_radii = new_sum, centers.copy(), radii.copy()\n            else:\n                centers[i] = old\n            temp = T0 * (1 - step / max_steps)\n\n    return best_centers, best_radii, best_sum\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution timed out after 30 seconds"
      }
    }
  },
  {
    "id": 59,
    "parent_id": 22,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef hex_grid(n_rows, n_cols, dx=0.08, dy=0.08, margin=0.03):\n    # Returns an array of center coordinates for a hexagonal grid,\n    # shifted so it fills (0,0)-(1,1) with approximate spacing dx, dy.\n    points = []\n    y = margin\n    while y < 1 - margin:\n        row = []\n        x_off = margin + (0.5 * dx if (len(points) % 2) else 0.0)\n        x = x_off\n        while x < 1 - margin:\n            row.append([x, y])\n            x += dx\n        points.extend(row)\n        y += dy * np.sqrt(3)/2\n    return np.array(points)\n\ndef make_initial_guess():\n    # Arrange 26 points in roughly hex pattern in the square, then nudge in corners\n    grid = hex_grid(6, 6, dx=0.175, dy=0.165, margin=0.05)\n    np.random.shuffle(grid)\n    centers = grid[:26]\n    # Nudge 4 points close to the corners to the corners to fill them\n    for i, corner in enumerate([(0.05,0.05), (0.95,0.05), (0.95,0.95), (0.05,0.95)]):\n        idx = np.argmin(np.linalg.norm(centers - corner, axis=1))\n        centers[idx] = corner\n    # Initial guess: moderate radii -- they will be grown in optimization\n    radii = 0.07 * np.ones(26)\n    return centers, radii\n\ndef pack_objective(z):\n    # Negative sum of radii (maximize sum)\n    radii = z[52:]\n    # Penalty for negative radii\n    penalty = np.sum(np.abs(np.minimum(0, radii))) * 1000\n    return -np.sum(np.maximum(0, radii)) + penalty\n\ndef make_constraints(n):\n    constraints = []\n\n    # Each circle inside square: x-r>=0, x+r<=1, y-r>=0, y+r<=1, r>=0\n    for i in range(n):\n        def left(z, i=i):  # x_i - r_i >= 0\n            return z[2*i] - z[n*2 + i]\n        constraints.append({'type':'ineq', 'fun':left})\n\n        def right(z, i=i):  # x_i + r_i <= 1\n            return 1.0 - (z[2*i] + z[n*2 + i])\n        constraints.append({'type':'ineq', 'fun':right})\n\n        def bot(z, i=i):  # y_i - r_i >= 0\n            return z[2*i+1] - z[n*2 + i]\n        constraints.append({'type':'ineq', 'fun':bot})\n\n        def top(z, i=i):  # y_i + r_i <= 1\n            return 1.0 - (z[2*i+1] + z[n*2 + i])\n        constraints.append({'type':'ineq', 'fun':top})\n\n        def nonneg(z, i=i): # r_i >= 0\n            return z[n*2 + i]\n        constraints.append({'type':'ineq', 'fun':nonneg})\n\n    # No overlaps: for every i<j: dist((x_i, y_i), (x_j, y_j)) >= r_i + r_j\n    for i in range(n):\n        for j in range(i+1, n):\n            def sep(z, i=i, j=j):\n                xi, yi = z[2*i], z[2*i+1]\n                xj, yj = z[2*j], z[2*j+1]\n                ri, rj = z[n*2 + i], z[n*2 + j]\n                return np.sqrt((xi-xj)**2 + (yi-yj)**2) - (ri + rj)\n            constraints.append({'type':'ineq', 'fun':sep})\n\n    return constraints\n\ndef run_packing():\n    n = 26\n    centers0, radii0 = make_initial_guess()\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    constraints = make_constraints(n)\n    bounds = []\n    # x, y: 0 to 1; r: 0 to 0.5 (loose upper bound)\n    for i in range(n):\n        bounds.append((0.0, 1.0)) # x\n        bounds.append((0.0, 1.0)) # y\n    for i in range(n):\n        bounds.append((0.0, 0.5)) # r\n\n    res = minimize(pack_objective, x0, method='SLSQP', constraints=constraints,\n                   bounds=bounds, options={'maxiter': 1000, 'ftol': 1e-7, 'disp': False})\n\n    z = res.x\n    centers = z[:n*2].reshape((n,2))\n    radii = z[n*2:]\n    # Verification: final (hard) clipping to stay in square (in case of small float errors)\n    radii = np.clip(radii, 0, None)\n    for i in range(n):\n        x, y, r = centers[i,0], centers[i,1], radii[i]\n        maxr = min(x, y, 1-x, 1-y)\n        if r > maxr:\n            radii[i] = maxr\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.5928205696646986,
      "additional_data": {
        "sum_radii": "2.592821",
        "target_ratio": "0.983993",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 60,
    "parent_id": 7,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small improvement: Slightly expand outer ring, less conservative collision buffer,\n    initial radii closer to max, more passes, and less aggressive clipping.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Ring of 8 circles (radius 0.25)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n    \n    # Ring of 16 circles (slightly expanded radius)\n    ring2_radius = 0.415  # up from 0.4\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + ring2_radius * np.cos(angle), 0.5 + ring2_radius * np.sin(angle)]\n    \n    # One additional circle: move a bit closer to the upper edge\n    centers[25] = [0.5, 0.87]\n    \n    # Only clip if centers are outside [0.07, 0.93]\n    centers = np.clip(centers, 0.07, 0.93)\n    \n    # Slightly larger starting radii\n    radii = np.ones(n) * 0.057\n    \n    # Limit by distance to square borders\n    max_rad = 0.090  # Increase maximum allowed radius\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y, max_rad)\n    \n    # Less conservative buffer (was 0.95)\n    buffer = 0.96\n    \n    # More passes\n    for _ in range(30):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist * buffer:\n                    scale = (dist * buffer) / (radii[i] + radii[j])\n                    radii[i] *= scale\n                    radii[j] *= scale\n            # Reapply box constraint after adjustment\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y, max_rad)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.8919520432893864,
      "additional_data": {
        "sum_radii": "1.891952",
        "target_ratio": "0.718008",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 61,
    "parent_id": 38,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize, Bounds, NonlinearConstraint\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n\n    def is_feasible(center, radius, centers, radii, min_radius=0.007):\n        x, y = center\n        if (x-radius < 0) or (x+radius > 1) or (y-radius < 0) or (y+radius > 1):\n            return False\n        if radius < min_radius or radius > 0.24:\n            return False\n        if centers.shape[0] == 0:\n            return True\n        dists = np.linalg.norm(centers - center, axis=1)\n        if np.any(dists < (radii + radius - 1e-10)):\n            return False\n        return True\n\n    def max_radius_for_point(point, centers, radii):\n        x, y = point\n        boundary_max = min(x, 1-x, y, 1-y)\n        if centers.shape[0] > 0:\n            dists = np.linalg.norm(centers - point, axis=1) - radii\n            neighbor_max = np.min(dists) if np.all(dists > 0) else 0.0\n            return max(0.0, min(boundary_max, neighbor_max))\n        else:\n            return max(0.0, boundary_max)\n\n    def greedy_sequential_placement(points, n_circles, min_radius=0.0075):\n        centers = []\n        radii = []\n        used = np.zeros(len(points), dtype=bool)\n        for i in range(n_circles):\n            best_r = 0\n            best_p = None\n            best_idx = None\n            for idx, pt in enumerate(points):\n                if used[idx]:\n                    continue\n                r = max_radius_for_point(pt, np.array(centers) if centers else np.zeros((0,2)), np.array(radii) if radii else np.zeros(0))\n                if r > best_r + 1e-10 and r > min_radius:\n                    best_r = r\n                    best_p = pt\n                    best_idx = idx\n            if best_p is not None:\n                centers.append(np.array(best_p))\n                radii.append(best_r)\n                used[best_idx] = True\n            else:\n                # Try random fill for any leftovers\n                trials = 0\n                while trials < 1000:\n                    trial_pt = np.random.uniform(0.0+min_radius, 1.0-min_radius, size=2)\n                    r = max_radius_for_point(trial_pt, np.array(centers), np.array(radii))\n                    if r > min_radius:\n                        centers.append(trial_pt)\n                        radii.append(r)\n                        break\n                    trials += 1\n                else:\n                    break\n        return np.array(centers), np.array(radii)\n\n    def make_candidate_grid(npoints=39, border_points=19, jitter=0.007):\n        ys = np.linspace(0.025,0.975,npoints)\n        xs = np.linspace(0.025,0.975,npoints)\n        points = []\n        rng = np.random.default_rng(12345)\n        for i,y in enumerate(ys):\n            offs = (0.5*(xs[1]-xs[0]) if i%2 else 0.0)\n            for x in xs:\n                x2 = x + offs + rng.uniform(-jitter, jitter)\n                y2 = y + rng.uniform(-jitter, jitter)\n                if x2>=0.017 and x2<=0.983 and y2>=0.017 and y2<=0.983:\n                    points.append((x2,y2))\n        # Denser border grid for edges\n        border_lin = np.linspace(0.008,0.992,border_points)\n        for t in border_lin:\n            points.append((t,0.008))\n            points.append((t,0.992))\n            points.append((0.008,t))\n            points.append((0.992,t))\n        return np.array(points)\n\n    candidate_grid = make_candidate_grid()\n\n    best_total = 0\n    best_centers = None\n    best_radii = None\n    for trial in range(18):\n        shuffled = candidate_grid.copy()\n        np.random.shuffle(shuffled)\n        if trial < 14:\n            use_points = shuffled\n        else:\n            use_points = candidate_grid[np.random.choice(np.arange(len(candidate_grid)), size=95, replace=False)]\n        centers, radii = greedy_sequential_placement(\n            use_points, n,\n            min_radius=0.0080 + 0.0017*np.random.beta(0.6,0.8)\n        )\n        s = np.sum(radii)\n        if len(centers)==n and s > best_total+1e-8:\n            best_total = s\n            best_centers = centers.copy()\n            best_radii = radii.copy()\n\n    # --- NEW: local optimization post-processing ---\n    if best_centers is not None and best_radii is not None:\n        x0 = np.hstack([best_centers.ravel(), best_radii])\n        bounds = []\n        for i in range(n):\n            # Center bounds\n            bounds.append((0,1))\n            bounds.append((0,1))\n        # Radii bounds\n        for i in range(n):\n            bounds.append((max(0.008, best_radii[i]*0.72), min(0.25, best_radii[i]*1.22)))\n\n        bounds = Bounds(*zip(*bounds))\n        # Constraints:\n        def non_overlap(x):\n            arr = []\n            centers = x[:2*n].reshape((n,2))\n            radii = x[2*n:]\n            for i in range(n):\n                xi,yi = centers[i]\n                ri = radii[i]\n                # Stay within square entirely\n                arr.append(xi-ri)\n                arr.append(1-xi-ri)\n                arr.append(yi-ri)\n                arr.append(1-yi-ri)\n            # No overlaps\n            for i in range(n):\n                for j in range(i+1, n):\n                    dx = x[2*i]-x[2*j]\n                    dy = x[2*i+1]-",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 62,
    "parent_id": 26,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n    best_sum = -1\n    best_centers = None\n    best_radii = None\n\n    for trial_seed in [2, 3, 4]:\n        # Improved lattice: denser middle band\n        def hex_lattice_coords(num, r_min=0.038):\n            # Optimized row structure for 26 circles: 4,5,8,5,4\n            rows = [4, 5, 8, 5, 4]\n            coords = []\n            dx = (1 - 2 * r_min) / (max(rows) - 1)\n            dy = (1 - 2 * r_min) / (len(rows) - 1)\n            y = r_min\n            for i, nrow in enumerate(rows):\n                offset = (max(rows) - nrow) / 2 * dx\n                for j in range(nrow):\n                    x = r_min + offset + j * dx\n                    coords.append([x, y])\n                y += dy\n            return np.array(coords)[:num]\n\n        # Start with larger radius for initial attempt (so circles fill more)\n        r0 = 0.038\n\n        # Arrange in hex lattice and add smaller random shake\n        centers0 = hex_lattice_coords(n, r_min=r0)\n        np.random.seed(trial_seed)\n        centers0 += (np.random.rand(n, 2) - 0.5) * 0.04\n\n        # Initial radii\n        radii0 = np.full(n, r0)\n        x0 = np.concatenate([centers0.flatten(), radii0])\n\n        # --- Define constraints ---\n\n        cons = []\n\n        # All circles within bounds: x_i, y_i in [ri, 1-ri]\n        for i in range(n):\n            def makefn_idx(i):\n                return lambda x: x[2*i] - x[2*n+i]\n            cons.append({'type': 'ineq', 'fun': makefn_idx(i)})\n\n            def makefn_idx2(i):\n                return lambda x: 1 - x[2*i] - x[2*n+i]\n            cons.append({'type': 'ineq', 'fun': makefn_idx2(i)})\n\n            def makefn_idy(i):\n                return lambda x: x[2*i+1] - x[2*n+i]\n            cons.append({'type': 'ineq', 'fun': makefn_idy(i)})\n\n            def makefn_idy2(i):\n                return lambda x: 1 - x[2*i+1] - x[2*n+i]\n            cons.append({'type': 'ineq', 'fun': makefn_idy2(i)})\n\n            # radii nonnegative, loosened minimum a bit\n            def makefn_r0(i):\n                return lambda x: x[2*n+i] - 0.010\n            cons.append({'type': 'ineq', 'fun': makefn_r0(i)})\n\n            def makefn_r1(i):\n                return lambda x: 0.15 - x[2*n+i]\n            cons.append({'type': 'ineq', 'fun': makefn_r1(i)})\n\n        # All pairs: dist(center_i, center_j) >= ri + rj\n        overlap_margin = 0.0013\n        for i in range(n):\n            for j in range(i+1, n):\n                def makefun(i, j):\n                    return lambda x: (\n                        (x[2*i  ] - x[2*j  ])**2 +\n                        (x[2*i+1] - x[2*j+1])**2\n                    )**0.5 - (x[2*n+i] + x[2*n+j] + overlap_margin)\n                cons.append({'type':'ineq', 'fun': makefun(i,j)})\n\n        # --- Objective: minimize negative sum of radii ---\n        def objective(x):\n            return -np.sum(x[2*n:])\n\n        # --- Run optimizer ---\n        result = minimize(\n            objective, x0, constraints=cons, method='SLSQP',\n            options={'ftol':1e-7, 'maxiter': 1100, 'disp': False}\n        )\n\n        if not result.success:\n            x = x0\n        else:\n            x = result.x\n\n        centers = x[:2*n].reshape((n,2))\n        radii = x[2*n:]\n        sum_radii = np.sum(radii)\n\n        if sum_radii > best_sum:\n            best_sum = sum_radii\n            best_centers = centers\n            best_radii = radii\n\n    return best_centers, best_radii, float(best_sum)\n",
    "evaluation": {
      "fitness": 2.563346037831845,
      "additional_data": {
        "sum_radii": "2.563346",
        "target_ratio": "0.972807",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 63,
    "parent_id": 27,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    26 circles in a unit square, maximizing sum of radii.\n    Two\u2010stage optimization: quick SLSQP, then trust\u2010constr refinement.\n    Returns:\n        centers: (26,2) array\n        radii:   (26,)   array\n        sum_radii: float\n    \"\"\"\n    n = 26\n    # helper: central hex\u2010patch of 1+6+12 = 19 circles\n    def hex_patch(cx, cy, r, n_rings=2):\n        pos = [(cx, cy)]\n        for layer in range(1, n_rings+1):\n            m = 6*layer\n            for i in range(m):\n                ang = 2*np.pi*i/m\n                dx = layer*2*r*np.cos(ang)\n                dy = layer*2*r*np.sin(ang)\n                pos.append((cx+dx, cy+dy))\n        return np.array(pos)\n    # slightly smaller start radius to allow expansion\n    center_r = 0.090\n    cen = 0.5\n    cen_positions = hex_patch(cen, cen, center_r, n_rings=2)[:19]\n    # 7 rim spots\n    rim_positions = np.array([\n        [0.07,0.07],[0.93,0.07],[0.07,0.93],[0.93,0.93],\n        [0.50,0.04],[0.50,0.96],[0.96,0.50]\n    ])\n    centers_init = np.vstack([cen_positions, rim_positions])\n    # initial radii\n    radii_init = np.empty(n)\n    radii_init[:19] = center_r\n    radii_init[19:] = 0.06\n\n    # pack into x0\n    x0 = np.zeros(n*3)\n    x0[0::3] = centers_init[:,0]\n    x0[1::3] = centers_init[:,1]\n    x0[2::3] = radii_init\n\n    # bounds: x,y in [0,1], radii in [0.015,0.20]\n    bnds = []\n    for i in range(n):\n        bnds += [(0.0,1.0),(0.0,1.0),(0.015,0.20)]\n    bnds = tuple(bnds)\n\n    # constraints: non\u2010overlap and inside\u2010square\n    def all_constraints(v):\n        c = []\n        for i in range(n):\n            xi, yi, ri = v[3*i:3*i+3]\n            c.append(xi - ri)        # xi>=ri\n            c.append(1 - xi - ri)    # xi<=1-ri\n            c.append(yi - ri)\n            c.append(1 - yi - ri)\n            c.append(ri - 0.015)     # ri>=min\n            c.append(0.20 - ri)      # ri<=max\n        # pairwise\n        for i in range(n):\n            xi, yi, ri = v[3*i:3*i+3]\n            for j in range(i+1,n):\n                xj, yj, rj = v[3*j:3*j+3]\n                dx = xi-xj; dy = yi-yj\n                d2 = dx*dx+dy*dy\n                m = (ri+rj)\n                c.append(d2 - m*m)\n        return np.array(c)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    cons = {'type':'ineq','fun':all_constraints}\n\n    # Stage 1: quick SLSQP\n    res1 = minimize(objective, x0, method='SLSQP',\n                    bounds=bnds, constraints=[cons],\n                    options={'maxiter':200,'ftol':1e-4,'disp':False})\n    x_mid = res1.x if res1.success else x0\n\n    # Stage 2: trust\u2010region refinement\n    res2 = minimize(objective, x_mid, method='trust-constr',\n                    bounds=bnds, constraints=[cons],\n                    jac='2-point', hess='2-point',\n                    options={'maxiter':500,'gtol':1e-6,'verbose':0})\n    x_best = res2.x if res2.success and res2.fun < res1.fun else x_mid\n\n    # extract\n    centers = np.vstack((x_best[0::3], x_best[1::3])).T\n    radii   = x_best[2::3]\n    sumr    = float(np.sum(radii))\n    return centers, radii, sumr\n\n# for quick testing:\nif __name__=='__main__':\n    C,R,S = run_packing()\n    print(\"sum_radii =\", S)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 64,
    "parent_id": 36,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    n = 26\n\n    def alt_hex_coords(num, r_min=0.0385):\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx%2 else 0) + (max(rows)-nrow)/2*dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    # initial guess\n    r0 = 0.0365\n    r_min_grid = r0 + 0.0025\n    centers0 = alt_hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    # constraints\n    cons = []\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.008},\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.16 - x[2*n+i]},\n        ]\n    epsilon = 1e-5\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + epsilon)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n)-0.5) * jitter\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-10, 'maxiter':5000, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    xs, fits = [], []\n    xbest, fbest = optimize_once(x0, seed=None, jitter=0.0)\n    xs.append(xbest); fits.append(fbest)\n    for idx, jit in enumerate([0.012,0.015,0.025,0.030,0.040,0.050]):\n        xtry, ftry = optimize_once(xbest, seed=100+idx, jitter=jit)\n        xs.append(xtry); fits.append(ftry)\n    ib = int(np.argmax(fits))\n    xopt = xs[ib]\n    centers = xopt[:2*n].reshape(n,2)\n    radii   = xopt[2*n:]\n\n    # greedy inflation step\n    def inflate(centers, radii, iterations=10, eps=1e-8):\n        n = len(radii)\n        for _ in range(iterations):\n            for i in range(n):\n                x_i, y_i = centers[i]\n                r_max = min(x_i, 1-x_i, y_i, 1-y_i)\n                for j in range(n):\n                    if i == j: continue\n                    d = np.hypot(x_i-centers[j,0], y_i-centers[j,1]) - radii[j]\n                    if d < r_max:\n                        r_max = d\n                radii[i] = max(radii[i], max(0.0, r_max - eps))\n        return radii\n\n    radii = inflate(centers, radii, iterations=10)\n    \n    # linear programming to re-optimize radii\n    # maximize sum(r) subject to r_i <= boundary and r_i + r_j <= dist(i,j)\n    A = []\n    b = []\n    for i in range(n):\n        xi, yi = centers[i]\n        bound_i = min(xi,1-xi,yi,1-yi)\n        row = np.zeros(n)\n        row[i] = 1\n        A.append(row)\n        b.append(bound_i)\n    for i in range(n):\n        for j in range(i+1, n):\n            d = np.hypot(centers[i,0]-centers[j,0], centers[i,1]-centers[j,1])\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A.append(row)\n            b.append(d)\n    A = np.array(A)\n    b = np.array(b)\n    res_lp = linprog(-np.ones(n), A_ub=A, b_ub=b, bounds=[(0,None)]*n, method='highs')\n    if res_lp.success:\n        radii = res_lp.x\n\n    sum_radii = float(np.sum(radii))\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.6306466112134936,
      "additional_data": {
        "sum_radii": "2.630647",
        "target_ratio": "0.998348",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 65,
    "parent_id": 18,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Hex\u2010like initial grid with slightly bigger seed radius\n    def alt_hex_coords(num, r_min=0.0385):\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for nrow in rows:\n            offset = (max(rows) - nrow) / 2 * dx\n            for j in range(nrow):\n                x = r_min + offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    # Slight bump in initial radius\n    r0 = 0.0365\n    r_min_grid = r0 + 0.002\n    centers0 = alt_hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    cons = []\n    # boundary & radius bounds\n    for i in range(n):\n        cons += [\n            {'type':'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},    # x_i - r_i >= 0\n            {'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]}, # 1 - x_i - r_i >= 0\n            {'type':'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},    # y_i - r_i >= 0\n            {'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]}, # 1 - y_i - r_i >= 0\n            {'type':'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.011},       # r_i >= 0.011\n            {'type':'ineq', 'fun': lambda x, i=i: 0.14 - x[2*n+i]}         # r_i <= 0.14\n        ]\n    # non\u2010overlap\n    epsilon = 1e-4\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type':'ineq',\n                'fun': lambda x, i=i, j=j: np.hypot(x[2*i]-x[2*j], x[2*i+1]-x[2*j+1])\n                                           - (x[2*n+i]+x[2*n+j]+epsilon)\n            })\n\n    # maximize sum of radii\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            # jitter both centers and radii\n            xstart += (np.random.rand(xstart.shape[0]) - 0.5) * jitter\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-9, 'maxiter':3000, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    # multi\u2010start sequence\n    xs, fits = [], []\n    x_best, f_best = optimize_once(x0, seed=0, jitter=0.0)\n    xs.append(x_best); fits.append(f_best)\n\n    # targeted restarts: smaller and larger jitters\n    jitters = [0.008]*3 + [0.016]*3 + [0.024]*2\n    for idx, j in enumerate(jitters):\n        x_try, f_try = optimize_once(x_best, seed=100+idx, jitter=j)\n        xs.append(x_try); fits.append(f_try)\n        if f_try > f_best:\n            x_best, f_best = x_try, f_try\n\n    # unpack best\n    x = x_best\n    centers = x[:2*n].reshape(n,2)\n    radii   = x[2*n:]\n    return centers, radii, float(np.sum(radii))\n",
    "evaluation": {
      "fitness": 2.628831039178059,
      "additional_data": {
        "sum_radii": "2.628831",
        "target_ratio": "0.997659",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 66,
    "parent_id": 31,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Tweaked center-heavy hex grid: 7,6,5,4,4\n    def hex_coords(num, r_min=0.0360, y_compress=0.0):\n        rows = [7,6,5,4,4]  # 7+6+5+4+4=26\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        # Slightly compress grid vertically (y_compress in [0, 0.12])\n        dy0 = (1 - 2*r_min) / (len(rows)-1)\n        dy = dy0 * (1-y_compress)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx%2 else 0) + (max(rows) - nrow)/2*dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    r0 = 0.0378  # slightly bigger than before\n    r_min_grid = r0 + 0.0018\n\n    # Slight grid compression yields extra real estate for radii to grow\n    centers0 = hex_coords(n, r_min=r_min_grid, y_compress=0.080)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    cons = []\n    RMIN = 0.008\n    RMAX = 0.172  # allow optimizer a little more slack for big boundary circles\n\n    # boundary + radius bounds\n    for i in range(n):\n        cons += [\n            {'type':'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},         # x_i >= r_i\n            {'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},   # x_i <= 1 - r_i\n            {'type':'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},        # y_i >= r_i\n            {'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},    # y_i <= 1 - r_i\n            {'type':'ineq', 'fun': lambda x, i=i: x[2*n+i] - RMIN},            # r_i >= RMIN\n            {'type':'ineq', 'fun': lambda x, i=i: RMAX - x[2*n+i]},            # r_i <= RMAX\n        ]\n    # non-overlap constraint with epsilon=0 to allow tight packing\n    epsilon = 0.0\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type':'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i]-x[2*j], x[2*i+1]-x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + epsilon)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0, rad_jit=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n)-0.5)*jitter\n        if rad_jit > 0:\n            xstart[2*n:] += (np.random.rand(n)-0.5)*rad_jit\n            xstart[2*n:] = np.clip(xstart[2*n:], RMIN, RMAX)\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-8, 'maxiter':4600, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    # multi-start, more attempts, including more aggressive jittering\n    xs, fits = [], []\n    xbest, fbest = optimize_once(x0, None, 0.0, 0.0)\n    xs.append(xbest); fits.append(fbest)\n    jitters = [0.013, 0.018, 0.022, 0.034, 0.042, 0.052, 0.067, 0.080, 0.09, 0.10]\n    radjit = [0.004, 0.006, 0.008, 0.010, 0.013, 0.018, 0.021, 0.023, 0.026, 0.029]\n    for idx in range(len(jitters)):\n        xtry, ftry = optimize_once(xbest, seed=30+idx, jitter=jitters[idx], rad_jit=radjit[idx])\n        xs.append(xtry); fits.append(ftry)\n    # Try a \"radial shuffle\" for global variations: swap biggest and smallest 3 radii\n    xshuffle = xbest.copy()\n    rad = xshuffle[2*n:]\n    order = np.argsort(rad)\n    bigi = order[-3:]; smalli = order[:3]\n    avg = (rad[bigi].mean() + rad[smalli].mean())/2\n   ",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 67,
    "parent_id": 18,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Improved hexagonal close packing for initial positions\n    def better_hex_coords(num, r_min=0.0395):\n        # 5 rows: 6-5-5-5-5 = 26 (alternate row offset: True hex close pack)\n        row_counts = [6,5,5,5,5]\n        coords = []\n        rows = len(row_counts)\n        dx = (1 - 2*r_min) / (max(row_counts)-1)\n        dy = (1 - 2*r_min) / (rows-1)*0.97  # Contract packing vertically 97%\n        y0 = r_min + 0.5*(1-dy*(rows-1)-2*r_min)  # vertical centering\n        y = y0\n        for i, nrow in enumerate(row_counts):\n            offset = (max(row_counts) - nrow) / 2 * dx\n            if i % 2 == 1:  # offset for true hex pattern\n                offset += 0.5 * dx\n            for j in range(nrow):\n                x = r_min + offset + j * dx\n                coords.append([x, y])\n            y += dy\n        arr = np.array(coords)[:num]\n        arr = np.clip(arr, r_min, 1-r_min)  # safe edge fallback\n        return arr\n\n    # Larger initial guess for radii\n    r0 = 0.0382  # slightly larger than before\n    r_min_grid = r0 + 0.0013\n\n    centers0 = better_hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    cons = []\n    for i in range(n):\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]         })  # x_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]    })  # 1 - x_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]        })  # y_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]    })  # 1 - y_i - r_i >= 0\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.0105          })  # r_i >= 0.0105\n        cons.append({'type':'ineq', 'fun': lambda x, i=i: 0.151 - x[2*n+i]           })  # r_i <= 0.151\n\n    epsilon = 6e-4  # slight bump to make optimizer more stable\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({'type':'ineq', 'fun': lambda x, i=i, j=j: (\n                ((x[2*i] - x[2*j])**2 + (x[2*i+1] - x[2*j+1])**2 )**0.5\n                - (x[2*n+i] + x[2*n+j] + epsilon))})\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = np.copy(x0)\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n)-0.5)*jitter\n        result = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-8, 'maxiter':4000, 'disp':False}\n        )\n        if result.success:\n            return result.x, -result.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    # Multi-start: original, then extra jitters\n    xs_list, fits = [], []\n\n    xbest, fitbest = optimize_once(x0, seed=None, jitter=0.0)\n    xs_list.append(xbest)\n    fits.append(fitbest)\n    # more restarts: 3 at jitter=0.019, 2 at 0.032\n    for s, scale in enumerate([0.019]*3 + [0.032]*2):\n        xtry, fittry = optimize_once(xbest, seed=842+s, jitter=scale)\n        xs_list.append(xtry)\n        fits.append(fittry)\n\n    idx_best = np.argmax(fits)\n    x = xs_list[idx_best]\n\n    centers = x[:2*n].reshape((n,2))\n    radii = x[2*n:]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 2.624478724391023,
      "additional_data": {
        "sum_radii": "2.624479",
        "target_ratio": "0.996007",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 68,
    "parent_id": 7,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # --- HELPER: Constraints ---\n\n    def get_vars(x):\n        centers = x[:n*2].reshape((n,2))\n        radii = x[n*2:]\n        return centers, radii\n\n    def all_constraints(x):\n        centers, radii = get_vars(x)\n        cons = []\n\n        # Circle inside box\n        cons.extend(centers[:,0] - radii)       # x - r >= 0 --> x >= r\n        cons.extend(1 - centers[:,0] - radii)   # 1 - x - r >= 0 --> x <= 1 - r\n        cons.extend(centers[:,1] - radii)       # y - r >= 0\n        cons.extend(1 - centers[:,1] - radii)   # 1 - y - r >= 0\n\n        # Non-negative radii\n        cons.extend(radii - 0.005)           # min radius (avoid collapse)\n        \n        # Non-overlap: (d_ij - (r_i+r_j)) >= 0\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                cons.append(d - (radii[i] + radii[j]))\n        return np.array(cons)\n\n    # --- Objective ---\n    def obj(x):\n        # Negative sum because scipy minimizes\n        return -np.sum(x[n*2:])\n\n    # --- Smart Initial Placement: Layered Hexagonal Grid ---\n    # Closest known best is to \"bulge\" against the edges & share the load\n    rows = 5\n    row_counts = [5,6,5,5,5]     # Try variable row configuration\n    y_vals = np.linspace(0.12, 0.88, rows)\n    centers = []\n    for i, (y, m) in enumerate(zip(y_vals,row_counts)):\n        xs = np.linspace(0.12 + 0.035*(i%2), 0.88 - 0.035*(i%2), m)  # Staggered (hex)\n        for x in xs:\n            centers.append([x,y])\n    centers = np.array(centers)[:n]\n\n    # Initial radius: Max possible inside box given regular grid\n    min_dist = np.inf\n    for i in range(len(centers)):\n        for j in range(i+1, len(centers)):\n            d = np.linalg.norm(centers[i] - centers[j])\n            if d < min_dist:\n                min_dist = d\n    r0 = 0.5 * min_dist * 0.98   # A little smaller than half min separation\n\n    radii = np.full(n, r0)\n    # Stack into variables: [x0,y0, x1,y1, ..., xn,yn, r0,...,rn]\n    x0 = np.hstack([centers.flatten(), radii])\n\n    # --- BOUNDS ---\n    bounds = []\n    for i in range(n):\n        # Center x [0,1]\n        bounds.append((0.0,1.0))\n        # Center y [0,1]\n        bounds.append((0.0,1.0))\n    for i in range(n):\n        # Radius [0.005, 0.3] (can't be negative, can't be absurdly big)\n        bounds.append((0.005,0.25))\n\n    # --- Nonlinear Constraints ---\n    cons = {\n        'type':'ineq',\n        'fun': lambda x: all_constraints(x)\n    }\n\n    # --- Minimize (maximize sum of radii) ---\n    result = minimize(obj, x0, method='SLSQP',\n                      constraints=cons, bounds=bounds,\n                      options={'maxiter':1200, 'ftol':1e-8, 'disp':False})\n\n    xopt = result.x\n    centers, radii = get_vars(xopt)\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.607919215166213,
      "additional_data": {
        "sum_radii": "2.607919",
        "target_ratio": "0.989723",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 69,
    "parent_id": 26,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Denser band, as before. Slightly reduced r_min for better spacing\n    def hex_lattice_coords(num, r_min=0.0378):\n        # Structure: 4,5,8,5,4\n        rows = [4, 5, 8, 5, 4]\n        coords = []\n        dx = (1 - 2 * r_min) / (max(rows) - 1)\n        dy = (1 - 2 * r_min) / (len(rows) - 1)\n        y = r_min\n        for i, nrow in enumerate(rows):\n            offset = (max(rows) - nrow) / 2 * dx\n            for j in range(nrow):\n                x = r_min + offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    r0 = 0.0378\n\n    centers0 = hex_lattice_coords(n, r_min=r0)\n    np.random.seed(3)  # Slightly different seed for new jitter\n\n    # Smaller random shake to pack tighter\n    centers0 += (np.random.rand(n, 2) - 0.5) * 0.022\n\n    # Initial radii still uniform, but slightly smaller to match r0\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    cons = []\n\n    # All circles within [ri,1-ri], as before\n    for i in range(n):\n        cons.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i] - x[2*n+i]})\n        cons.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i] - x[2*n+i]})\n        cons.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]})\n        cons.append({'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]})\n\n        # Allow even smaller minimum radius\n        cons.append({'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.010})\n        cons.append({'type': 'ineq', 'fun': lambda x, i=i: 0.15 - x[2*n+i]})\n\n    for i in range(n):\n        for j in range(i+1, n):\n            # Remove the +0.002 padding: allow circles to just touch\n            cons.append({'type':'ineq', 'fun': lambda x, i=i, j=j: (\n                ((x[2*i  ] - x[2*j  ])**2 +\n                 (x[2*i+1] - x[2*j+1])**2\n                )**0.5 - (x[2*n+i] + x[2*n+j]))\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    result = minimize(\n        objective, x0, constraints=cons, method='SLSQP',\n        options={'ftol':1e-8, 'maxiter': 1100, 'disp': False}\n    )\n\n    if not result.success:\n        x = x0\n    else:\n        x = result.x\n\n    centers = x[:2*n].reshape((n,2))\n    radii = x[2*n:]\n    sum_radii = np.sum(radii)\n\n    return centers, radii, float(sum_radii)\n",
    "evaluation": {
      "fitness": 2.55928654667424,
      "additional_data": {
        "sum_radii": "2.559287",
        "target_ratio": "0.971266",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 70,
    "parent_id": 34,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n    # --- GEOMETRIC SEED CONSTRUCTION: ---\n    # Arrange 26 circles in a semi-hexagonal honeycomb pattern, with some near-edges/corners.\n\n    # Build the pattern: rows alternating as in a hex grid but warped to fit square.\n    centers = []\n\n    # Central row (6 circles), shifted\n    ncenter = 6\n    y_c = 0.5\n    for k in range(ncenter):\n        x = (k + 0.5) / ncenter\n        y = y_c\n        centers.append([x, y])\n    \n    # Row above (5 circles)\n    nrow = 5\n    y = y_c + 0.12\n    for k in range(nrow):\n        x = (k + 1) / (nrow + 2)\n        centers.append([x, y])\n    # Row below (5 circles)\n    y = y_c - 0.12\n    for k in range(nrow):\n        x = (k + 1) / (nrow + 2)\n        centers.append([x, y])\n\n    # Add medium rows closer to top and bottom (4 circles)\n    y = y_c + 0.24\n    for k in range(4):\n        x = (k + 1.5) / (4 + 2)\n        centers.append([x, y])\n    y = y_c - 0.24\n    for k in range(4):\n        x = (k + 1.5) / (4 + 2)\n        centers.append([x, y])\n\n    # Place 2 near corners, top left and bottom right\n    centers.append([0.10, 0.10])\n    centers.append([0.90, 0.90])\n\n    # Place 2 at opposite edge midpoints\n    centers.append([0.10, 0.90])\n    centers.append([0.90, 0.10])\n\n    # Place 2 near left and right edges, vertically offset\n    centers.append([0.10, 0.5])\n    centers.append([0.90, 0.5])\n\n    centers = np.array(centers)\n    assert len(centers) == n\n\n    # --- GEOMETRIC INITIAL RADII: try variable radii per shell/row ---\n    # Largest in center, decreasing towards edge.\n    radii = np.full(n, 0.055)  # base value\n\n    # Central row\n    for i in range(0, ncenter):\n        radii[i] = 0.065\n    # Next rows\n    for i in range(ncenter, ncenter + 2 * nrow):\n        radii[i] = 0.0575\n    # Medium rows\n    for i in range(ncenter + 2 * nrow, ncenter + 2 * nrow + 8):\n        radii[i] = 0.051\n    # Corners slightly smaller\n    for i in range(ncenter + 2*nrow + 8, n):\n        radii[i] = 0.048\n\n    # Small Gaussian jitter to both positions and radii to avoid symmetries\n    rng = np.random.default_rng(911)\n    centers += rng.normal(0, 0.010, centers.shape)\n    radii += rng.normal(0, 0.0035, radii.shape)\n    # Ensure within [0.035, 0.079]\n    radii = np.clip(radii, 0.035, 0.079)\n\n    # --- FLATTEN INITIAL X0 ---\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # --- CONSTRAINTS ---\n    epsilon = 1e-6\n    cons = []\n    # Boundary & positivity r>0, inside square\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]-x[2*n+i]},  # x - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i] - x[2*n+i]},  # x + r <= 1\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1]-x[2*n+i]},  # y - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},  # y + r <= 1\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.032}, # min r\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.089 - x[2*n+i]}, # max r\n        ]\n    # No overlap\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type':'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + epsilon)\n                )\n            })\n\n    # --- OBJECTIVE ---\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    # --- FIRST LOCAL OPTIMIZATION, GEOMETRIC SEED ---\n    res =",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 71,
    "parent_id": 17,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef make_hex_grid(n, padding=0.055, seed=0):\n    \"\"\"\n    Generate n points in a nearly hexagonal lattice inside [0,1]x[0,1],\n    spread as evenly as possible.\n    \"\"\"\n    rows = 5\n    cols = 6\n    y = np.linspace(padding, 1-padding, rows)\n    x = np.linspace(padding, 1-padding, cols)\n    centers = []\n    for i in range(rows):\n        # Shift every other row for hex pattern\n        xrow = x.copy()\n        if i%2 == 1:\n            xrow += (x[1]-x[0])/2\n        row_centers = []\n        for xx in xrow:\n            if padding <= xx <= 1-padding:\n                row_centers.append(xx)\n        for xx in row_centers:\n            centers.append((xx,y[i]))\n    # Truncate or randomly sample if too many\n    np.random.seed(seed)\n    if len(centers) > n:\n        idx = np.random.choice(len(centers), n, replace=False)\n        centers = [centers[i] for i in idx]\n    elif len(centers) < n:\n        # Add some in corners\n        for _ in range(n - len(centers)):\n            centers.append((padding + (1-2*padding)*np.random.rand(),\n                            padding + (1-2*padding)*np.random.rand()))\n    return np.array(centers)\n\ndef arrange_initial(n, padding=0.055, seed=0):\n    centers = make_hex_grid(n, padding=padding, seed=seed)\n    radii = np.ones(n) * 0.034\n    return centers, radii\n\ndef constraint_no_overlap(vars, n):\n    res = []\n    centers = vars[:-n].reshape((n,2))\n    radii = vars[-n:]\n    for i in range(n):\n        for j in range(i+1,n):\n            d = np.linalg.norm(centers[i]-centers[j])\n            res.append( d - (radii[i]+radii[j]) )\n    return np.array(res)\n\ndef constraint_in_square(vars, n):\n    centers = vars[:-n].reshape((n,2))\n    radii = vars[-n:]\n    res = []\n    x = centers[:,0]\n    y = centers[:,1]\n    res.extend( x - radii )         # >= 0\n    res.extend( 1 - (x + radii) )   # >= 0\n    res.extend( y - radii )         # >= 0\n    res.extend( 1 - (y + radii) )   # >= 0\n    return np.array(res)\n\ndef objective(vars, n):\n    radii = vars[-n:]\n    return -np.sum(radii)\n\ndef run_packing():\n    n = 26\n    best_sum = -1\n    best_c = None\n    best_r = None\n    np.random.seed(0)\n    for trial in range(7):  # Run 7 restarts\n        # Try a different random hex grid each time\n        centers, radii = arrange_initial(n, padding=0.055, seed=trial+37)\n        # Apply tiny random noise to positions for non-degeneracy\n        centers = np.clip(centers + 0.003*np.random.randn(*centers.shape), 0.0, 1.0)\n        radii = np.clip(radii + 0.005*np.random.randn(*radii.shape), 0.014, 0.18)\n        x0 = np.concatenate([centers.ravel(), radii])\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0,1.0))\n            bounds.append((0.0,1.0))\n        for i in range(n):\n            bounds.append((0.010, 0.22))\n        cons = []\n        cons.append({'type':'ineq','fun':constraint_no_overlap, 'args':(n,)})\n        cons.append({'type':'ineq','fun':constraint_in_square, 'args':(n,)})\n\n        result = minimize(objective, x0, args=(n,),\n                          method='SLSQP',\n                          bounds=bounds,\n                          constraints=cons,\n                          options={'maxiter':650,'ftol':1e-8,'disp':False})\n        if result.success:\n            xopt = result.x\n            centers_ = xopt[:-n].reshape((n,2))\n            radii_ = xopt[-n:]\n            # Validate: all radii positive, non-overlapping and contained\n            if (np.all(radii_>0)\n                and np.all(centers_[:,0] - radii_ >= -1e-5)\n                and np.all(centers_[:,1] - radii_ >= -1e-5)\n                and np.all(centers_[:,0] + radii_ <= 1+1e-5)\n                and np.all(centers_[:,1] + radii_ <= 1+1e-5)):\n                # Overlap check is in constraints, just to be sure:\n                ok = True\n                for i in range(n):\n                    for j in range(i+1,n):\n                        d = np.linalg.norm(centers_[i] - centers_[j])\n                        if d < (radii_[i]+radii_[j])-1e-6:\n                            ok = False\n                            break\n                    if not ok:\n                        break\n                if ok:\n                    sum_radii = np.sum(radii_)\n                    if sum_radii > best_sum:\n                        best_sum = sum_radii\n                        best_c = centers_.copy()\n                        best_r = radii_.copy()\n    return",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 72,
    "parent_id": 52,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # (Unchanged) Arrange initial centers in a pseudo-hex grid\n    def alt_hex_coords(num, r_min=0.0385):\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx%2 else 0) + (max(rows)-nrow)/2*dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    r0 = 0.0362  # Slightly smaller to allow post-inflation step\n    r_min_grid = r0 + 0.0025\n    centers0 = alt_hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    cons = []\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},            # x - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},       # 1 - x - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},            # y - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},        # 1 - y - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.009},               # r >= 0.009 (tiny increase for convexity)\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.16 - x[2*n+i]},                # r <= 0.16\n        ]\n    # non-overlap\n    epsilon = 7e-6\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + epsilon)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n)-0.5) * jitter\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':3e-10, 'maxiter':6500, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    # Multi-start optimization\n    xs, fits = [], []\n    jitters = [0.011,0.013,0.016,0.018,0.021,0.025]\n    xbest, fbest = optimize_once(x0, seed=None, jitter=0.0)\n    xs.append(xbest); fits.append(fbest)\n    for idx, jit in enumerate(jitters):\n        xtry, ftry = optimize_once(xbest, seed=127+idx, jitter=jit)\n        xs.append(xtry); fits.append(ftry)\n    ib = int(np.argmax(fits))\n    xopt = xs[ib]\n    centers = xopt[:2*n].reshape(n,2)\n    radii   = xopt[2*n:]\n\n    # Post-process greedy inflation, ensure all circles are inside and maximally \"bloated\"\n    def inflate(centers, radii, outer_iter=12, eps0=1e-4, fine_iter=2):\n        n = len(radii)\n        centers = centers.copy()\n        radii   = radii.copy()\n        for it in range(outer_iter):\n            eps = eps0 * (0.5**it)\n            order = np.argsort(radii)  # grow smaller circles first\n            for i in order:\n                x_i, y_i = centers[i]\n                # boundary slack\n                r_max = min(x_i, 1-x_i, y_i, 1-y_i)\n                # neighbor slack\n                for j in range(n):\n                    if i == j: continue\n                    d = np.hypot(x_i-centers[j,0], y_i-centers[j,1]) - radii[j]\n                    if d < r_max:\n                        r_max = d\n                # Don't reduce a circle's radius\n                if r_max - eps > radii[i]:\n                    radii[i",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 73,
    "parent_id": 21,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Construct initial guess: central, inner shell, outer shell, corner/edge fillers\n\n    # Central circle (index 0)\n    center = np.array([0.5, 0.5])\n\n    # Inner shell: 6 circles spaced hexagonally at radius r1 (to be determined)\n    inner_shell_theta = np.linspace(0, 2*np.pi, 7, endpoint=False)[:-1]\n    inner_shell_r = 0.167  # slightly increased\n    inner_shell_xy = center + 0.272 * np.stack([np.cos(inner_shell_theta), np.sin(inner_shell_theta)], axis=-1)  # slightly expanded shell\n\n    # Outer shell: 12 circles spaced at larger radius, pressed to corners/edges more\n    outer_shell_theta = np.linspace(0, 2*np.pi, 13, endpoint=False)[:-1]\n    R2 = 0.41  # more aggressive\n    squash_x = 0.5 + R2*np.cos(outer_shell_theta) * 0.93\n    squash_y = 0.5 + R2*np.sin(outer_shell_theta) * 0.93\n    outer_shell_xy = np.stack([squash_x, squash_y], axis=1)\n\n    # 7 edge/corner fillers, adjusted very slightly (fill corners/touch edges a bit more)\n    fillers = np.array([\n        [0.10, 0.10],\n        [0.10, 0.90],\n        [0.90, 0.10],\n        [0.90, 0.90],\n        [0.5, 0.07],\n        [0.07, 0.5],\n        [0.5, 0.93]\n    ])\n\n    # Assemble all centers\n    centers_init = np.vstack([\n        center[None],           # 1\n        inner_shell_xy,         # 6\n        outer_shell_xy,         # 12\n        fillers                 # 7\n    ])  # shape (26,2)\n\n    assert centers_init.shape == (26,2), \"Bad arrangement\"\n\n    # Assign radii: bump up r_center, r_inner, r_outer slightly, a bit less for fillers\n    r_center = 0.136\n    r_inner = 0.113\n    r_outer = 0.087\n    r_filler = 0.068\n\n    radii_init = np.concatenate([\n        [r_center],\n        [r_inner]*6,\n        [r_outer]*12,\n        [r_filler]*7\n    ])\n\n    # Add random <1.5% jitter to break symmetries and help optimizer escape local minima\n    rs = np.random.RandomState(121)\n    centers_init += rs.uniform(-0.009, 0.009, centers_init.shape)\n    radii_init *= rs.uniform(0.985, 1.015, radii_init.shape)\n\n    # Construct optimization variables: [x0, y0, r0, x1, y1, r1, ...]\n    x0 = np.empty(n*3)\n    x0[0::3] = centers_init[:,0]\n    x0[1::3] = centers_init[:,1]\n    x0[2::3] = radii_init\n\n    # --- Constraints ---\n\n    bounds = []\n    for i in range(n):\n        # We allow full box for centers, but radii in [0.004, 0.18]\n        bounds.extend([(0.0,1.0), (0.0,1.0), (0.004,0.18)])\n\n    def objective(z):\n        # maximize sum radii\n        return -np.sum(z[2::3])\n\n    cons = []\n\n    # Each circle in square (center +/- radius in [0,1] for both axes)\n    for i in range(n):\n        def bl(z, i=i):\n            return z[0+3*i] - z[2+3*i]\n        def br(z, i=i):\n            return 1.0 - (z[0+3*i] + z[2+3*i])\n        def bb(z, i=i):\n            return z[1+3*i] - z[2+3*i]\n        def bt(z, i=i):\n            return 1.0 - (z[1+3*i] + z[2+3*i])\n        cons.append({'type':'ineq','fun':bl})\n        cons.append({'type':'ineq','fun':br})\n        cons.append({'type':'ineq','fun':bb})\n        cons.append({'type':'ineq','fun':bt})\n\n    # Non-overlap between every pair\n    for i in range(n):\n        for j in range(i+1, n):\n            def sep(z, i=i, j=j):\n                xi, yi, ri = z[3*i], z[3*i+1], z[3*i+2]\n                xj, yj, rj = z[3*j], z[3*j+1], z[3*j+2]\n                return np.hypot(xi-xj, yi-yj) - (ri + rj)\n            cons.append({'type':'ineq','fun':sep})\n\n    # We use SLSQP, but increase iterations and use tighter tolerance\n    res = minimize(\n        objective, x0, method='SLSQP', bounds=bounds, constraints=cons,\n        options={'disp': False, 'maxiter': 2500, 'ftol': 1e-9}\n    )\n\n    z = res.x\n    centers = np.zeros((n,2))\n    radii = np.zeros(n)\n    for i in range(n):\n        centers[i,0] = z[3*i]\n        centers[i,1] = z[3*i+1]\n        radii[i] = z[3*i+2]\n\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.598425627440356,
      "additional_data": {
        "sum_radii": "2.598426",
        "target_ratio": "0.986120",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 74,
    "parent_id": 18,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    # initial hex-like layout\n    def alt_hex_coords(num, r_min=0.03):\n        rows = [6,5,5,5,5]\n        dx = (1 - 2*r_min) / (max(rows) - 1)\n        dy = (1 - 2*r_min) / (len(rows) - 1)\n        coords = []\n        y = r_min\n        for rcount in rows:\n            offset = (max(rows) - rcount) / 2 * dx\n            for j in range(rcount):\n                coords.append([r_min + offset + j*dx, y])\n            y += dy\n        return np.array(coords[:num])\n\n    # compute radii from positions by boundary and neighbor distances\n    def compute_radii(centers):\n        # boundary distances\n        bx = np.minimum(centers[:,0], 1 - centers[:,0])\n        by = np.minimum(centers[:,1], 1 - centers[:,1])\n        bdist = np.minimum(bx, by)\n        # pairwise distances\n        dif = centers[:, None, :] - centers[None, :, :]\n        d2 = dif[:,:,0]**2 + dif[:,:,1]**2 + np.eye(n)*1e6\n        d = np.sqrt(d2)\n        min_nd = np.min(d, axis=1)\n        radii = np.minimum(bdist, 0.5 * min_nd)\n        return radii\n\n    # simulated annealing on positions\n    centers = alt_hex_coords(n)\n    radii = compute_radii(centers)\n    best_centers = centers.copy()\n    best_radii = radii.copy()\n    best_sum = best_radii.sum()\n    curr_centers = centers.copy()\n    curr_radii = radii.copy()\n    curr_sum = best_sum\n\n    rng = np.random.RandomState(42)\n    max_iter = 80000\n    T0 = 0.02\n    step0 = 0.15\n    for k in range(1, max_iter+1):\n        # temperature and step schedule\n        t = k / max_iter\n        T = T0 * (1 - t)\n        step = step0 * (1 - t)\n        # propose move for one circle\n        i = rng.randint(n)\n        new_centers = curr_centers.copy()\n        new_centers[i] += rng.randn(2) * step\n        # clip into box\n        new_centers[i,0] = min(max(new_centers[i,0], 0.0), 1.0)\n        new_centers[i,1] = min(max(new_centers[i,1], 0.0), 1.0)\n        new_radii = compute_radii(new_centers)\n        new_sum = new_radii.sum()\n        # acceptance\n        if new_sum > curr_sum or rng.rand() < np.exp((new_sum - curr_sum) / max(T,1e-6)):\n            curr_centers, curr_radii, curr_sum = new_centers, new_radii, new_sum\n            # update best\n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_centers = curr_centers.copy()\n                best_radii = curr_radii.copy()\n\n    return best_centers, best_radii, float(best_sum)\n",
    "evaluation": {
      "fitness": 2.4974268028420283,
      "additional_data": {
        "sum_radii": "2.497427",
        "target_ratio": "0.947790",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 75,
    "parent_id": 64,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    n = 26\n\n    def alt_hex_coords(num, r_min=0.0385):\n        # Staggered hex rows\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx%2 else 0) + (max(rows)-nrow)/2*dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    # Try two grids: original and shifted hex center\n    best_sum = -1\n    best_centers, best_radii = None, None\n\n    for r_min_shift in [0.0385, 0.0400]:\n\n        # initial guess\n        r0 = 0.0365\n        r_min_grid = r0 + 0.0025\n        centers0 = alt_hex_coords(n, r_min=r_min_shift)\n        radii0 = np.full(n, r0)\n        x0 = np.concatenate([centers0.flatten(), radii0])\n\n        # constraints\n        cons = []\n        for i in range(n):\n            cons += [\n                {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n                {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n                {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n                {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n                {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.008},\n                {'type': 'ineq', 'fun': lambda x, i=i: 0.16 - x[2*n+i]},\n            ]\n        epsilon = 3e-6  # a little tighter\n        for i in range(n):\n            for j in range(i+1, n):\n                cons.append({\n                    'type': 'ineq',\n                    'fun': lambda x, i=i, j=j: (\n                        np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                        - (x[2*n+i] + x[2*n+j] + epsilon)\n                    )\n                })\n\n        def objective(x):\n            return -np.sum(x[2*n:])\n\n        def optimize_once(x0, seed=None, jitter=0.0):\n            xstart = x0.copy()\n            if seed is not None:\n                np.random.seed(seed)\n            if jitter > 0:\n                xstart[:2*n] += (np.random.rand(2*n)-0.5) * jitter\n            res = minimize(\n                objective, xstart, constraints=cons, method='SLSQP',\n                options={'ftol':1e-10, 'maxiter':6000, 'disp':False}\n            )\n            if res.success:\n                return res.x, -res.fun\n            else:\n                return xstart, np.sum(xstart[2*n:])\n\n        xs, fits = [], []\n        xbest, fbest = optimize_once(x0, seed=None, jitter=0.0)\n        xs.append(xbest); fits.append(fbest)\n        for idx, jit in enumerate([0.012,0.015,0.025,0.030,0.040,0.050]):\n            xtry, ftry = optimize_once(xbest, seed=100+idx, jitter=jit)\n            xs.append(xtry); fits.append(ftry)\n        ib = int(np.argmax(fits))\n        xopt = xs[ib]\n        centers = xopt[:2*n].reshape(n,2)\n        radii   = xopt[2*n:]\n\n        # Improved inflation: do a binary search per circle for max radius (not just nudge up)\n        def inflate_precisely(centers, radii, iterations=30, eps=1e-10):\n            n = len(radii)\n            radii_new = radii.copy()\n            for iter in range(iterations):\n                for i in range(n):\n                    xi, yi = centers[i]\n                    # Max possible radius due to boundaries\n                    r_bound = min(xi, 1-xi, yi, 1-yi)\n                    # Max due to other circles\n                    r_pair = []\n                    for j in range(n):\n                        if i == j: continue\n                        d = np.hypot(xi-centers[j,0], yi-centers[j,1])\n                        d = d - radii_new[j]\n                        if d >= 0:\n                            r_pair.append(d)\n                        else:\n                            r_pair.append(0)\n                    r_max = min([r_bound] + r_pair)\n                    # Use binary search to push radii_new[i] as large as possible\n                    low = radii_new[i]\n                    high = max(radii_new[i], r_max)\n                    for _ in range(10):  # binary search loop\n                        mid = (low + high) / 2\n                        valid = True\n                        # check boundaries\n                        if not (mid <= min(xi, 1-xi, yi, 1-yi) + eps):\n                            valid = False\n                        else:\n                            for j in range(n):\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 76,
    "parent_id": 64,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    n = 26\n\n    def alt_hex_coords(num, r_min=0.0385):\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx%2 else 0) + (max(rows)-nrow)/2*dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    def shell_shift_coords(num, r_min=0.035):\n        # 8 periphery, 6 at next shell, 6, then 6; rough ring grouping\n        angles1 = np.linspace(0, 2*np.pi, 8, endpoint=False)\n        radius1 = 0.42\n        angles2 = np.linspace(0, 2*np.pi, 6, endpoint=False)\n        radius2 = 0.23\n        cx, cy = 0.5, 0.5\n        out = []\n        for a in angles1:\n            out.append([cx + radius1*np.cos(a), cy + radius1*np.sin(a)])\n        for a in angles2:\n            out.append([cx + radius2*np.cos(a), cy + radius2*np.sin(a)])\n        # center and additional points slightly randomized towards the middle\n        for _ in range(num-len(out)):\n            out.append([np.random.uniform(0.18,0.82), np.random.uniform(0.18,0.82)])\n        return np.array(out[:num])\n\n    r0 = 0.0364\n    r_min_grid = r0 + 0.0027\n    centers0 = alt_hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    # constraints\n    cons = []\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.008},\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.16 - x[2*n+i]},\n        ]\n    epsilon = 1.2e-5 # slightly larger for more separation for numerical stability\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + epsilon)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            rng = np.random.RandomState(seed)\n        else:\n            rng = np.random\n        if jitter > 0:\n            xstart[:2*n] += (rng.rand(2*n)-0.5) * jitter\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-10, 'maxiter':5500, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    all_xs, all_fits = [], []\n    \n    best = (-1e9, None)\n    # Try different starting arrangements and jitters\n    for base_idx, (centers_init, rgrid) in enumerate([\n            (alt_hex_coords(n, r_min=0.039), 0.037),\n            (alt_hex_coords(n, r_min=0.035), 0.0342),\n            (shell_shift_coords(n), 0.0328)\n        ]):\n        for s, jit in enumerate([0.0, 0.012, 0.018, 0.022, 0.030, 0.037]):\n            rad_init = np.full(n, rgrid)\n            x_init = np.concatenate([centers_init.flatten(), rad_init])\n            xopt, fitopt = optimize_once(x_init, seed=1337+base_idx*7+s, jitter=jit)\n            all_xs.append(xopt); all_fits.append(fitopt)\n            if fitopt > best[0]:\n                best = (fitopt, xopt.copy())\n\n    xbest = best[1]\n    centers = xbest[:2*n].reshape(n,2)\n    radii   = xbest[2*n:]\n\n    # aggressive greedy inflation step with more iterations\n    def inflate(centers, radii, iterations=12, eps=1e-9):\n        n = len(radii)\n        updated = radii.copy()\n        for _ in range(iterations):\n            for i in range(n):\n                x_i, y_i = centers[i]\n                r_max = min(x_i, 1-x_i, y_i, 1-y_i)\n                for j in range(n):\n                    if i == j: continue\n                    d = np.hypot(x_i-centers[j,0], y_i-centers[j,1",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 77,
    "parent_id": 64,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    n = 26\n\n    # Generate several alternative hex/grid/semi-random layouts\n    def alt_hex_coords(num, r_min=0.0385, jitter=0.0, offset=0.0):\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min + offset\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx%2 else 0) + (max(rows)-nrow)/2*dx + offset\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        coords = np.array(coords)[:num]\n        if jitter>0:\n            coords += (np.random.rand(*coords.shape)-0.5) * jitter\n        coords = np.clip(coords, r_min, 1-r_min)\n        return coords\n\n    # Try a central circle version, plus others\n    def center_shell_coords(num, r=0.036, jitter=0.0):\n        coords = []\n        R_outer = 0.5 - r\n        coords.append([0.5, 0.5])\n        # Distribute rest on two shells\n        for ring, npts in zip([0.25, 0.38], [8, 17]):\n            for k in range(npts):\n                th = 2*np.pi*k/npts + (ring*37)%1 # Stagger angles\n                x = 0.5 + ring*np.cos(th)\n                y = 0.5 + ring*np.sin(th)\n                coords.append([x, y])\n        coords = np.array(coords)[:num]\n        if jitter>0:\n            coords += (np.random.rand(*coords.shape)-0.5)*jitter\n        coords = np.clip(coords, r, 1-r)\n        return coords\n\n    seeds = [\n        (alt_hex_coords(n, r_min=0.0385, jitter=0.005, offset=0.0), 0.0365),\n        (alt_hex_coords(n, r_min=0.0375, jitter=0.009, offset=0.012), 0.0372),\n        (alt_hex_coords(n, r_min=0.0335, jitter=0.014, offset=-0.006), 0.0376),\n        (center_shell_coords(n, r=0.0365, jitter=0.013), 0.0365),\n    ]\n\n    # constraints\n    cons = []\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.008},\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.16 - x[2*n+i]},\n        ]\n    epsilon = 1e-5\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + epsilon)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n)-0.5) * jitter\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-10, 'maxiter':5000, 'disp': False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    # Try all seeds/patterns and jitters, keep best\n    xs, fits = [], []\n    for cinit, r0 in seeds:\n        radii0 = np.full(n, r0)\n        x0 = np.concatenate([cinit.flatten(), radii0])\n        xbest, fbest = optimize_once(x0, seed=None, jitter=0.0)\n        xs.append(xbest)\n        fits.append(fbest)\n        for idx, jit in enumerate([0.012,0.015,0.025,0.030,0.040,0.050,0.075]):\n            xtry, ftry = optimize_once(xbest, seed=101+idx, jitter=jit)\n            xs.append(xtry); fits.append(ftry)\n    ibest = int(np.argmax(fits))\n    xopt = xs[ibest]\n    centers = xopt[:2*n].reshape(n,2)\n    radii   = xopt[2*n:]\n\n    # greedy inflation step (more/finer)\n    def inflate(centers, radii, iterations=28, eps=3e-9):\n        n = len(radii)\n        for _ in range(iterations):\n            for i in range(n):\n                x_i, y_i = centers[i]\n                r_max = min(x_i, 1-x_i, y_i, 1-y_i)\n                for j in range(n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 78,
    "parent_id": 64,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    n = 26\n\n    # Helper: check for overlap with current placed circles\n    def valid_pos(pos, r, placed_centers, placed_radii):\n        if pos[0]-r < 0 or pos[0]+r > 1 or pos[1]-r < 0 or pos[1]+r > 1:\n            return False\n        if placed_centers.shape[0] == 0:\n            return True\n        dists = np.sqrt(np.sum((placed_centers - pos)**2, axis=1))\n        return np.all(dists >= (placed_radii + r - 1e-8))\n\n    # Return maximal possible radius for given pos, given current circles\n    def max_allowed_radius(pos, placed_centers, placed_radii):\n        maxr = min(pos[0], 1-pos[0], pos[1], 1-pos[1])\n        if placed_centers.shape[0] == 0:\n            return maxr\n        dists = np.sqrt(np.sum((placed_centers - pos)**2, axis=1)) - placed_radii\n        if len(dists)==0:\n            return maxr\n        return min([maxr]+[d for d in dists])\n\n    # 1. Constructive greedy placement:\n\n    placed_centers = []\n    placed_radii = []\n\n    # Place the first (largest) circle at center\n    pos0 = np.array([0.5, 0.5])\n    r0 = max_allowed_radius(pos0, np.empty((0,2)), np.empty(0))\n    placed_centers.append(pos0)\n    placed_radii.append(r0*0.92)  # Slightly reduce to allow surrounds, helps with edge cases\n\n    # For each new circle, search among a set of candidate locations, placing the biggest such\n    # Candidates: grid over square, biased towards boundaries, previous circle edges, and corners.\n\n    for idx in range(1, n):\n        # Generate candidate positions: corners, edges, grid points, and points around existing circles\n        candidates = []\n\n        # Edges: Uniform along square perimeter (20)\n        edge_points = []\n        s_pts = max(8, 2*n)\n        # Bottom and top\n        xs = np.linspace(0.05,0.95,s_pts)\n        for x in xs:\n            edge_points.append([x,0.0])\n            edge_points.append([x,1.0])\n        ys = np.linspace(0.05,0.95,s_pts)\n        for y in ys:\n            edge_points.append([0.0,y])\n            edge_points.append([1.0,y])\n        candidates.extend(edge_points)\n        # Corners\n        for c in [[0,0],[1,0],[0,1],[1,1]]:\n            candidates.append(c)\n        # Points on a coarse grid (avoid too regular)\n        grid_pts = []\n        gridsz = max(5,int(np.sqrt(n))*2)\n        for i in range(gridsz):\n            for j in range(gridsz):\n                grid_pts.append([ (0.07+0.86*i/(gridsz-1)), (0.07+0.86*j/(gridsz-1)) ])\n        candidates.extend(grid_pts)\n        # Near each placed circle at radius+tiny step (biased toward edge of current circles)\n        for ci, ri in zip(placed_centers, placed_radii):\n            for th in np.linspace(0,2*np.pi,16,endpoint=False):\n                pt = ci + (ri + 0.003) * np.array([np.cos(th), np.sin(th)])\n                if 0<=pt[0]<=1 and 0<=pt[1]<=1:\n                    candidates.append(pt)\n        candidates = np.array(candidates)\n\n        # For each candidate, compute maximal allowed radius\n        best_r = -1\n        best_pos = None\n        for pos in candidates:\n            r = max_allowed_radius(pos, np.array(placed_centers), np.array(placed_radii))\n            if r > best_r+1e-6:\n                # Additional bias: prefer positions NOT exactly at walls/corners unless that's much better\n                w_dist = min(pos[0],1-pos[0],pos[1],1-pos[1])\n                bias = 1.0 if w_dist < 0.01 else 0.98\n                r_eff = r*bias\n                if r_eff > best_r:\n                    best_r = r\n                    best_pos = pos.copy()\n        # Place new circle\n        placed_centers.append(best_pos)\n        placed_radii.append(best_r)\n\n    centers = np.array(placed_centers)\n    radii = np.array(placed_radii)\n\n    # 2. Global refinement / optimization\n    # After initial constructive placement, adjust all positions/radii with constraints\n\n    # Initial guess vector: x = [x1,y1,x2,y2,...,xn,yn,r1,...,rn]\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # Constraints: boundaries, non-overlap, radii positive and fit in square\n    cons = []\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},        # x>=r\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},  # x<=1-r\n            {'type': 'ineq', 'fun",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 79,
    "parent_id": 56,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles\n    inner_ring_r = 0.26\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Outer ring of 16 circles\n    outer_ring_r = 0.39\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # One additional circle near bottom edge (nudge slightly closer to bottom to allow more space for others)\n    corner_idx = 25\n    centers[corner_idx] = [0.5, 0.08]  # changed from 0.085 to 0.08\n\n    # Initial radii\n    radii = np.ones(n) * 0.073\n    radii[0] = 0.086\n    radii[1:9] = 0.076\n    radii[9:25] = 0.070\n    radii[corner_idx] = 0.074\n\n    # Enforce border constraints initially\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    # Iterative shrink-relax passes (increase passes for finer adjustment)\n    passes = 22\n    for _ in range(passes):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = centers[i] - centers[j]\n                d = np.hypot(dx, dy)\n                if d < 1e-12:\n                    s = 0.5\n                else:\n                    s = min(1.0, (d * 0.995) / (radii[i] + radii[j]))\n                if s < 1.0:\n                    if radii[i] < radii[j]:\n                        radii[i] *= s ** 0.53\n                        radii[j] *= s ** 0.47\n                    else:\n                        radii[j] *= s ** 0.53\n                        radii[i] *= s ** 0.47\n        # Border constraint after each pass\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    # Final border cleanup\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    # Greedy local enlargement\n    for _ in range(2):\n        for i in range(n):\n            xi, yi = centers[i]\n            max_r = min(xi, yi, 1 - xi, 1 - yi)\n            for j in range(n):\n                if j == i: continue\n                dx, dy = xi - centers[j,0], yi - centers[j,1]\n                dij = np.hypot(dx, dy)\n                max_r = min(max_r, dij - radii[j])\n            if max_r > radii[i]:\n                radii[i] = max_r\n\n    # Micro-nudge local coordinate ascent to try to find room: for each circle, nudge position to maximize allowed radius\n    # Try for all circles a few times each\n    nudge_steps = 2\n    nudge_delta = 0.003\n    nudge_dirs = np.array([[1,0],[0,1],[-1,0],[0,-1],[1,1],[-1,1],[-1,-1],[1,-1]]) / np.sqrt(2)  # 8 dirs\n\n    for _ in range(nudge_steps):\n        for i in range(n):\n            best_center = centers[i].copy()\n            xi0, yi0 = centers[i]\n            best_r = radii[i]\n            # Try small nudges in each direction\n            for d in nudge_dirs:\n                xi = xi0 + d[0]*nudge_delta\n                yi = yi0 + d[1]*nudge_delta\n                if not (0.0 < xi < 1.0 and 0.0 < yi < 1.0):\n                    continue\n                max_r = min(xi, yi, 1 - xi, 1 - yi)\n                for j in range(n):\n                    if j == i: continue\n                    dx, dy = xi - centers[j,0], yi - centers[j,1]\n                    dij = np.hypot(dx, dy)\n                    max_r = min(max_r, dij - radii[j])\n                if max_r > best_r and max_r > 0.0:\n                    best_r = max_r\n                    best_center = [xi, yi]\n            centers[i] = best_center\n            radii[i] = best_r\n\n    # After nudging, another greedy radius maximization pass to lock in new potential\n    for _ in range(2):\n        for i in range(n):\n            xi, yi = centers[i]\n            max_r =",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 80,
    "parent_id": 46,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n    best_sum_radii = -np.inf\n    best_centers = None\n    best_radii = None\n\n    num_restarts = 7  # try 7 times with different random initializations\n\n    for restart in range(num_restarts):\n        # Slightly expand grid to cover more edge near square\n        rows = 5\n        cols = 6\n        x_grid = np.linspace(0.10, 0.90, cols)\n        y_grid = np.linspace(0.10, 0.90, rows)\n        xv, yv = np.meshgrid(x_grid, y_grid)\n        xy = np.column_stack([xv.ravel(), yv.ravel()])\n        # Pick 26 closest points to center\n        dists = np.linalg.norm(xy - 0.5, axis=1)\n        idxs = np.argsort(dists)[:n]\n        centers_init = xy[idxs]\n        # Add small random perturbations (less than before to keep regularity)\n        np.random.seed(42 + restart)\n        centers_init += (np.random.rand(n,2)-0.5)*0.05\n\n        # More variable initial radii: linear decrease from center outwards\n        dist_from_center = np.linalg.norm(centers_init - 0.5, axis=1)\n        radii_init = 0.13 - 0.03*dist_from_center/dist_from_center.max() + (np.random.rand(n)-0.5)*0.01\n\n        # Flatten variables\n        x0 = np.concatenate([centers_init.ravel(), radii_init])\n\n        cons = []\n        # Boundary constraints\n        for i in range(n):\n            def cons_xi(x, i=i):\n                return x[2*i] - x[n*2 + i]\n            cons.append({'type': 'ineq', 'fun': cons_xi})\n            def cons_xi2(x, i=i):\n                return 1. - (x[2*i] + x[n*2 + i])\n            cons.append({'type': 'ineq', 'fun': cons_xi2})\n            def cons_yi(x, i=i):\n                return x[2*i+1] - x[n*2 + i]\n            cons.append({'type': 'ineq', 'fun': cons_yi})\n            def cons_yi2(x, i=i):\n                return 1. - (x[2*i+1] + x[n*2 + i])\n            cons.append({'type': 'ineq', 'fun': cons_yi2})\n\n        # Non-overlap constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                def cons_sep(x, i=i, j=j):\n                    xi = x[2*i]\n                    yi = x[2*i+1]\n                    xj = x[2*j]\n                    yj = x[2*j+1]\n                    ri = x[n*2 + i]\n                    rj = x[n*2 + j]\n                    center_dist_sq = (xi-xj)**2 + (yi-yj)**2\n                    min_dist = ri + rj\n                    return (center_dist_sq - (min_dist**2))\n                cons.append({'type': 'ineq', 'fun': cons_sep})\n\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0,1.0))\n            bounds.append((0.0,1.0))\n        for i in range(n):\n            bounds.append((0.002, 0.25))\n\n        def obj(x):\n            return -np.sum(x[n*2:])\n\n        options = dict(maxiter=1200, disp=False)\n\n        res = minimize(obj, x0, method='SLSQP', bounds=bounds, constraints=cons, options=options)\n\n        if res.success:\n            x_opt = res.x\n            centers = x_opt[:n*2].reshape(n,2)\n            radii = x_opt[n*2:]\n        else:\n            centers = centers_init\n            radii = radii_init\n\n        sum_radii = np.sum(radii)\n        if sum_radii > best_sum_radii:\n            best_sum_radii = sum_radii\n            best_centers = centers\n            best_radii = radii\n\n    return best_centers, best_radii, best_sum_radii\n",
    "evaluation": {
      "fitness": 2.599015396721543,
      "additional_data": {
        "sum_radii": "2.599015",
        "target_ratio": "0.986344",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 81,
    "parent_id": 31,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Slightly tweaked distribution: extra row at the bottom (8), more edge-hugging\n    def hex_coords(num, r_min=0.0357):\n        rows = [8,6,5,4,3]  # More edge coverage, still 26\n        assert sum(rows)==26\n        maxrow = max(rows)\n        dx = (1-2*r_min)/(maxrow-1)\n        dy = (1-2*r_min)/(len(rows)-1)\n        coords = []\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx%2 else 0) + (maxrow-nrow)/2*dx\n            for j in range(nrow):\n                x = r_min + row_offset + j*dx\n                coords.append([x,y])\n            y += dy\n        return np.array(coords)[:num]\n\n    # Initial radii: larger radii for center, smaller toward edges, for initial seed\n    r_init_c = 0.0386  # centermost row\n    r_init_b = 0.0355  # outermost row\n    radii_template = []\n    for i, r in enumerate([8,6,5,4,3]):\n        rrow = np.linspace(r_init_b, r_init_c, len([8,6,5,4,3]))[i]\n        radii_template += [rrow]*r\n    radii0 = np.array(radii_template[:n])\n    centers0 = hex_coords(n, r_min=min(radii0))\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    cons = []\n    # Slightly increased maximum radius bound from 0.165 to 0.17\n    for i in range(n):\n        cons += [\n            {'type':'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n            {'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n            {'type':'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n            {'type':'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n            {'type':'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.008},\n            {'type':'ineq', 'fun': lambda x, i=i: 0.17 - x[2*n+i]},\n        ]\n    # non-overlap constraint with even tighter epsilon (very small)\n    epsilon = 1e-6\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type':'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i]-x[2*j], x[2*i+1]-x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + epsilon)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0, rad_jit=0.0, ftol=1e-8, maxiter=4000):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n)-0.5)*jitter\n        if rad_jit > 0:\n            xstart[2*n:] += (np.random.rand(n)-0.5)*rad_jit\n            xstart[2*n:] = np.clip(xstart[2*n:], 0.008, 0.17)\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':ftol, 'maxiter':maxiter, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    xs, fits = [], []\n\n    # More multistart: vary jitters, radius jitters, and seeds\n    seeds = [None, 1, 2, 10, 30, 44, 69, 110, 200, 301, 420]\n    jitters = [0.0, 0.013, 0.019, 0.025, 0.03, 0.036, 0.041, 0.052, 0.065, 0.08, 0.10]\n    radjit = [0.0, 0.004, 0.007, 0.01, 0.014, 0.017, 0.02, 0.022, 0.025, 0.028, 0.032]\n    for idx in range(len(seeds)):\n        xtry, ftry = optimize_once(x0, seed=seeds[idx], jitter=jitters[idx], rad_jit=radjit[idx])\n        xs.append(xtry); fits.append(ftry)\n\n    # Pick best\n    ib = int(np.argmax(fits))\n    xbest = xs[ib]\n\n    # Final '",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 82,
    "parent_id": 64,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    n = 26\n\n    def alt_hex_coords(num, r_min=0.0385):\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx % 2 else 0) + (max(rows)-nrow)/2 * dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    r0 = 0.0365\n    r_min_grid = r0 + 0.0025\n    centers0 = alt_hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    cons = []\n    eps = 1e-6\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.008},\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.16 - x[2*n+i]},\n        ]\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + eps)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n) - 0.5) * jitter\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-12, 'maxiter':10000, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    xs, fits = [], []\n    xbest, fbest = optimize_once(x0, seed=0, jitter=0.0)\n    xs.append(xbest); fits.append(fbest)\n    jitters = [0.005, 0.010, 0.015, 0.020, 0.030, 0.040, 0.050, 0.060]\n    for idx, jit in enumerate(jitters):\n        xtry, ftry = optimize_once(xbest, seed=200+idx, jitter=jit)\n        xs.append(xtry); fits.append(ftry)\n    ib = int(np.argmax(fits))\n    xopt = xs[ib]\n    centers = xopt[:2*n].reshape(n,2)\n    radii   = xopt[2*n:]\n\n    def inflate(centers, radii, iterations=20, eps=1e-9):\n        n = len(radii)\n        for _ in range(iterations):\n            for i in range(n):\n                x_i, y_i = centers[i]\n                r_max = min(x_i, 1-x_i, y_i, 1-y_i)\n                for j in range(n):\n                    if i == j: continue\n                    d = np.hypot(x_i-centers[j,0], y_i-centers[j,1]) - radii[j]\n                    if d < r_max:\n                        r_max = d\n                radii[i] = max(radii[i], max(0.0, r_max - eps))\n        return radii\n\n    radii = inflate(centers, radii, iterations=20)\n\n    A = []\n    b = []\n    for i in range(n):\n        xi, yi = centers[i]\n        bound_i = min(xi,1-xi,yi,1-yi)\n        row = np.zeros(n)\n        row[i] = 1\n        A.append(row); b.append(bound_i)\n    for i in range(n):\n        for j in range(i+1, n):\n            d = np.hypot(centers[i,0]-centers[j,0], centers[i,1]-centers[j,1])\n            row = np.zeros(n)\n            row[i] = 1; row[j] = 1\n            A.append(row); b.append(d)\n    A = np.array(A); b = np.array(b)\n    res_lp = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                     bounds=[(0,None)]*n, method='highs')\n    if res_lp.success:\n        radii = res_lp.x\n\n    sum_radii = float(np.sum(radii))\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.6306949349088207,
      "additional_data": {
        "sum_radii": "2.630695",
        "target_ratio": "0.998366",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 83,
    "parent_id": 55,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import basinhopping, minimize\n\ndef run_packing():\n    n = 26\n\n    # improved hexagonal close-packed initialization with smaller noise\n    def hex_coords(num, r_min=0.03):\n        rows = [4,6,6,6,4]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows) - 1)\n        dy = (1 - 2*r_min) / (len(rows) - 1)\n        y = r_min\n        for nrow in rows:\n            offset = (max(rows) - nrow) / 2 * dx\n            for j in range(nrow):\n                coords.append([r_min + offset + j*dx, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    centers0 = hex_coords(n)\n    np.random.seed(42)\n    centers0 += (np.random.rand(n,2) - 0.5) * 0.015   # smaller random kick to reduce initial overlaps\n    radii0 = np.full(n, 0.032)  # starting just barely touching for most dense config\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    # Tighten radius bounds to avoid optimizer choosing impossible radii\n    bounds = [(0,1)]*(2*n) + [(0.005,0.08)]*n\n\n    # penalized objective: maximize sum(r) minus heavy penalty for overlaps/outside\n    def obj(x):\n        c = x[:2*n].reshape(n,2)\n        r = x[2*n:]\n        sumr = np.sum(r)\n        # outside-square penalty\n        dxl = r - c[:,0]; dxh = c[:,0] + r - 1\n        dyl = r - c[:,1]; dyh = c[:,1] + r - 1\n        pen = np.sum(np.clip(dxl,0,None)**2 + np.clip(dxh,0,None)**2 +\n                     np.clip(dyl,0,None)**2 + np.clip(dyh,0,None)**2)\n        # overlap penalty (increased to 2e4)\n        XX = c[:,0][:,None] - c[:,0][None,:]\n        YY = c[:,1][:,None] - c[:,1][None,:]\n        D = np.sqrt(XX**2 + YY**2)\n        Rsum = r[:,None] + r[None,:]\n        mask = (Rsum > D) & (np.eye(n)==0)\n        pen += np.sum((Rsum[mask] - D[mask])**2) * 1.5e4\n        return -sumr + pen\n\n    minimizer_kwargs = {\n        \"method\": \"L-BFGS-B\",\n        \"bounds\": bounds,\n        \"options\": {\"ftol\":1e-5, \"maxiter\":500}\n    }\n\n    # modestly increase global search steps\n    bh = basinhopping(obj, x0,\n                      minimizer_kwargs=minimizer_kwargs,\n                      niter=30, T=1.0, stepsize=0.02,\n                      disp=False)\n    x_best = bh.x\n\n    # final local polish with SLSQP under explicit constraints, as before\n    cons = []\n    slack = 1e-8\n    for i in range(n):\n        cons += [\n            {'type':'ineq', 'fun': lambda x,i=i: x[2*n + i] - x[2*i]},\n            {'type':'ineq', 'fun': lambda x,i=i: 1 - x[2*i] - x[2*n + i]},\n            {'type':'ineq', 'fun': lambda x,i=i: x[2*i+1] - x[2*n + i]},\n            {'type':'ineq', 'fun': lambda x,i=i: 1 - x[2*i+1] - x[2*n + i]}\n        ]\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type':'ineq',\n                'fun': lambda x,i=i,j=j: np.hypot(\n                    x[2*i] - x[2*j], x[2*i+1] - x[2*j+1]\n                ) - (x[2*n+i] + x[2*n+j] + slack)\n            })\n\n    def obj2(x):\n        return -np.sum(x[2*n:])\n    res2 = minimize(obj2, x_best, method='SLSQP',\n                    constraints=cons,\n                    options={'ftol':1e-8, 'maxiter':600})\n    x_final = res2.x if res2.success else x_best\n\n    centers = x_final[:2*n].reshape((n,2))\n    radii = x_final[2*n:]\n    sum_radii = float(np.sum(radii))\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "invalid",
        "error": "Invalid packing (overlaps or out of bounds)"
      }
    }
  },
  {
    "id": 84,
    "parent_id": 12,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Small iterative improvement:\n    - More radii reduction passes\n    - Slightly larger initial radii\n    - Shrink only the larger-radius circle in overlapping pairs\n    - Place the last circle in the top-right corner for best utilization\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # Inner ring of 8 circles\n    inner_ring_r = 0.25\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n    \n    # Outer ring of 16 circles\n    outer_ring_r = 0.40\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n    \n    # Place last circle in a corner (top-right), as close to (1,1) as possible\n    # We will pick an initial guess for the radius and shift it inwards by its value\n    init_r = 0.075\n    centers[25] = [1 - init_r, 1 - init_r]\n\n    # Initialize radii to a slightly larger guess\n    radii = np.ones(n) * 0.075\n    \n    # First pass: border limit\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n    \n    # Increase the number of passes\n    for _ in range(8):\n        # For all pairs, check overlap and adjust\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = centers[i] - centers[j]\n                d = np.hypot(dx, dy)\n                if d < 1e-12:\n                    # practically coincident: shrink both\n                    s = 0.5\n                    radii[i] *= s\n                    radii[j] *= s\n                else:\n                    overlap = (radii[i] + radii[j]) - d\n                    if overlap > 0:\n                        # Only shrink the larger circle\n                        if radii[i] > radii[j]:\n                            # shrink radii[i]\n                            s = ((d * 0.98) - radii[j]) / radii[i]\n                            s = max(s, 0.5)\n                            radii[i] *= s\n                        else:\n                            s = ((d * 0.98) - radii[i]) / radii[j]\n                            s = max(s, 0.5)\n                            radii[j] *= s\n        # After each pass, restore border constraint\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = max(0, min(radii[i], x, y, 1 - x, 1 - y))\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.9469999999999996,
      "additional_data": {
        "sum_radii": "1.947000",
        "target_ratio": "0.738899",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 85,
    "parent_id": 82,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    n = 26\n\n    def alt_hex_coords(num, r_min=0.0375):\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx % 2 else 0) + (max(rows)-nrow)/2 * dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    r0 = 0.0357  # slightly smaller than before\n    r_min_grid = r0 + 0.0022  # slightly smaller than before\n    centers0 = alt_hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    cons = []\n    eps = 1e-6\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.0075},    # Just slightly lower\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.16 - x[2*n+i]},\n        ]\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + eps)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n) - 0.5) * jitter\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-12, 'maxiter':12000, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    xs, fits = [], []\n    xbest, fbest = optimize_once(x0, seed=0, jitter=0.0)\n    xs.append(xbest); fits.append(fbest)\n    jitters = [0.0025, 0.005, 0.0075, 0.010, 0.013, 0.016, 0.019, 0.021, 0.025, 0.030, 0.040, 0.050, 0.060, 0.090]\n    for idx, jit in enumerate(jitters):\n        xtry, ftry = optimize_once(xbest, seed=300+idx, jitter=jit)\n        xs.append(xtry); fits.append(ftry)\n    ib = int(np.argmax(fits))\n    xopt = xs[ib]\n    centers = xopt[:2*n].reshape(n,2)\n    radii   = xopt[2*n:]\n\n    def inflate(centers, radii, iterations=20, eps=1e-10):\n        n = len(radii)\n        radii = radii.copy()\n        for _ in range(iterations):\n            for i in range(n):\n                x_i, y_i = centers[i]\n                r_max = min(x_i, 1-x_i, y_i, 1-y_i)\n                for j in range(n):\n                    if i == j: continue\n                    d = np.hypot(x_i-centers[j,0], y_i-centers[j,1]) - radii[j]\n                    if d < r_max:\n                        r_max = d\n                radii[i] = max(radii[i], max(0.0, r_max - eps))\n        return radii\n\n    radii = inflate(centers, radii, iterations=24)\n\n    # LP phase\n    A = []\n    b = []\n    for i in range(n):\n        xi, yi = centers[i]\n        bound_i = min(xi,1-xi,yi,1-yi)\n        row = np.zeros(n)\n        row[i] = 1\n        A.append(row); b.append(bound_i)\n    for i in range(n):\n        for j in range(i+1, n):\n            d = np.hypot(centers[i,0]-centers[j,0], centers[i,1]-centers[j,1])\n            row = np.zeros(n)\n            row[i] = 1; row[j] = 1\n            A.append(row); b.append(d)\n    A = np.array(A",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 86,
    "parent_id": 82,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    n = 26\n\n    # 5 concentric rows, hex pattern, variable density\n    def alt_hex_coords(num, r_min=0.037):\n        # More space towards the edges\n        rows = [6,5,5,5,5]  # From earlier\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx % 2 else 0) + (max(rows)-nrow)/2 * dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    r0 = 0.0372\n    r_min_grid = r0 + 0.001\n    centers0 = alt_hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    cons = []\n    eps = 1e-8\n    # Boundary and minimal/maximal radius constraints\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.006},  # allow smaller min radius\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.16 - x[2*n+i]},\n        ]\n    # Overlap constraints\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + eps)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n) - 0.5) * jitter\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-13, 'maxiter':15000, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    xs, fits = [], []\n    xbest, fbest = optimize_once(x0, seed=0, jitter=0.0)\n    xs.append(xbest); fits.append(fbest)\n    jitters = [0.004, 0.008, 0.012, 0.016, 0.022, 0.030, 0.038, 0.052, 0.065]\n    for idx, jit in enumerate(jitters):\n        xtry, ftry = optimize_once(xbest, seed=200+idx, jitter=jit)\n        xs.append(xtry); fits.append(ftry)\n    ib = int(np.argmax(fits))\n    xopt = xs[ib]\n    centers = xopt[:2*n].reshape(n,2)\n    radii   = xopt[2*n:]\n\n    # Greedy inflation in-place\n    def inflate(centers, radii, iterations=15, eps=1e-10):\n        n = len(radii)\n        idxs = np.arange(n)\n        for _ in range(iterations):\n            np.random.shuffle(idxs)\n            for idx in idxs:\n                x_i, y_i = centers[idx]\n                # Boundary\n                r_max = min(x_i, 1-x_i, y_i, 1-y_i)\n                # Separation to all other circles\n                for j in range(n):\n                    if idx == j: continue\n                    d = np.hypot(x_i-centers[j,0], y_i-centers[j,1]) - radii[j]\n                    if d < r_max:\n                        r_max = d\n                radii[idx] = max(radii[idx], max(0.0, r_max-eps))\n        return radii\n\n    radii = inflate(centers, radii, iterations=15)\n    \n    # LP inflation (as before, but allow tiny negatives), then an extra inflation pass\n    A = []\n    b = []\n    for i in range(n):\n        xi, yi = centers[i]\n        bound_i = min(xi,1-xi,yi,1-yi)\n        row = np.zeros(n)\n        row[i] = 1\n        A.append(row); b.append(bound_i)\n    for i in range(n):\n        for j in range(i+1, n):\n            d = np.h",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: module 'numpy' has no attribute 'h'"
      }
    }
  },
  {
    "id": 87,
    "parent_id": 1,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef generate_initial_centers_radii(n):\n    \"\"\"\n    Lay down n points in a roughly hexagonal grid inside unit square,\n    jittered, with a small initial radius for each.\n    \"\"\"\n    # Determine roughly square grid\n    rows = int(np.ceil(np.sqrt(n * (2/np.sqrt(3)))))\n    cols = int(np.ceil(n / rows))\n    dy = 1.0 / (rows + 1)\n    dx = 1.0 / (cols + 1)\n    centers = []\n    for i in range(rows):\n        for j in range(cols):\n            # Offset every other row for hexagonal packing\n            x = (j + 1) * dx\n            y = (i + 1) * dy\n            if i % 2 == 1:\n                x += dx / 2\n            if 0 <= x <= 1 and 0 <= y <= 1:\n                centers.append([x, y])\n    centers = np.array(centers)\n    # Select n closest to center if oversupplied\n    if len(centers) > n:\n        dists = np.linalg.norm(centers - 0.5, axis=1)\n        idx = np.argsort(dists)[:n]\n        centers = centers[idx]\n    elif len(centers) < n:\n        # Randomly add to reach n\n        add = n - len(centers)\n        while add > 0:\n            candidate = np.random.rand(2) * 0.8 + 0.1\n            centers = np.vstack([centers, candidate])\n            add -= 1\n    radii = np.full(n, 0.03)\n    return centers, radii\n\ndef pack_objective(x, n):\n    # x: [x0, y0, r0, x1, y1, r1, ...]\n    radii = x[2::3]\n    return -np.sum(radii)  # maximize sum of radii\n\ndef pack_constraints(x, n):\n    cons = []\n    for i in range(n):\n        xi, yi, ri = x[3*i], x[3*i+1], x[3*i+2]\n        # Bounds to stay within unit square\n        cons.append({'type':'ineq', 'fun': lambda z, i=i: z[3*i] - z[3*i+2]})      # x - r >= 0\n        cons.append({'type':'ineq', 'fun': lambda z, i=i: 1 - (z[3*i] + z[3*i+2])}) # x + r <= 1\n        cons.append({'type':'ineq', 'fun': lambda z, i=i: z[3*i+1] - z[3*i+2]})    # y - r >= 0\n        cons.append({'type':'ineq', 'fun': lambda z, i=i: 1 - (z[3*i+1] + z[3*i+2])}) # y + r <= 1\n        cons.append({'type':'ineq', 'fun': lambda z, i=i: z[3*i+2]})       # r >= 0\n        cons.append({'type':'ineq', 'fun': lambda z, i=i: 0.017 - (z[3*i+2] - 0) }) # r <= 0.017 (loosen for search)\n        # realistically, let optimizer go higher\n    # Non-overlap for all i < j\n    for i in range(n):\n        xi, yi = x[3*i], x[3*i+1]\n        ri = x[3*i+2]\n        for j in range(i+1,n):\n            xj, yj = x[3*j], x[3*j+1]\n            rj = x[3*j+2]\n            cons.append({\n                'type':'ineq',\n                'fun': lambda z, i=i, j=j: \n                    np.sqrt((z[3*i] - z[3*j])**2 + (z[3*i+1] - z[3*j+1])**2) \n                    - (z[3*i+2] + z[3*j+2]) + 1e-5 # small tolerance\n            })\n    return cons\n\ndef run_packing():\n    n_circles = 26\n\n    # Hex-grid initialization ensures feasible start\n    centers, radii_init = generate_initial_centers_radii(n_circles)\n    x0 = np.zeros(n_circles*3)\n    x0[0::3] = centers[:,0]\n    x0[1::3] = centers[:,1]\n    x0[2::3] = radii_init\n\n    bnds = []\n    for i in range(n_circles):\n        # x in [0,1], y in [0,1], r in [0,0.17]\n        bnds.append((0,1)) # x\n        bnds.append((0,1)) # y\n        bnds.append((0.008, 0.20)) # r: lower >0 for numerical stability\n    bnds = tuple(bnds)\n\n    cons = pack_constraints(x0, n_circles)\n\n    result = minimize(lambda x: pack_objective(x, n_circles), x0, \n                     method='SLSQP',\n                     bounds=bnds,\n                     constraints=cons, \n                     options={'ftol':1e-7, 'maxiter':700, 'disp':False})\n\n    x = result.x\n    centers = np.stack((x[0::3], x[1::3]), axis=-1)\n    radii = x[2::3]\n    \n    # Final feasibility check: all inside, all non-overlapping\n    ok = True\n    for i in range",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 88,
    "parent_id": 15,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef initial_hexgrid(n, margin=0.025):\n    \"\"\"\n    Place n centers in an approximate optimal hexagonal grid inside unit square.\n    Returns:\n        centers: (n,2) array\n    \"\"\"\n    best_diff = 1e9\n    best_rows, best_cols = None, None\n    for rows in range(4, 9):\n        cols = int(np.ceil(n / rows))\n        diff = abs(rows - cols * np.sqrt(3)/2)\n        if diff < best_diff:\n            best_diff, best_rows, best_cols = diff, rows, cols\n    rows, cols = best_rows, best_cols\n\n    dy = (1 - 2*margin) / (rows - 1)\n    dx = (1 - 2*margin) / (cols - 1) if cols > 1 else 0.5\n    centers = []\n    for r in range(rows):\n        y = margin + r * dy\n        shift = 0.5*dx if r % 2 == 1 and cols > 1 else 0\n        c_this = cols - (1 if (r%2==1 and n%2==1 and n%cols!=0) else 0)\n        for c in range(cols):\n            x = margin + c * dx + shift\n            if 0 <= x <= 1 and 0 <= y <= 1:\n                centers.append([x, y])\n    centers = np.array(centers)\n    if len(centers) > n:  # Trim to n\n        centers = centers[:n]\n    elif len(centers) < n:  # Add some random ones\n        extra = n - len(centers)\n        extras = margin + (1-2*margin)*np.random.rand(extra,2)\n        centers = np.vstack([centers, extras])\n    return centers\n\ndef pack_objective(x, n):\n    # x: 3n array: [x1,y1,r1, ..., xn,yn,rn]\n    radii = x[2::3]\n    # We want to maximize sum radii, so minimize negative sum\n    return -np.sum(radii)\n\ndef gen_constraints(n):\n    constraints = []\n    # Inside square:\n    def make_in_square(idx):\n        return [\n            {'type':'ineq', 'fun': lambda x, idx=idx: x[3*idx]     - x[3*idx+2]},  # x - r >= 0\n            {'type':'ineq', 'fun': lambda x, idx=idx: 1 - x[3*idx] - x[3*idx+2]}, # 1-x - r >= 0\n            {'type':'ineq', 'fun': lambda x, idx=idx: x[3*idx+1]   - x[3*idx+2]}, # y - r >= 0\n            {'type':'ineq', 'fun': lambda x, idx=idx: 1 - x[3*idx+1] - x[3*idx+2]},# 1-y - r >= 0\n            {'type':'ineq', 'fun': lambda x, idx=idx: x[3*idx+2]}, # r >= 0\n            {'type':'ineq', 'fun': lambda x, idx=idx: 0.27 - x[3*idx+2]} # r <= 0.27\n        ]\n    # Nonoverlap:\n    def make_nonoverlap(i,j):\n        return {\n            'type':'ineq',\n            'fun': lambda x, i=i, j=j: (\n                np.linalg.norm(x[3*i:3*i+2] - x[3*j:3*j+2]) - (x[3*i+2] + x[3*j+2]) + 1e-7\n            )\n        }\n    # All constraints:\n    for idx in range(n):\n        constraints += make_in_square(idx)\n    for i in range(n):\n        for j in range(i+1, n):\n            constraints.append(make_nonoverlap(i,j))\n    return constraints\n\ndef greedy_inflate(centers, radii, max_iter=6):\n    n = len(radii)\n    for _ in range(max_iter):\n        for i in range(n):\n            max_r = 1.0\n            # To boundary\n            max_r = min(max_r, centers[i,0], 1-centers[i,0], centers[i,1], 1-centers[i,1])\n            # To other circles\n            for j in range(n):\n                if i == j: continue\n                d = np.linalg.norm(centers[i]-centers[j])\n                if d <= 1e-12: continue\n                max_r = min(max_r, d - radii[j])\n            radii[i] = max(min(max_r-1e-8, 0.28), 0.004) # upper bound for safety\n    return radii\n\ndef run_packing():\n    np.random.seed(1234)  # reproducible\n    n = 26\n    margin = 0.025\n\n    # --- Initial guess: hex grid, initial radii ---\n    centers0 = initial_hexgrid(n, margin=margin)\n    centers0 += (np.random.rand(n,2)-0.5)*0.012\n    # Initial radii: distance to closest wall, minus a bit\n    wall_dists = np.min([\n        centers0[:,0], 1-centers0[:,0],\n        centers0[:,1], 1-centers0[:,1]\n    ], axis=0)\n    radii0 = np.clip(wall_dists - 2e-2, 0.01, 0.13)\n    x0 = np.zeros(3*n)\n    x0[::3] = centers0[:,0]\n    x0[1::3] = centers0[:,1]\n    x0[2::3] = radii0\n\n    # --- Constraints ---\n    constraints = gen_constraints",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 89,
    "parent_id": 38,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n    S = 1.0\n    min_radius = 0.006  # allow optimizer some flexibility to shrink circles if needed\n\n    # Generate initial positions using a hexagonal close packing, then trim if too many\n    def hex_pack(n, offset=0.07):\n        # estimate rows needed\n        for rows in range(6, 20):\n            max_in_row = rows\n            total = 0\n            for i in range(rows):\n                # alternate row lengths for hex packing\n                rowlen = max_in_row if i % 2 == 0 else max_in_row - 1\n                total += rowlen\n            if total >= n:\n                break\n        coords = []\n        rad = (S - 2*offset) / (rows + 0.5)\n        for i in range(rows):\n            y = offset + rad + i * rad\n            rowlen = max_in_row if i%2==0 else max_in_row-1\n            x_start = offset + rad + (0 if i%2==0 else rad/1.5)\n            for j in range(rowlen):\n                x = x_start + j * rad\n                if x + rad > S-offset: break\n                coords.append((x, y))\n                if len(coords) >= n: return np.array(coords)\n            if len(coords) >= n: return np.array(coords)\n        return np.array(coords)\n\n    # Seed positions\n    seed_centers = hex_pack(n, offset=0.04)\n    if seed_centers.shape[0] < n:  # fallback: random\n        seed_centers = np.random.uniform(0.12, 0.88, size=(n,2))\n\n    # Initial radii (fairly large to encourage tight packing)\n    init_r = 0.035 * np.ones(n)\n\n    # Form variable: x0\n    # x0[:n] = x coords, x0[n:2n] = y coords, x0[2n:] = radii\n    x0 = np.concatenate([seed_centers[:,0], seed_centers[:,1], init_r])\n\n    # Bounds for each variable\n    bnds = []\n    for i in range(n):\n        # x\n        bnds.append( (0.0, S) )\n    for i in range(n):\n        # y\n        bnds.append( (0.0, S) )\n    for i in range(n):\n        # radii\n        bnds.append( (min_radius, S*0.30) )\n\n    # Constraints:\n    cons = []\n\n    # All circles fully inside\n    for i in range(n):\n        # x[i] - r[i] >= 0  <==> r[i] <= x[i]\n        # x[i] + r[i] <= 1  <==> r[i] <= 1-x[i]\n        # (similarly for y)\n        def c_left(x, i=i):\n            return x[i] - x[2*n + i]\n        def c_right(x, i=i):\n            return (S - x[i]) - x[2*n + i]\n        def c_bottom(x, i=i):\n            return x[n + i] - x[2*n + i]\n        def c_top(x, i=i):\n            return (S - x[n + i]) - x[2*n + i]\n        cons.append( {'type':'ineq', 'fun':c_left} )\n        cons.append( {'type':'ineq', 'fun':c_right} )\n        cons.append( {'type':'ineq', 'fun':c_bottom} )\n        cons.append( {'type':'ineq', 'fun':c_top} )\n\n    # No overlap constraints (for all i<j)\n    def cons_no_overlap_factory(i, j):\n        def c(x):\n            xi, yi, ri = x[i], x[n+i], x[2*n+i]\n            xj, yj, rj = x[j], x[n+j], x[2*n+j]\n            d2 = (xi-xj)**2 + (yi-yj)**2\n            min_dist2 = (ri + rj)**2 + 1e-7  # small fudge factor for numerical issues\n            return d2 - min_dist2\n        return c\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append( {'type':'ineq', 'fun':cons_no_overlap_factory(i,j)} )\n\n    # Objective: maximize sum(radii)\n    def objective(x):\n        # negative since we minimize\n        return -np.sum(x[2*n:])\n\n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n\n    # We'll use several random restarts, because this is a hard nonconvex opt problem!\n    # Each time, tiny jitter on positions and radii.\n    n_restarts = 7\n    for trial in range(n_restarts):\n        jitter = np.random.normal(size=(n,2))*0.01\n        start_r = init_r * (1 + np.random.normal(size=n)*0.08)\n        xstart = np.concatenate([\n            np.clip(seed_centers[:,0] + jitter[:,0], 0.08, 0.92),\n            np.clip(seed_centers[:,1] + jitter[:,1], 0.08, 0.92),\n            np.maximum(start_r, min_radius+3e-4)\n        ])\n\n        res = minimize(objective, xstart, method='SLSQP', bounds=bnds,\n                       constraints=cons, options={'ftol':1e-9, 'disp': False, 'maxiter': 1550})\n\n        xopt = res.x\n        radii = xopt[2*n:]\n        centers = np.stack( [xopt[:n], xopt[n:2*n]], axis=1 )\n        sumr = np.sum(radii)\n        if (res.success) and (sumr > best_sum + 1e-7):\n            #",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 90,
    "parent_id": 82,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    n = 26\n\n    # Small randomization of hex grid to break symmetry\n    def alt_hex_coords(num, r_min=0.0385, jitter=0.003, seed=47):\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        rng = np.random.RandomState(seed)\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx % 2 else 0) + (max(rows)-nrow)/2 * dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                # Add small jitter to improve symmetry-breaking\n                coords.append([\n                    x + (rng.rand()-0.5)*jitter,\n                    y + (rng.rand()-0.5)*jitter\n                ])\n            y += dy\n        return np.array(coords)[:num]\n\n    r0 = 0.0365\n    r_min_grid = r0 + 0.0025\n    centers0 = alt_hex_coords(n, r_min=r_min_grid, jitter=0.003)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    # Constraints (unchanged)\n    cons = []\n    eps = 1e-6\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.008},\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.16 - x[2*n+i]},\n        ]\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + eps)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n) - 0.5) * jitter\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-12, 'maxiter':6000, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    xs, fits = [], []\n    xbest, fbest = optimize_once(x0, seed=0, jitter=0.002)\n    xs.append(xbest); fits.append(fbest)\n    jitters = [0.005, 0.010, 0.015, 0.020, 0.030, 0.040, 0.050, 0.060]\n    for idx, jit in enumerate(jitters):\n        xtry, ftry = optimize_once(xbest, seed=200+idx, jitter=jit)\n        xs.append(xtry); fits.append(ftry)\n    ib = int(np.argmax(fits))\n    xopt = xs[ib]\n    centers = xopt[:2*n].reshape(n,2)\n    radii   = xopt[2*n:]\n\n    # Improved inflation: Use LP for radii, repeat iteratively with fixed centers\n    def global_inflate(centers, radii_old=None, n_pass=15):\n        radii = np.copy(radii_old) if radii_old is not None else np.copy(radii)\n        for _ in range(n_pass):\n            A = []\n            b = []\n            for i in range(n):\n                xi, yi = centers[i]\n                bound_i = min(xi,1-xi,yi,1-yi)\n                row = np.zeros(n)\n                row[i] = 1\n                A.append(row); b.append(bound_i)\n            for i in range(n):\n                for j in range(i+1, n):\n                    d = np.hypot(centers[i,0]-centers[j,0], centers[i,1]-centers[j,1])\n                    row = np.zeros(n)\n                    row[i] = 1; row[j] = 1\n                    A.append(row); b.append(d)\n            A = np.array(A); b = np.array(b)\n            res_lp = linprog(-np.ones(n), A_ub=A, b_ub=b,\n                             bounds=[(0.008,0.16)]*n, method='highs')\n            if res_lp.success:\n                # Add tiny eps for safety\n                radii = np.maximum(0.0, res_lp.x - 1e-10)\n            else:\n                break\n        return radii\n\n    radii =",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 91,
    "parent_id": 7,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Slight iterative improvement on previous approach:\n    - Outermost ring nudged outward using available border, then clipped slightly closer to the wall.\n    - Border-allowed radius recalculated each time, allowing for circles getting slightly closer to the boundary.\n    - Slightly increased max_rad.\n    - More optimization passes.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    \n    # Central circle\n    centers[0] = [0.5, 0.5]\n    \n    # First ring of 8 circles (radius 0.25)\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n    \n    # Outermost ring (radius 0.41 instead of 0.4) -- nudge outward modestly\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.41 * np.cos(angle), 0.5 + 0.41 * np.sin(angle)]\n    \n    # Topmost extra circle (keep as in original)\n    centers[25] = [0.5, 0.85]\n    \n    # Allow even closer to borders for further densification\n    centers = np.clip(centers, 0.06, 0.94)\n    \n    # Initial slightly larger radii\n    radii = np.ones(n) * 0.055  # up slightly\n    \n    # Increased max allowed\n    max_rad = 0.09\n    # Iteratively adjust radii\n    for outer in range(32):  # More passes\n        for i in range(n):\n            x, y = centers[i]\n            # Distance to each border\n            border_dist = min(x, y, 1 - x, 1 - y)\n            # Local max radius at this center\n            radii[i] = min(radii[i], border_dist, max_rad)\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                # Safety factor slightly decreased for tighter packing\n                safefac = 0.96\n                if radii[i] + radii[j] > dist * safefac:\n                    scale = (dist * safefac) / (radii[i] + radii[j])\n                    radii[i] *= scale\n                    radii[j] *= scale\n        # Re-clamp to wall after shrinkage\n        for i in range(n):\n            x, y = centers[i]\n            border_dist = min(x, y, 1 - x, 1 - y)\n            radii[i] = min(radii[i], border_dist, max_rad)\n    \n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.3706,
      "additional_data": {
        "sum_radii": "1.370600",
        "target_ratio": "0.520152",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 92,
    "parent_id": 56,
    "solution": "\nimport numpy as np\n\ndef run_packing():\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Central circle\n    centers[0] = [0.5, 0.5]\n\n    # Inner ring of 8 circles\n    inner_ring_r = 0.26\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + inner_ring_r * np.cos(angle), 0.5 + inner_ring_r * np.sin(angle)]\n\n    # Outer ring of 16 circles\n    outer_ring_r = 0.39\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + outer_ring_r * np.cos(angle), 0.5 + outer_ring_r * np.sin(angle)]\n\n    # One additional circle near bottom edge\n    corner_idx = 25\n    centers[corner_idx] = [0.5, 0.085]\n\n    # Initial radii\n    radii = np.ones(n) * 0.073\n    radii[0] = 0.086\n    radii[1:9] = 0.076\n    radii[9:25] = 0.070\n    radii[corner_idx] = 0.074\n\n    # Enforce border constraints initially\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    # Iterative shrink-relax passes\n    passes = 20\n    for _ in range(passes):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = centers[i] - centers[j]\n                d = np.hypot(dx, dy)\n                if d < 1e-12:\n                    s = 0.5\n                else:\n                    s = min(1.0, (d * 0.995) / (radii[i] + radii[j]))\n                if s < 1.0:\n                    mean = (radii[i] + radii[j]) * 0.5\n                    radii[i] = mean * s\n                    radii[j] = mean * s\n        # Border constraint after each pass\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    # Final border cleanup\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    # Greedy local enlargement (more passes!)\n    for _ in range(8):\n        for i in range(n):\n            xi, yi = centers[i]\n            max_r = min(xi, yi, 1 - xi, 1 - yi)\n            for j in range(n):\n                if j == i: continue\n                dx, dy = xi - centers[j,0], yi - centers[j,1]\n                dij = np.hypot(dx, dy)\n                max_r = min(max_r, dij - radii[j])\n            if max_r > radii[i]:\n                radii[i] = max_r\n\n    # Final max-radius assignment per circle (one more pass)\n    for i in range(n):\n        xi, yi = centers[i]\n        max_r = min(xi, yi, 1 - xi, 1 - yi)\n        for j in range(n):\n            if j == i: continue\n            dx, dy = xi - centers[j,0], yi - centers[j,1]\n            dij = np.hypot(dx, dy)\n            max_r = min(max_r, dij - radii[j])\n        radii[i] = max(0.0, min(radii[i], max_r))\n\n    sum_radii = np.sum(radii)\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 1.889763609380641,
      "additional_data": {
        "sum_radii": "1.889764",
        "target_ratio": "0.717178",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 93,
    "parent_id": 21,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n    # Parameters of hex packing in square (approximate, adjusted for square)\n    # Arranging as 4 rows: 7, 6, 7, 6 = 26\n    rows = [7,6,7,6]\n    y_pad = 0.04\n    x_pad = 0.04\n    total_height = 1 - 2*y_pad\n    row_gaps = total_height/(len(rows)-1)\n    centers = []\n\n    for i, n_c in enumerate(rows):\n        y = y_pad + i*row_gaps\n        # 'hex offset' for even/odd rows for close packing\n        x_start = x_pad + (0 if (i%2==0) else row_gaps/2)\n        total_width = 1 - 2*x_pad\n        if n_c == 1:\n            cx = 0.5\n            centers.append([cx, y])\n        else:\n            for j in range(n_c):\n                if n_c > 1:\n                    cx = x_pad + (total_width)*(j/(n_c-1))\n                else:\n                    cx = 0.5\n                centers.append([cx, y])\n    centers = np.array(centers)\n    assert centers.shape == (26,2)\n    \n    # Estimate maximal radii without overlap, initial\n    # Compute min pairwise distances\n    dists = np.array([np.sqrt((centers[i][0]-centers[j][0])**2 +\n                              (centers[i][1]-centers[j][1])**2)\n                      for i in range(n) for j in range(i+1, n)])\n    min_dist = np.min(dists)\n    # Further, at edge, center must stay inside; compute edge-limited radii\n    edge_radii = np.min( np.c_[\n        centers[:,0], 1 - centers[:,0],\n        centers[:,1], 1 - centers[:,1]\n    ], axis=1 )\n    # Conservative initial guess\n    r0 = np.minimum(edge_radii, min_dist/2) * 0.97\n    radii_init = r0\n\n    # Optimization variable: the 26 radii\n    x0 = radii_init.copy()\n\n    # --- Constraints ---\n\n    cons = []\n\n    # All radii positive and within square envelope at each center.\n    bounds = [(0.004, float(edge_radii[i])) for i in range(n)]\n\n    # Each circle within square\n    for i in range(n):\n        def con_left(r, i=i):    # x - r >= 0  =>  r <= x\n            return centers[i,0] - r[i]\n        def con_right(r, i=i):   # x + r <= 1  =>  r <= 1-x\n            return 1 - (centers[i,0] + r[i])\n        def con_bot(r, i=i):\n            return centers[i,1] - r[i]\n        def con_top(r, i=i):\n            return 1 - (centers[i,1] + r[i])\n        cons.append({'type':'ineq','fun':con_left})\n        cons.append({'type':'ineq','fun':con_right})\n        cons.append({'type':'ineq','fun':con_bot})\n        cons.append({'type':'ineq','fun':con_top})\n\n    # Non-overlap between all pairs\n    for i in range(n):\n        for j in range(i+1, n):\n            def con_nolap(r, i=i, j=j):\n                dx = centers[i,0] - centers[j,0]\n                dy = centers[i,1] - centers[j,1]\n                dist = np.sqrt(dx*dx + dy*dy)\n                return dist - (r[i] + r[j])\n            cons.append({'type':'ineq', 'fun': con_nolap})\n\n    def obj(r):\n        return -np.sum(r)\n\n    res = minimize(obj, x0, method='SLSQP', bounds=bounds, constraints=cons,\n                   options={'ftol':1e-8, 'disp':False, 'maxiter':2000})\n\n    r_opt = res.x\n    # Compute validity mask (circles inside, no overlap)\n    # (should be guaranteed by SLSQP)\n    centers_out = centers.copy()\n    radii_out = r_opt.copy()\n    sum_radii = np.sum(radii_out)\n\n    return centers_out, radii_out, float(sum_radii)\n",
    "evaluation": {
      "fitness": 1.4679999999999898,
      "additional_data": {
        "sum_radii": "1.468000",
        "target_ratio": "0.557116",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 94,
    "parent_id": 82,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    n = 26\n\n    def alt_hex_coords(num, r_min=0.0377):\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx % 2 else 0) + (max(rows)-nrow)/2 * dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    r0 = 0.0372  # slight increase\n    r_min_grid = r0 + 0.002  # slight reduction for more spread/overlap\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    seeds = [0, 42]  # try two seeds for initialization\n\n    for trial_seed in seeds:\n        np.random.seed(trial_seed)\n        centers0 = alt_hex_coords(n, r_min=r_min_grid)\n        # Jitter the initial coordinates a little to break symmetry\n        centers0 += (np.random.rand(n,2)-0.5)*0.012\n        radii0 = np.full(n, r0)\n        x0 = np.concatenate([centers0.flatten(), radii0])\n\n        cons = []\n        eps = 2e-6  # tighter constraints\n        for i in range(n):\n            cons += [\n                {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n                {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n                {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n                {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n                {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.0065},  # allow a slightly smaller min\n                {'type': 'ineq', 'fun': lambda x, i=i: 0.17 - x[2*n+i]},\n            ]\n        for i in range(n):\n            for j in range(i+1, n):\n                cons.append({\n                    'type': 'ineq',\n                    'fun': lambda x, i=i, j=j: (\n                        np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                        - (x[2*n+i] + x[2*n+j] + eps)\n                    )\n                })\n\n        def objective(x):\n            return -np.sum(x[2*n:])\n\n        def optimize_once(x0, seed=None, jitter=0.0):\n            xstart = x0.copy()\n            if seed is not None:\n                np.random.seed(seed)\n            if jitter > 0:\n                xstart[:2*n] += (np.random.rand(2*n) - 0.5) * jitter\n            res = minimize(\n                objective, xstart, constraints=cons, method='SLSQP',\n                options={'ftol':1e-13, 'maxiter':15000, 'disp':False}\n            )\n            if res.success:\n                return res.x, -res.fun\n            else:\n                return xstart, np.sum(xstart[2*n:])\n\n        # Run jittered optimizations in sequence, increasing jitter magnitude\n        xs, fits = [], []\n        xbest, fbest = optimize_once(x0, seed=100, jitter=0.0)\n        xs.append(xbest); fits.append(fbest)\n        jitters = [0.005, 0.012, 0.020, 0.027, 0.035, 0.045, 0.055, 0.065]\n        for idx, jit in enumerate(jitters):\n            xtry, ftry = optimize_once(xs[-1], seed=300+idx+2*trial_seed, jitter=jit)\n            xs.append(xtry); fits.append(ftry)\n        ib = int(np.argmax(fits))\n        xopt = xs[ib]\n        centers = xopt[:2*n].reshape(n,2)\n        radii   = xopt[2*n:]\n\n        # Spatial inflation routine (before LP, to unlock new packing possibilities by increasing tight circles)\n        def inflate(centers, radii, iterations=18, eps=1e-10):\n            n = len(radii)\n            for _ in range(iterations):\n                for i in range(n):\n                    x_i, y_i = centers[i]\n                    r_max = min(x_i, 1-x_i, y_i, 1-y_i)\n                    for",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 95,
    "parent_id": 82,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    n = 26\n    # Layered/shell constructive arrangement:\n    # - 4 corner circles\n    # - 8 edge circles (on midpoints and off-midpoints)\n    # - 4 near-corner edge circles\n    # - 10 inner (almost hex) circles\n\n    # Corner circles (large, maximize up to 0.5)\n    edge_margin = 0.10\n    r_corner = 0.088   #\u2020 room for corner+edge\n    corners = np.array([\n        [r_corner, r_corner],\n        [1 - r_corner, r_corner],\n        [1 - r_corner, 1 - r_corner],\n        [r_corner, 1 - r_corner]\n    ])\n\n    # Edge midpoints, bit inwards to leave room for corner circles\n    r_edge = 0.075\n    edge_pos = [\n        [0.5, r_edge], [0.5, 1-r_edge],    # bottom, top\n        [r_edge, 0.5], [1-r_edge,0.5]      # left, right\n    ]\n    # Off-midpoints for more edge circles\n    delta = 0.26\n    edge_more = [\n        [delta, r_edge], [1-delta, r_edge],\n        [delta, 1-r_edge], [1-delta, 1-r_edge],\n        [r_edge, delta], [r_edge, 1-delta],\n        [1-r_edge, delta], [1-r_edge, 1-delta]\n    ]\n\n    # Near-corner edge circle \"between\" corners and edge midpoints\n    near_corner_delta = 0.20\n    r_nc = 0.065\n    near_corners = [\n        [r_corner + (near_corner_delta - r_corner)/2, r_corner],\n        [1 - r_corner - (near_corner_delta - r_corner)/2, r_corner],\n        [r_corner, 1 - r_corner - (near_corner_delta - r_corner)/2],\n        [1 - r_corner, 1 - r_corner - (near_corner_delta - r_corner)/2],\n    ]\n\n    # 10 inner hexagonal grid points inside [0.2,0.8]^2\n    # Slightly perturb so not perfectly hex for better edge filling\n    r_inner = 0.047\n    inner_base = []\n    xs = [0.32, 0.5, 0.68]\n    ys = [0.32, 0.5, 0.68]\n    for xi in xs:\n        for yi in ys:\n            inner_base.append([xi, yi])\n    # Add points offset diagonally from (0.5,0.5) to get extra\n    r_diag = 0.14\n    for angle in np.linspace(0, 2*np.pi, 5)[:-1]:\n        inner_base.append([\n            0.5 + r_diag*np.cos(angle),\n            0.5 + r_diag*np.sin(angle)\n        ])\n    # That is 9+4=13, so remove one to get 10 (remove center-most)\n    dists = [np.hypot(x-0.5, y-0.5) for (x, y) in inner_base]\n    idx_c = np.argmin(dists)\n    del inner_base[idx_c]\n\n    centers = np.array(\n        corners +\n        edge_pos +\n        edge_more +\n        near_corners +\n        inner_base\n    )\n    assert len(centers) == n\n\n    # Initial radii based on layer\n    radii = np.zeros(n)\n    radii[ 0:4]  = r_corner\n    radii[ 4:8]  = r_edge\n    radii[ 8:16] = r_edge*0.95\n    radii[16:20] = r_nc\n    radii[20:]   = r_inner\n\n    # Slightly jitter to avoid symmetry grid-traps in SLSQP\n    centers += (np.random.rand(n,2)-0.5)*0.005\n\n    x0 = np.concatenate([centers.flatten(), radii])\n\n    # Constraints\n    cons = []\n    eps = 1e-7\n    # Stay inside square, positive radii\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},           # x - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: 1-x[2*i] - x[2*n+i]},           # 1-x - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},           # y - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: 1-x[2*i+1] - x[2*n+i]},         # 1-y - r >= 0\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.008},              # r >= 0.008\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.19 - x[2*n+i]},               # r <= 0.19 (arbitrary upper bound)\n        ]\n    # No overlap constraints\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({'type': 'ineq', 'fun': lambda x, i=i, j=j:\n                np.hypot(x[2*i]-x[2*j], x[2*i+1]-x[2*j+1]) - (x[2*n+i]+x[2*n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 96,
    "parent_id": 94,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    def alt_hex_coords(num, r_min=0.04):\n        # Slightly more balanced than previous: 6,6,5,5,4 = 26\n        rows = [6,6,5,5,4]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx % 2 else 0) + (max(rows)-nrow)/2 * dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    r0 = 0.0375  # ensure circles start with comfortable size\n    r_min_grid = r0 # grid buffer\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    seeds = [0, 42]\n\n    for trial_seed in seeds:\n        np.random.seed(trial_seed)\n        centers0 = alt_hex_coords(n, r_min=r_min_grid)\n        # Gentle jitter \u2013 less than before\n        centers0 += (np.random.rand(n,2) - 0.5) * 0.005\n        radii0 = np.full(n, r0)\n        x0 = np.concatenate([centers0.flatten(), radii0])\n\n        cons = []\n        eps = 1e-4  # Slightly relaxed for stability\n\n        # Box and radius constraints\n        for i in range(n):\n            cons += [\n                {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},    # x - r >= 0    (left)\n                {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},# 1-x - r >= 0 (right)\n                {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},    # y - r >= 0    (bottom)\n                {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},# 1-y - r >= 0 (top)\n                {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.012},        # r >= 0.012 (prevent near-0)\n                {'type': 'ineq', 'fun': lambda x, i=i: 0.17 - x[2*n+i]},\n            ]\n        # Pairwise distance non-overlap\n        for i in range(n):\n            for j in range(i+1, n):\n                cons.append({\n                    'type': 'ineq',\n                    'fun': lambda x, i=i, j=j: (\n                        np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                        - (x[2*n+i] + x[2*n+j] + eps)\n                    )\n                })\n\n        def objective(x):\n            return -np.sum(x[2*n:])\n\n        def check_valid(x):\n            # Return True if all constraints satisfied, else False\n            for con in cons:\n                if con['fun'](x) < -1e-7:\n                    return False\n            return True\n\n        # Main optimization\n        res = minimize(\n            objective, x0, constraints=cons, method='SLSQP',\n            options={'ftol':1e-10, 'maxiter':6000, 'disp':False}\n        )\n        res_x = res.x if res.success and check_valid(res.x) else x0\n        sum_radii = np.sum(res_x[2*n:])\n        # Save best result\n        if sum_radii > best_sum and check_valid(res_x):\n            best_sum = sum_radii\n            best_centers = res_x[:2*n].reshape(n,2)\n            best_radii = res_x[2*n:]\n\n    # Fallback if optimization fails: return initial grid\n    if best_centers is None or best_radii is None:\n        best_centers = alt_hex_coords(n, r_min=0.04)\n        best_radii = np.full(n, 0.035)\n        best_sum = best_radii.sum()\n\n    return best_centers, best_radii, float(best_sum)\n",
    "evaluation": {
      "fitness": 2.606630428552001,
      "additional_data": {
        "sum_radii": "2.606630",
        "target_ratio": "0.989234",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 97,
    "parent_id": 33,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef make_hex_grid(n, padding=0.048, seed=None):\n    \"\"\"\n    Generate n points in a nearly hexagonal lattice inside [0,1]x[0,1],\n    spread as evenly as possible.\n    \"\"\"\n    rows = 5\n    cols = 6\n    y = np.linspace(padding, 1-padding, rows)\n    x = np.linspace(padding, 1-padding, cols)\n    centers = []\n    for i in range(rows):\n        # Shift every other row for hex pattern\n        xrow = x.copy()\n        if i%2 == 1:\n            xrow += (x[1]-x[0])/2\n        # Remove out-of-bounds shifted points\n        row_centers = []\n        for xx in xrow:\n            if padding <= xx <= 1-padding:\n                row_centers.append(xx)\n        for xx in row_centers:\n            centers.append((xx,y[i]))\n    # Truncate or randomly sample if too many\n    if seed is not None:\n        np.random.seed(seed)\n    if len(centers) > n:\n        idx = np.random.choice(len(centers), n, replace=False)\n        centers = [centers[i] for i in idx]\n    elif len(centers) < n:\n        # Add random points to balance\n        for _ in range(n - len(centers)):\n            centers.append((padding + (1-2*padding)*np.random.rand(),\n                            padding + (1-2*padding)*np.random.rand()))\n    return np.array(centers)\n\ndef arrange_initial(n, padding=0.048, seed=None):\n    centers = make_hex_grid(n, padding=padding, seed=seed)\n    radii = np.ones(n) * 0.037\n    return centers, radii\n\ndef constraint_no_overlap(vars, n):\n    res = []\n    centers = vars[:-n].reshape((n,2))\n    radii = vars[-n:]\n    for i in range(n):\n        for j in range(i+1,n):\n            d = np.linalg.norm(centers[i]-centers[j])\n            res.append( d - (radii[i]+radii[j]) )\n    return np.array(res)\n\ndef constraint_in_square(vars, n):\n    centers = vars[:-n].reshape((n,2))\n    radii = vars[-n:]\n    res = []\n    x = centers[:,0]\n    y = centers[:,1]\n    res.extend( x - radii )         # >= 0\n    res.extend( 1 - (x + radii) )   # >= 0\n    res.extend( y - radii )         # >= 0\n    res.extend( 1 - (y + radii) )   # >= 0\n    return np.array(res)\n\ndef objective(vars, n):\n    radii = vars[-n:]\n    return -np.sum(radii)\n\ndef micro_perturb(x0, n, scale_center=0.001, scale_r=0.001):\n    x = x0.copy()\n    centers = x[:-n].reshape((n,2))\n    radii = x[-n:]\n    centers += np.random.uniform(-scale_center, scale_center, centers.shape)\n    radii *= (1 - np.abs(np.random.normal(0, scale_r, radii.shape)))\n    # Keep within [0,1] for centers and positive for radii\n    centers = np.clip(centers, 0.0, 1.0)\n    radii = np.clip(radii, 0.01, 0.22)\n    return np.concatenate([centers.ravel(), radii])\n\ndef run_packing():\n    n = 26\n    rmin = 0.01\n    rmax = 0.22\n    best_sum = -np.inf\n    best_centers = None\n    best_radii = None\n\n    # Try more seeds + micro perturbation\n    seeds = [0, 99, 123, 2021, 42, 301, 888, 555, 777, 17, 111, 67, 251, 404, 77]  # 15 runs\n    for seed in seeds:\n        centers, radii = arrange_initial(n, padding=0.048, seed=seed)\n        x0 = np.concatenate([centers.ravel(), radii])\n\n        # Bounds\n        bounds = []\n        for i in range(n):\n            bounds.append((0.0,1.0)) # x\n            bounds.append((0.0,1.0)) # y\n        for i in range(n):\n            bounds.append((rmin, rmax))\n\n        cons = [\n            {'type':'ineq','fun':constraint_no_overlap,'args':(n,)},\n            {'type':'ineq','fun':constraint_in_square,'args':(n,)}\n        ]\n\n        result = minimize(objective, x0, args=(n,),\n                          method='SLSQP',\n                          bounds=bounds,\n                          constraints=cons,\n                          options={'maxiter':2000,'ftol':1e-12,'disp':False})\n\n        if not result.success:\n            continue\n        xopt = result.x\n        centers_ = xopt[:-n].reshape((n,2))\n        radii_ = xopt[-n:]\n        sum_radii_ = np.sum(radii_)\n\n        # Micro perturb (small variance) + quick mini-optimization -- may break out of local trap\n        for _ in range(2):\n            xpert = micro_perturb(xopt, n, scale_center=0.00065, scale_r=0.00085)\n            res2 = minimize(objective, xpert, args=(n,),\n                        method='SLSQP',\n                        bounds",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Results file not found"
      }
    }
  },
  {
    "id": 98,
    "parent_id": 82,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    n = 26\n\n    def alt_hex_coords(num, r_min=0.0385):\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx % 2 else 0) + (max(rows)-nrow)/2 * dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    r0 = 0.0365\n    r_min_grid = r0 + 0.0025\n    centers0 = alt_hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    cons = []\n    eps = 1e-6\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.008},\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.16 - x[2*n+i]},\n        ]\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + eps)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n) - 0.5) * jitter\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-12, 'maxiter':10000, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    xs, fits = [], []\n    xbest, fbest = optimize_once(x0, seed=0, jitter=0.0)\n    xs.append(xbest); fits.append(fbest)\n    jitters = [0.005, 0.010, 0.015, 0.020, 0.030, 0.040, 0.050, 0.060]\n    for idx, jit in enumerate(jitters):\n        xtry, ftry = optimize_once(xbest, seed=200+idx, jitter=jit)\n        xs.append(xtry); fits.append(ftry)\n    ib = int(np.argmax(fits))\n    xopt = xs[ib]\n    centers = xopt[:2*n].reshape(n,2)\n    radii   = xopt[2*n:]\n\n    # --- Improved Inflate ---\n\n    def inflate(centers, radii, iterations=20, eps=1e-9):\n        n = len(radii)\n        radii = radii.copy()\n        for _ in range(iterations):\n            idxs = np.arange(n)\n            np.random.shuffle(idxs)\n            for i in idxs:\n                x_i, y_i = centers[i]\n                r_max = min(x_i, 1-x_i, y_i, 1-y_i)\n                for j in range(n):\n                    if i == j: continue\n                    d = np.hypot(x_i-centers[j,0], y_i-centers[j,1]) - radii[j]\n                    if d < r_max:\n                        r_max = d\n                radii[i] = max(radii[i], max(0.0, r_max - eps))\n        return radii\n\n    # --- LP Passes ---\n    def lp_radii(centers, radii):\n        A = []\n        b = []\n        for i in range(n):\n            xi, yi = centers[i]\n            bound_i = min(xi,1-xi,yi,1-yi)\n            row = np.zeros(n)\n            row[i] = 1\n            A.append(row);",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "error",
        "error": "Solution execution failed: cannot unpack non-iterable NoneType object"
      }
    }
  },
  {
    "id": 99,
    "parent_id": 49,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    # Initialize centers in a hexagonal grid as starting point, variable radii\n    def hex_pack(n, box=1.0, margin=0.05):\n        # Try to fit the desired number in as square grid of hex layers as possible\n        # We'll do (rows, cols) such that rows*cols >= n, \n        # alternating rows shifted (hex packing)\n        # Adjust the number empirically to match n\n        for rows in range(int(np.sqrt(n)), n+1):\n            for cols in range(rows, n+1):\n                if rows * cols >= n:\n                    step_y = (box - 2*margin) / (rows-1) if rows > 1 else 0\n                    step_x = (box - 2*margin) / (cols-1) if cols > 1 else 0\n                    points = []\n                    for i in range(rows):\n                        offset = 0.0\n                        if i % 2 == 1 and cols>1:\n                            offset = step_x / 2\n                        for j in range(cols):\n                            x = margin + j*step_x + offset\n                            y = margin + i*step_y\n                            if len(points) < n and x>0 and x<1 and y>0 and y<1:\n                                points.append([x,y])\n                    if len(points) >= n:\n                        return np.array(points[:n])\n        # fallback: random\n        return margin + (1-2*margin) * np.random.rand(n,2)\n\n    # Initial radii: estimate min-dist in grid, then shrink a bit\n    centers = hex_pack(n, box=1, margin=0.08)\n    dists = []\n    for i in range(n):\n        for j in range(i+1, n):\n            dists.append(np.linalg.norm(centers[i]-centers[j]))\n    approx_r = 0.4 * np.min(dists) # shrink to allow some flexibility\n    radii = np.full(n, approx_r)\n    # Add some random shift to avoid symmetry traps\n    centers = centers + 0.01*np.random.randn(*centers.shape)\n    x0 = np.hstack([centers, radii[:,None]]).flatten()\n\n    # Constraints:\n\n    # 1. Circles inside square:  0+r <= x <= 1-r AND same for y\n    def boundary_constr(idx):\n        def cfun(xvec):\n            xs = xvec[0::3]\n            ys = xvec[1::3]\n            rs = xvec[2::3]\n            ci = idx\n            val = [\n                xs[ci] - rs[ci],              # >= 0\n                1 - xs[ci] - rs[ci],          # >= 0\n                ys[ci] - rs[ci],              # >= 0\n                1 - ys[ci] - rs[ci],          # >= 0\n                rs[ci]                        # >= 0\n            ]\n            return np.array(val)\n        return cfun\n\n    constraints = []\n    for i in range(n):\n        cfun = boundary_constr(i)\n        constraints.append({'type':'ineq', 'fun': cfun})\n    # 2. No overlaps: for all pairs, distance >= sum of radii\n    def overlap_constr(i,j):\n        def ofun(xvec):\n            xs = xvec[0::3]\n            ys = xvec[1::3]\n            rs = xvec[2::3]\n            dx = xs[i] - xs[j]\n            dy = ys[i] - ys[j]\n            dist = np.sqrt(dx*dx + dy*dy)\n            return dist - (rs[i] + rs[j]) + 1e-7 # add epsilon in case of float problems\n        return ofun\n    for i in range(n):\n        for j in range(i+1, n):\n            constraints.append({'type':'ineq', 'fun': overlap_constr(i,j)})\n\n    # Objective: maximize sum of radii (scipy minimizes, so use negative)\n    def obj(xvec):\n        rs = xvec[2::3]\n        return -np.sum(rs)\n\n    opt = minimize(\n        obj,\n        x0,\n        method='SLSQP',\n        constraints=constraints,\n        options={'ftol':1e-8, 'maxiter':1000, 'disp':False}\n    )\n\n    xvec = opt.x\n    centers = np.column_stack([xvec[0::3], xvec[1::3]])\n    radii   = xvec[2::3]\n    sum_radii = radii.sum()\n\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.581158095471561,
      "additional_data": {
        "sum_radii": "2.581158",
        "target_ratio": "0.979567",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  },
  {
    "id": 100,
    "parent_id": 96,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    n = 26\n\n    def alt_hex_coords(num, r_min=0.028):\n        # Slightly more balanced: 6,6,5,5,4 = 26\n        rows = [6,6,5,5,4]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = (dx/2 if idx % 2 else 0) + (max(rows)-nrow)/2 * dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    r0 = 0.0400  # Slightly larger initial radius\n    r_min_grid = 0.028 # push closer to box edges\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    seeds = [0, 42, 7, 55]  # More random seeds for local optima\n\n    for trial_seed in seeds:\n        np.random.seed(trial_seed)\n        centers0 = alt_hex_coords(n, r_min=r_min_grid)\n        # Slightly larger jitter\n        centers0 += (np.random.rand(n,2) - 0.5) * 0.008\n        radii0 = np.full(n, r0)\n        x0 = np.concatenate([centers0.flatten(), radii0])\n\n        cons = []\n        eps = 1.5e-4  # Slightly higher for dense pack\n\n        # Box and radius constraints\n        border_pad = 1e-5 # Slight extra tolerance so circles flush with edge\n        for i in range(n):\n            cons += [\n                {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i] + border_pad},     # x - r >= 0\n                {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i] + border_pad}, # 1-x - r >= 0\n                {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i] + border_pad},     # y - r >= 0\n                {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i] + border_pad}, # 1-y - r >= 0\n                {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.012},        # r >= 0.012 (minimum radius)\n                {'type': 'ineq', 'fun': lambda x, i=i: 0.17 - x[2*n+i]},         # r <= 0.17 (safety)\n            ]\n        # Pairwise distance non-overlap\n        for i in range(n):\n            for j in range(i+1, n):\n                cons.append({\n                    'type': 'ineq',\n                    'fun': lambda x, i=i, j=j: (\n                        np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                        - (x[2*n+i] + x[2*n+j] + eps)\n                    )\n                })\n\n        def objective(x):\n            return -np.sum(x[2*n:])\n\n        def check_valid(x):\n            for con in cons:\n                if con['fun'](x) < -1e-7:\n                    return False\n            return True\n\n        res = minimize(\n            objective, x0, constraints=cons, method='SLSQP',\n            options={'ftol':1e-11, 'maxiter':10000, 'disp':False}\n        )\n        res_x = res.x if res.success and check_valid(res.x) else x0\n        sum_radii = np.sum(res_x[2*n:])\n        if sum_radii > best_sum and check_valid(res_x):\n            best_sum = sum_radii\n            best_centers = res_x[:2*n].reshape(n,2)\n            best_radii = res_x[2*n:]\n\n    # Fallback if optimization fails: return initial grid\n    if best_centers is None or best_radii is None:\n        best_centers = alt_hex_coords(n, r_min=0.035)\n        best_radii = np.full(n, 0.033)\n        best_sum = best_radii.sum()\n\n    return best_centers, best_radii, float(best_sum)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "sum_radii": "0.0",
        "target_ratio": "0.0",
        "validity": "invalid",
        "error": "Invalid packing (overlaps or out of bounds)"
      }
    }
  },
  {
    "id": 101,
    "parent_id": 82,
    "solution": "\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    n = 26\n\n    def alt_hex_coords(num, r_min=0.038):\n        rows = [6,5,5,5,5]\n        coords = []\n        dx = (1 - 2*r_min) / (max(rows)-1)\n        dy = (1 - 2*r_min) / (len(rows)-1)\n        y = r_min\n        for idx, nrow in enumerate(rows):\n            row_offset = ((dx/2) if (idx % 2) else 0) + (max(rows)-nrow)/2 * dx\n            for j in range(nrow):\n                x = r_min + row_offset + j * dx\n                coords.append([x, y])\n            y += dy\n        return np.array(coords)[:num]\n\n    # tweak initial radius slightly upward\n    r0 = 0.037\n    r_min_grid = r0 + 0.002\n    centers0 = alt_hex_coords(n, r_min=r_min_grid)\n    radii0 = np.full(n, r0)\n    x0 = np.concatenate([centers0.flatten(), radii0])\n\n    eps = 1e-6\n    cons = []\n    # boundary constraints\n    for i in range(n):\n        cons += [\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i]   - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i]    - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: 1 - x[2*i+1] - x[2*n+i]},\n            {'type': 'ineq', 'fun': lambda x, i=i: x[2*n+i] - 0.008},\n            {'type': 'ineq', 'fun': lambda x, i=i: 0.16 - x[2*n+i]},\n        ]\n    # non-overlap\n    for i in range(n):\n        for j in range(i+1, n):\n            cons.append({\n                'type': 'ineq',\n                'fun': lambda x, i=i, j=j: (\n                    np.hypot(x[2*i] - x[2*j], x[2*i+1] - x[2*j+1])\n                    - (x[2*n+i] + x[2*n+j] + eps)\n                )\n            })\n\n    def objective(x):\n        return -np.sum(x[2*n:])\n\n    def optimize_once(x0, seed=None, jitter=0.0):\n        xstart = x0.copy()\n        if seed is not None:\n            np.random.seed(seed)\n        if jitter > 0:\n            xstart[:2*n] += (np.random.rand(2*n) - 0.5) * jitter\n        res = minimize(\n            objective, xstart, constraints=cons, method='SLSQP',\n            options={'ftol':1e-14, 'maxiter':20000, 'disp':False}\n        )\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return xstart, np.sum(xstart[2*n:])\n\n    # multiple restarts with growing jitter list including a smaller initial jitter\n    xbest, fbest = optimize_once(x0, seed=0, jitter=0.0)\n    best_list = [(xbest, fbest)]\n    jitters = [0.0025, 0.005, 0.01, 0.015, 0.02, 0.03, 0.04, 0.05, 0.06, 0.07, 0.08]\n    for idx, jit in enumerate(jitters):\n        xtry, ftry = optimize_once(xbest, seed=100+idx, jitter=jit)\n        if ftry > fbest:\n            xbest, fbest = xtry, ftry\n\n    centers = xbest[:2*n].reshape(n,2)\n    radii   = xbest[2*n:]\n\n    def inflate(centers, radii, iterations=50, eps=1e-12):\n        n = len(radii)\n        for _ in range(iterations):\n            for i in range(n):\n                xi, yi = centers[i]\n                rmax = min(xi,1-xi,yi,1-yi)\n                for j in range(n):\n                    if i==j: continue\n                    d = np.hypot(xi-centers[j,0], yi-centers[j,1]) - radii[j]\n                    if d < rmax:\n                        rmax = d\n                radii[i] = max(radii[i], rmax - eps)\n        return radii\n\n    radii = inflate(centers, radii)\n\n    # final LP to maximize radii sum exactly\n    A = []\n    b = []\n    for i in range(n):\n        xi, yi = centers[i]\n        bound_i = min(xi,1-xi,yi,1-yi)\n        row = np.zeros(n)\n        row[i] = 1\n        A.append(row); b.append(bound_i)\n    for i in range(n):\n        for j in range(i+1, n):\n            dij = np.hypot(centers[i,0]-centers[j,0], centers[i,1]-centers[j,1])\n            row = np.zeros(n)\n            row[i] = 1; row[j] = 1\n            A.append(row); b.append(dij)\n    A = np.array(A); b = np.array(b)\n    res_lp = linprog(-np.ones(n), A_ub=A, b_ub=b, bounds=[(0,None)]*n, method='highs')\n    if res_lp.success:\n        radii = res_lp.x\n\n    sum_radii = float(np.sum(radii))\n    return centers, radii, sum_radii\n",
    "evaluation": {
      "fitness": 2.6045093335186245,
      "additional_data": {
        "sum_radii": "2.604509",
        "target_ratio": "0.988429",
        "validity": "valid",
        "target_value": "2.635"
      }
    }
  }
]