[
  {
    "id": 1,
    "parent_id": null,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Fixed parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 10\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            # abort and return identity mapping\n            return [], A\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    if params['ht']:\n        sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    else:\n        sA = U.sum(axis=0)\n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    if params['hl']:\n        h0 = np.log(sA).sum() / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n# Single-qubit Clifford layer extraction\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n\n",
    "evaluation": {
      "fitness": 4.833333333333329,
      "additional_data": {
        "score": "4.833333",
        "total_compute_time": "6.035769",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 19,
    "creation_info": null
  },
  {
    "id": 2,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Improved CNOT circuit synthesis using enhanced GL heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2.5,  # Tuned heuristic weight\n        'wMax': 15   # Increased patience\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        best = None\n        best_dh = None\n        best_B = None\n        \n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            \n            # Consider inverse heuristic if enabled\n            if params['hi']:\n                Binv = bin_mat_inv(B[:n,:n].T)\n                hBinv_val, _ = gl_heuristic(sym_cnot(Binv), params)\n                hB_val = min(hB_val, hBinv_val)\n            \n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            \n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n                \n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        \n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n            \n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            return [], A\n            \n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    \n    # Enhanced heuristic calculation\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    \n    if params['ht']:\n        sA = np.concatenate([col_sums, row_sums])\n    else:\n        sA = col_sums\n        \n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    \n    # Improved heuristic combining multiple factors\n    if params['hl']:\n        log_terms = np.log(np.maximum(sA, 1))\n        h0 = log_terms.sum() / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n        \n    # Additional term for nearly complete columns\n    near_complete = sum(1 for x in col_sums if x == 1 or x == n-1)\n    h0 -= 0.1 * near_complete / n\n    \n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    \n    # Include all possible CX operations\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                opts.append(('CX', (i, j)))\n                \n    return opts\n\n\n# [Rest of the helper functions remain exactly the same as in the original solution]\ndef apply_op(U, op): ...\ndef op_list_layers(op_list): ...\ndef count_entangling(op_list): ...\ndef op_list_to_string(op_list, sep=' '): ...\ndef sym_cnot(U): ...\ndef bin_mat_inv(A): ...\ndef sym_r2(U): ...\ndef perm_mat_to_ix(P): ...\ndef ix_rev(ix): ...\ndef Fmat(U, i, j): ...\ndef SQC2str(A): ...\ndef CList2opList(CList): ...\ndef mat2SQC(UC): ...\ndef op_list2sym(op_list, n): ...\ndef sym_test(U, ops): ...\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: 'NoneType' object has no attribute 'shape'",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 5,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 3,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'beam_width': 5,\n        'max_depth': 50,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 15\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], 0)])\n    best_h = float('inf')\n    best_state = None\n    \n    for _ in range(params['max_depth']):\n        if not beam:\n            break\n            \n        next_beam = []\n        \n        for U, ops, _ in beam:\n            if gl_heuristic(U, params)[0] < 1e-5:\n                return ops, U\n                \n            for op in gl_options(U):\n                new_U = apply_op(U, op)\n                new_ops = ops + [op]\n                h_val, h_tuple = gl_heuristic(new_U, params)\n                next_beam.append((new_U, new_ops, h_val))\n        \n        next_beam.sort(key=lambda x: x[2])\n        beam = deque(next_beam[:params['beam_width']])\n        \n        current_best = beam[0][2]\n        if current_best < best_h:\n            best_h = current_best\n            best_state = (beam[0][0], beam[0][1])\n    \n    if best_state:\n        return best_state[1], best_state[0]\n    return [], A\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    \n    col_weights = top.sum(axis=0)\n    row_weights = top.sum(axis=1)\n    \n    h_col = np.sum(np.log(np.maximum(col_weights, 1)))\n    h_row = np.sum(np.log(np.maximum(row_weights, 1)))\n    \n    h_inv = np.sum(np.log(np.maximum(bot.sum(axis=0), 1)))\n    \n    h_total = h_col + h_row + h_inv\n    weights = tuple(map(int, col_weights)) + tuple(map(int, row_weights))\n    \n    return h_total, weights\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 2,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 4,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved CNOT circuit synthesis using enhanced heuristic and search strategy.\n\"\"\"\nimport numpy as np\nimport time\nfrom collections import defaultdict\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    # Generate both original and transposed versions\n    sym = sym_cnot(U)\n    symT = sym_cnot(U.T)\n    \n    # Search both versions in parallel\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 15,\n        'max_attempts': 3\n    }\n    \n    best_result = None\n    for attempt in range(params['max_attempts']):\n        for mat in [sym, symT]:\n            result = synth_main(mat, params)\n            if best_result is None or result[1] < best_result[1]:\n                best_result = result\n                if best_result[1] <= n:  # Early exit if optimal found\n                    return best_result\n    \n    proc_time = time.time() - start\n    n, gate_count, depth, _, check, circ = best_result\n    return n, gate_count, depth, proc_time, check, circ\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, 0, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = float('inf')\n    curr_wait = 0\n    best_h = float('inf')\n    best_U = U.copy()\n    best_ops = []\n    \n    while True:\n        h_val, h_tuple = enhanced_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        candidates = []\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = enhanced_heuristic(B, params)\n            candidates.append((hB_val, hB_tuple, op, B))\n        \n        # Sort candidates by heuristic and select top 3\n        candidates.sort()\n        for hB_val, hB_tuple, op_chosen, B in candidates[:3]:\n            if hB_val < h_val:\n                U = B\n                op_list.append(op_chosen)\n                if hB_val < best_h:\n                    best_h = hB_val\n                    best_U = U.copy()\n                    best_ops = op_list.copy()\n                    curr_wait = 0\n                else:\n                    curr_wait += 1\n                break\n        else:\n            # No improvement found\n            curr_wait += 1\n            \n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            if best_h < float('inf'):\n                return best_ops, best_U\n            return [], A\n    \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef enhanced_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    # Column sums\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    \n    # Log heuristic\n    log_heuristic = 0\n    for s in col_sums:\n        if s > 0:\n            log_heuristic += np.log(s)\n    \n    # Weighted column priority\n    weighted = 0\n    for s in col_sums:\n        weighted += 1/(s+0.1) if s > 0 else 0\n    \n    # Combine metrics\n    h0 = (log_heuristic / n) + (weighted / n)\n    \n    if params['ht']:\n        sA = np.concatenate([col_sums, row_sums])\n    else:\n        sA = col_sums\n        \n    w = tuple(sorted(int(x) for x in sA))\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 2,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 1,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 3
    }
  },
  {
    "id": 5,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved search.py - Enhanced CNOT circuit synthesis with better heuristic and search.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 4,  # Increased heuristic ratio\n        'wMax': 10\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:  # Early termination if no options\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']//2:  # Early termination\n            break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    # Consider both original and inverse matrices\n    U_inv = bin_mat_inv(U[:n,:n].T)\n    sA = U.sum(axis=0)\n    sA_inv = U_inv.sum(axis=0)\n    \n    # Column-wise metrics\n    col_weights = tuple(sorted(int(x) for x in sA))\n    col_weights_inv = tuple(sorted(int(x) for x in sA_inv))\n    \n    if params['hl']:\n        # Logarithmic sum with epsilon to avoid log(0)\n        eps = 1e-10\n        h0 = (np.log(sA + eps).sum() + np.log(sA_inv + eps).sum()) / (2 * n)\n    else:\n        h0 = ((U.sum() + U_inv.sum()) / (2 * n) - 1\n    \n    # Combine metrics\n    w = col_weights + col_weights_inv\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n            opts.append(('CX', (j, i)))  # Add reverse CNOT\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Result file not found. Return code: 1, stderr:   File \"/var/folders/28/81_7stz56pj25dz5bc6t2lh40000gn/T/tmpihi8pyyd.py\", line 135\n    h0 = ((U.sum() + U_inv.sum()) / (2 * n) - 1\n         ^\nSyntaxError: '(' was never closed\n",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 4,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 4
    }
  },
  {
    "id": 6,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved search.py with enhanced heuristic and search parameters\n\"\"\"\n\nimport numpy as np\nimport time\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,  # Reduced from 3 for better balance\n        'wMax': 8  # Reduced from 10 for faster termination\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    sA = U.sum(axis=0)\n    sA_inv = U[n:,:n].sum(axis=0) if params['hi'] else sA\n    w = tuple(sorted(int(x) for x in sA + sA_inv))\n    Ls = len(w)\n    if params['hl']:\n        h0 = np.log(np.maximum(1, sA)).sum() / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, :n]\n    opts = []\n    # Add regular CNOT options\n    prod = top.T @ top\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    # Add inverse CNOT options\n    prod_inv = bot.T @ bot\n    rows, cols = np.nonzero(prod_inv)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (j, i)))  # Inverse direction\n    return opts\n\n[Rest of the helper functions remain exactly the same as in the original solution]\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Result file not found. Return code: 1, stderr:   File \"/var/folders/28/81_7stz56pj25dz5bc6t2lh40000gn/T/tmpu8lb1elq.py\", line 133\n    [Rest of the helper functions remain exactly the same as in the original solution]\n     ^^^^^^^\nSyntaxError: invalid syntax. Perhaps you forgot a comma?\n",
        "execution_method": "single_subprocess"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 9,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 5
    }
  },
  {
    "id": 7,
    "parent_id": 1,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    # Generate both original and transposed versions\n    sym = sym_cnot(U)\n    symT = sym_cnot(U.T)\n    \n    # Try both directions in parallel\n    result1 = beam_search(sym, beam_width=3)\n    result2 = beam_search(symT, beam_width=3)\n    \n    # Choose the better result\n    if len(result1[0]) <= len(result2[0]):\n        op_list, UC = result1\n    else:\n        op_list, UC = result2\n    \n    # Post-processing\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(sym, full_ops)\n    \n    return n, gate_count, depth, proc_time, check, circ\n\ndef beam_search(U, beam_width=3, max_iter=100):\n    n = U.shape[1] // 2\n    beams = [([], U.copy())]\n    \n    for _ in range(max_iter):\n        new_beams = []\n        for ops, mat in beams:\n            if advanced_heuristic(mat) == 0:\n                return ops, mat\n                \n            for op in extended_gl_options(mat):\n                new_mat = apply_op(mat, op)\n                new_ops = ops + [op]\n                new_beams.append((new_ops, new_mat))\n        \n        # Keep top beam_width candidates\n        beams = sorted(new_beams, key=lambda x: advanced_heuristic(x[1]))[:beam_width]\n    \n    return beams[0] if beams else ([], U)\n\ndef advanced_heuristic(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    # Column-wise metrics\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    inv_col_sums = bottom.sum(axis=0)\n    \n    # Prioritize columns with sum close to 1\n    col_prio = tuple(sorted((abs(s-1)+1 for s in col_sums)))\n    inv_prio = tuple(sorted((abs(s-1)+1 for s in inv_col_sums)))\n    \n    # Sparsity metrics\n    sparsity = (top.size - top.sum()) / top.size\n    inv_sparsity = (bottom.size - bottom.sum()) / bottom.size\n    \n    # Combined heuristic\n    h = (sum(np.log2(s+1) for s in col_sums) / n +\n         sum(np.log2(s+1) for s in inv_col_sums) / n +\n         sparsity + inv_sparsity)\n    \n    return h, (col_prio, inv_prio)\n\ndef extended_gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    opts = []\n    \n    # Column operations\n    prod = top.T @ top\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    \n    # Row operations (applied as column ops to inverse)\n    prod_inv = bottom.T @ bottom\n    rows, cols = np.nonzero(prod_inv)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (j+n, i+n)))\n    \n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        if j < n:  # Regular CNOT\n            U_new[:, j] ^= U_new[:, i]\n            U_new[:, n + i] ^= U_new[:, n + j]\n        else:  # Inverse CNOT\n            i -= n\n            j -= n\n            U_new[:, n + j] ^= U_new[:, n + i]\n            U_new[:, i] ^= U_new[:, j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 6,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 6
    }
  },
  {
    "id": 8,
    "parent_id": 1,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    # Generate all equivalent matrices to consider\n    matrices = [sym_cnot(U)]\n    matrices.append(sym_cnot(bin_mat_inv(U)))\n    matrices.append(sym_cnot(U.T))\n    \n    best_result = None\n    for mat in matrices:\n        try:\n            op_list, UC = beam_search(mat, beam_width=3, max_depth=50)\n            sqc_ops = mat2SQC(UC)\n            full_ops = sqc_ops + op_list\n            depth = len(op_list_layers(full_ops))\n            gate_count = count_entangling(full_ops)\n            proc_time = time.time() - start\n            \n            if best_result is None or gate_count < best_result[1]:\n                circ = op_list_to_string(full_ops)\n                check = sym_test(mat, full_ops)\n                best_result = (n, gate_count, depth, proc_time, check, circ)\n                \n                # Early exit if perfect solution found\n                if gate_count <= n:\n                    break\n                    \n        except Exception:\n            continue\n            \n    if best_result is None:\n        return (n, 0, 0, 0, False, \"\")\n    return best_result\n\ndef beam_search(A, beam_width=3, max_depth=50):\n    n = A.shape[1] // 2\n    beams = [([], A)]\n    \n    for _ in range(max_depth):\n        new_beams = []\n        for ops, U in beams:\n            for op in extended_gl_options(U):\n                new_ops = ops + [op]\n                new_U = apply_op(U, op)\n                new_beams.append((new_ops, new_U))\n        \n        if not new_beams:\n            break\n            \n        # Evaluate all candidates and keep top beam_width\n        new_beams.sort(key=lambda x: (advanced_heuristic(x[1]), len(x[0])))\n        beams = new_beams[:beam_width]\n        \n        # Check for solution\n        for ops, U in beams:\n            if advanced_heuristic(U) <= 1e-5:\n                return ops, U\n                \n    # Return best found if no perfect solution\n    beams.sort(key=lambda x: (advanced_heuristic(x[1]), len(x[0])))\n    return beams[0]\n\ndef advanced_heuristic(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    # Column and row sums\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    \n    # Diagonal dominance\n    diag = np.diag(top)\n    off_diag = top.sum() - diag.sum()\n    \n    # Inverse matrix properties\n    inv_col_sums = bottom.sum(axis=0)\n    \n    # Combined heuristic components\n    h_col = np.sum(np.log(np.maximum(col_sums, 1)))\n    h_row = np.sum(np.log(np.maximum(row_sums, 1)))\n    h_inv = np.sum(np.log(np.maximum(inv_col_sums, 1)))\n    h_diag = (n - diag.sum()) * 0.5\n    h_off = off_diag * 0.2\n    \n    return h_col + h_row + h_inv + h_diag + h_off\n\ndef extended_gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    \n    # Regular CNOT options\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    \n    # Additional operation types\n    for i in range(n):\n        for j in range(i+1, n):\n            if top[i,j] or top[j,i]:\n                opts.append(('SWAP', (i, j)))\n    \n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    \n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'SWAP':\n        i, j = q\n        U_new[:, [i, j]] = U_new[:, [j, i]]\n        U_new[:, [n+i, n+j]] = U_new[:, [n+j, n+i]]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    \n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ in ['CX', 'SWAP'])\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 8,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 7
    }
  },
  {
    "id": 9,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved search.py - Enhanced CNOT circuit synthesis with better heuristics.\n\"\"\"\n\nimport numpy as np\nimport time\nimport math\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n    \"\"\"\n    # Adaptive parameters based on matrix size\n    n = U.shape[0]\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': max(2, min(5, int(math.log2(n))) if n > 1 else 2,\n        'wMax': max(5, min(15, 2*n))\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    no_improve = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        best_op = None\n        best_U = None\n        best_h_new = float('inf')\n        \n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            \n            if hB_val < best_h_new:\n                best_h_new = hB_val\n                best_op = op\n                best_U = B\n                \n        if best_h_new >= h_val:\n            break\n            \n        U = best_U\n        op_list.append(best_op)\n        \n        if best_h_new < best_h:\n            best_h = best_h_new\n            no_improve = 0\n        else:\n            no_improve += 1\n            \n        if no_improve > params['wMax']:\n            break\n            \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    \n    # Column and row sums\n    col_sums = top.sum(axis=0) + bot.sum(axis=0)\n    row_sums = top.sum(axis=1) + bot.sum(axis=1)\n    \n    # Log-based terms\n    log_col = np.log([max(1, x) for x in col_sums]).sum()\n    log_row = np.log([max(1, x) for x in row_sums]).sum()\n    \n    # Combined heuristic\n    h_sum = (col_sums.sum() + row_sums.sum()) / (4 * n)\n    h_log = (log_col + log_row) / (2 * n)\n    \n    w = tuple(sorted(int(x) for x in col_sums + row_sums))\n    return params['hr'] * (0.6 * h_log + 0.4 * h_sum), w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    opts = []\n    \n    # Add CX options\n    prod = top.T @ top\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    \n    # Add reverse CX options\n    prod = bot.T @ bot\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j and ('CX', (j, i)) not in opts:\n            opts.append(('CX', (j, i)))\n    \n    return opts\n\n# [Rest of the helper functions remain exactly the same as in the original solution]\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Result file not found. Return code: 1, stderr:   File \"/var/folders/28/81_7stz56pj25dz5bc6t2lh40000gn/T/tmp692b2zy9.py\", line 53\n    }\n    ^\nSyntaxError: closing parenthesis '}' does not match opening parenthesis '(' on line 51\n",
        "execution_method": "single_subprocess"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 10,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 8
    }
  },
  {
    "id": 10,
    "parent_id": 4,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import defaultdict\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    # Generate multiple variants to search\n    variants = [\n        sym_cnot(U),\n        sym_cnot(U.T),\n        sym_cnot(bin_mat_inv(U)),\n        sym_cnot(bin_mat_inv(U).T)\n    ]\n    \n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,  # Reduced heuristic weight\n        'wMax': 10,  # Smaller patience window\n        'max_attempts': 2\n    }\n    \n    best_result = None\n    for mat in variants:\n        result = synth_main(mat, params)\n        if best_result is None or result[1] < best_result[1]:\n            best_result = result\n            if best_result[1] <= n:  # Early exit if optimal found\n                break\n    \n    proc_time = time.time() - start\n    n, gate_count, depth, _, check, circ = best_result\n    return n, gate_count, depth, proc_time, check, circ\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, 0, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_U = U.copy()\n    best_ops = []\n    best_h = float('inf')\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = enhanced_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        candidates = []\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = enhanced_heuristic(B, params)\n            candidates.append((hB_val, hB_tuple, op, B))\n        \n        candidates.sort()\n        for hB_val, hB_tuple, op_chosen, B in candidates[:5]:  # Consider top 5\n            if hB_val < h_val:\n                U = B\n                op_list.append(op_chosen)\n                if hB_val < best_h:\n                    best_h = hB_val\n                    best_U = U.copy()\n                    best_ops = op_list.copy()\n                    curr_wait = 0\n                else:\n                    curr_wait += 1\n                break\n        else:\n            curr_wait += 1\n            \n        if curr_wait > params['wMax']:\n            if best_h < float('inf'):\n                return best_ops, best_U\n            return [], A\n    \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef enhanced_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    \n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    \n    log_heuristic = sum(np.log(s + 0.1) for s in col_sums)\n    weighted = sum(1/(s + 0.1) for s in col_sums)\n    h0 = (log_heuristic + weighted) / (2 * n)\n    \n    if params['ht']:\n        sA = np.concatenate([col_sums, row_sums])\n    else:\n        sA = col_sums\n        \n    w = tuple(sorted(int(x) for x in sA))\n    return h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef SQC2str(A):\n    SQC_tostr = {\n        '1001': 'I', '0110': 'H',\n        '1101': 'S', '1011': 'HSH',\n        '1110': 'HS', '0111': 'SH'\n    }\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 2,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 11,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 11,
    "parent_id": 4,
    "solution": "\nimport numpy as np\nimport time\nimport heapq\nfrom functools import lru_cache\n\ndef search(U):\n    start_time = time.time()\n    n = U.shape[0]\n    \n    # Generate all equivalent forms to search\n    sym = symCNOT(U)\n    symT = symCNOT(U.T)\n    sym_inv = symCNOT(binMatInv(U))\n    sym_invT = symCNOT(binMatInv(U).T)\n    \n    targets = [sym, symT, sym_inv, sym_invT]\n    \n    best_result = None\n    for target in targets:\n        result = a_star_search(target, n, start_time)\n        if result and (best_result is None or result[1] < best_result[1]):\n            best_result = result\n            if best_result[1] <= n:  # Early exit if optimal found\n                break\n    \n    if best_result is None:\n        return (n, 0, 0, time.time()-start_time, False, \"\")\n    \n    proc_time = time.time() - start_time\n    n, gate_count, depth, _, check, circ = best_result\n    return (n, gate_count, depth, proc_time, check, circ)\n\ndef a_star_search(target, n, start_time):\n    heap = []\n    initial_state = np.eye(2*n, dtype=int)\n    initial_cost = 0\n    initial_heuristic = heuristic(target, initial_state)\n    heapq.heappush(heap, (initial_cost + initial_heuristic, initial_cost, initial_heuristic, initial_state, []))\n    \n    visited = set()\n    \n    while heap:\n        _, cost, _, current_state, path = heapq.heappop(heap)\n        \n        if time.time() - start_time > 15:  # Timeout\n            return None\n            \n        state_key = tuple(current_state.ravel())\n        if state_key in visited:\n            continue\n        visited.add(state_key)\n        \n        if np.array_equal(current_state, target):\n            depth = calculate_depth(path)\n            circ = circuit_to_string(path)\n            return (n, len(path), depth, 0, True, circ)\n        \n        for op in generate_operations(current_state, n):\n            new_state = apply_operation(current_state, op)\n            new_cost = cost + 1\n            new_heuristic = heuristic(target, new_state)\n            new_path = path + [op]\n            \n            heapq.heappush(heap, (new_cost + new_heuristic, new_cost, new_heuristic, new_state, new_path))\n    \n    return None\n\n@lru_cache(maxsize=None)\ndef heuristic(target, current):\n    n = target.shape[0] // 2\n    diff = (target ^ current)[:n,:n]\n    col_sums = diff.sum(axis=0)\n    row_sums = diff.sum(axis=1)\n    \n    # Combined heuristic considering both column and row weights\n    h = 0\n    for s in col_sums:\n        if s > 0:\n            h += np.log(s + 1)\n    for s in row_sums:\n        if s > 0:\n            h += np.log(s + 1)\n    \n    return h / (2*n)\n\ndef generate_operations(state, n):\n    top = state[:n,:n]\n    operations = []\n    for i in range(n):\n        for j in range(n):\n            if i != j and top[i,j] == 1:\n                operations.append(('CX', (i,j)))\n    return operations\n\ndef apply_operation(state, op):\n    typ, (i,j) = op\n    n = state.shape[0] // 2\n    new_state = state.copy()\n    if typ == 'CX':\n        new_state[:,j] ^= new_state[:,i]\n        new_state[:,n+i] ^= new_state[:,n+j]\n    return new_state\n\ndef calculate_depth(path):\n    layers = []\n    for op in path:\n        typ, (i,j) = op\n        added = False\n        for layer in layers:\n            if i not in layer and j not in layer:\n                layer.update({i,j})\n                added = True\n                break\n        if not added:\n            layers.append({i,j})\n    return len(layers)\n\ndef circuit_to_string(path):\n    return ' '.join(f'CX:{i},{j}' for typ, (i,j) in path)\n\ndef symCNOT(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n,:n] = U % 2\n    inv = binMatInv(U.T % 2)\n    S[n:,n:] = inv % 2\n    return S\n\ndef binMatInv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i,i] == 0:\n            for j in range(i+1,n):\n                if aug[j,i] == 1:\n                    aug[[i,j]] = aug[[j,i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular\")\n        for j in range(n):\n            if j != i and aug[j,i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:,n:]\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: unhashable type: 'numpy.ndarray'",
        "execution_method": "single_subprocess"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 13,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 12,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved search.py - Optimized CNOT circuit synthesis using enhanced GL heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,  # Reduced from 3\n        'wMax': 8  # Reduced from 10\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        \n        # Consider both original and transposed options\n        for op in gl_options(U) + gl_options(U.T):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        \n        if best is None:\n            break\n            \n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        \n        if h_min is None or hB_val < h_min[1]:\n            curr_wait = 0\n            h_min = (h_tuple, hB_val)\n        else:\n            curr_wait += 1\n            \n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            break\n            \n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    \n    # Enhanced heuristic calculations\n    sA_cols = U.sum(axis=0)\n    sA_rows = U.sum(axis=1)\n    sA = np.concatenate([sA_cols, sA_rows])\n    \n    # Column-wise analysis\n    col_weights = []\n    for j in range(n):\n        col = top[:, j]\n        w = col.sum()\n        if w > 1:\n            col_weights.append(1.0 / (w - 0.9))  # Favors columns closer to weight 1\n        else:\n            col_weights.append(0)\n    \n    h_col = np.sum(col_weights)\n    h_sum = (U.sum() / len(U) - 1)\n    h_log = np.log(sA + 1e-6).sum() / len(sA)  # Avoid log(0)\n    \n    # Combined heuristic\n    h0 = 0.4 * h_col + 0.3 * h_sum + 0.3 * h_log\n    w = tuple(sorted(int(x) for x in sA))\n    \n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 12,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 9
    }
  },
  {
    "id": 13,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved search.py with better heuristic and search parameters.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n    \"\"\"\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,  # Reduced from 3\n        'wMax': 15  # Increased from 10\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            return [], A\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    # Consider both original and transpose matrices\n    U1 = U[:n, :n]\n    U2 = U1.T\n    U3 = bin_mat_inv(U1)\n    U4 = bin_mat_inv(U1.T)\n    \n    sA = []\n    for M in [U1, U2, U3, U4]:\n        if params['ht']:\n            sA.extend([M.sum(axis=0), M.sum(axis=1)])\n        else:\n            sA.extend([M.sum(axis=0)])\n    \n    # Column-wise heuristic\n    col_heuristics = []\n    for col in U1.T:\n        w = col.sum()\n        if w == 0:\n            col_heuristics.append(0)\n        else:\n            col_heuristics.append(np.log(w) if params['hl'] else w-1)\n    \n    w = tuple(sorted(int(x) for x in sA))\n    h0 = np.mean(col_heuristics)\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    # Add inverse operations\n    for i, j in zip(cols, rows):\n        if i != j and ('CX', (i, j)) not in opts:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: only length-1 arrays can be converted to Python scalars",
        "execution_method": "single_subprocess"
      }
    },
    "children": 2,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 14,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 10
    }
  },
  {
    "id": 14,
    "parent_id": 10,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import defaultdict\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    # Generate multiple variants to search\n    variants = [\n        sym_cnot(U),\n        sym_cnot(U.T),\n        sym_cnot(bin_mat_inv(U)),\n        sym_cnot(bin_mat_inv(U).T)\n    ]\n    \n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 20,\n        'max_attempts': 5\n    }\n    \n    best_result = (n, float('inf'), float('inf'), 0, False, \"\")\n    for mat in variants:\n        try:\n            result = synth_main(mat, params)\n            if result[1] < best_result[1]:\n                best_result = result\n                if best_result[1] <= n:  # Early exit if optimal found\n                    break\n        except:\n            continue\n    \n    proc_time = time.time() - start\n    n, gate_count, depth, _, check, circ = best_result\n    return n, gate_count, depth, proc_time, check, circ\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, 0, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_U = U.copy()\n    best_ops = []\n    best_h = float('inf')\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = enhanced_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        candidates = []\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = enhanced_heuristic(B, params)\n            candidates.append((hB_val, hB_tuple, op, B))\n        \n        candidates.sort()\n        for hB_val, hB_tuple, op_chosen, B in candidates[:10]:  # Consider top 10\n            if hB_val < h_val:\n                U = B\n                op_list.append(op_chosen)\n                if hB_val < best_h:\n                    best_h = hB_val\n                    best_U = U.copy()\n                    best_ops = op_list.copy()\n                    curr_wait = 0\n                else:\n                    curr_wait += 1\n                break\n        else:\n            curr_wait += 1\n            \n        if curr_wait > params['wMax']:\n            if best_h < float('inf'):\n                return best_ops, best_U\n            return [], A\n    \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef enhanced_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    \n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    total_sum = top.sum()\n    \n    log_heuristic = sum(np.log(s + 0.1) for s in col_sums)\n    weighted = sum(1/(s + 0.1) for s in col_sums)\n    h0 = (log_heuristic + weighted + total_sum) / (3 * n)\n    \n    if params['ht']:\n        sA = np.concatenate([col_sums, row_sums])\n    else:\n        sA = col_sums\n        \n    w = tuple(sorted(int(x) for x in sA))\n    return h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef SQC2str(A):\n    SQC_tostr = {\n        '1001': 'I', '0110': 'H',\n        '1101': 'S', '1011': 'HSH',\n        '1110': 'HS', '0111': 'SH'\n    }\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 15,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 15,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved search.py - Enhanced CNOT circuit synthesis with better heuristics.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,  # Reduced from 3\n        'wMax': 15  # Increased from 10\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (h_val - hB_val, key)\n            if best_dh is None or dh > best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or hB_val < h_min[1]:\n            curr_wait = 0\n            h_min = (h_tuple, hB_val)\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    \n    if params['hi']:\n        inv_top = bin_mat_inv(top)\n        inv_col_sums = inv_top.sum(axis=0)\n        inv_row_sums = inv_top.sum(axis=1)\n        col_sums = np.minimum(col_sums, inv_col_sums)\n        row_sums = np.minimum(row_sums, inv_row_sums)\n    \n    if params['ht']:\n        sA = np.concatenate([col_sums, row_sums])\n    else:\n        sA = col_sums\n    \n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    \n    if params['hl']:\n        h0 = np.sum(np.log(np.maximum(sA, 1))) / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    \n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 16,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 11
    }
  },
  {
    "id": 16,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Fixed parameters with improved settings\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': False,  # Compare by scalar first\n        'hi': True,\n        'ht': True,   # Include row sums\n        'hl': True,   # Unused in new heuristic\n        'hr': 1,      # Multiplier set to 1\n        'wMax': 10\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            return [], A\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or (hB_val, hB_tuple) < h_min:\n            curr_wait = 0\n            h_min = (hB_val, hB_tuple)\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            return [], A\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    \"\"\"Improved heuristic using squared deviation from target sums\"\"\"\n    if params['ht']:\n        col_sums = U.sum(axis=0)\n        row_sums = U.sum(axis=1)\n        sA = np.concatenate([col_sums, row_sums])\n    else:\n        sA = U.sum(axis=0)\n    sA = sA.astype(int)\n    # Sum of squared deviations from 1\n    h0 = np.sum((sA - 1) ** 2)\n    w = tuple(sorted(sA))\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n# Single-qubit Clifford layer extraction\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 1.9666666666666686,
      "additional_data": {
        "score": "1.966667",
        "total_compute_time": "7.327166",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-reasoner",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 3,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 12
    }
  },
  {
    "id": 17,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved CNOT circuit synthesis using enhanced heuristic search.\n\"\"\"\n\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 10,\n        'backtrack': True,\n        'max_backtrack': 5\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    history = deque(maxlen=params['max_backtrack'])\n    \n    while True:\n        h_val, h_tuple = enhanced_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        best_op = None\n        best_dh = float('inf')\n        best_B = None\n        \n        for op in enhanced_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = enhanced_heuristic(B, params)\n            dh = hB_val - h_val\n            \n            if dh < best_dh:\n                best_dh = dh\n                best_op = op\n                best_B = B\n        \n        if best_dh >= 0 and params['backtrack'] and len(history) > 0:\n            U, op_list = history.pop()\n            continue\n            \n        if best_op is None:\n            break\n            \n        history.append((U.copy(), op_list.copy()))\n        U = best_B\n        op_list.append(best_op)\n        \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef enhanced_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    # Column sums with log weighting\n    col_sums_top = top.sum(axis=0)\n    col_sums_bottom = bottom.sum(axis=0)\n    \n    log_sum_top = np.sum(np.log(np.maximum(col_sums_top, 1)))\n    log_sum_bottom = np.sum(np.log(np.maximum(col_sums_bottom, 1)))\n    \n    # Row sums\n    row_sums_top = top.sum(axis=1)\n    row_sums_bottom = bottom.sum(axis=1)\n    \n    # Consider both matrix and its transpose\n    h_top = (log_sum_top + np.sum(row_sums_top)) / (2 * n)\n    h_bottom = (log_sum_bottom + np.sum(row_sums_bottom)) / (2 * n)\n    \n    # Combine with original heuristic\n    h_combined = (h_top + h_bottom) / 2\n    \n    # Tuple heuristic for better local minima avoidance\n    h_tuple = (tuple(sorted(col_sums_top)), \n               tuple(sorted(col_sums_bottom)),\n               tuple(sorted(row_sums_top)),\n               tuple(sorted(row_sums_bottom)))\n    \n    return h_combined, h_tuple\n\ndef enhanced_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    opts = []\n    \n    # Generate CNOT options based on both top and bottom matrices\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Options from top matrix\n                if top[i, j] == 1:\n                    opts.append(('CX', (i, j)))\n                # Options from bottom matrix\n                if bottom[i, j] == 1:\n                    opts.append(('CX', (j, i)))\n    \n    return list(set(opts))  # Remove duplicates\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation timed out after 60 seconds",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 17,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 13
    }
  },
  {
    "id": 18,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Fixed parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 1,\n        'wMax': 20\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    # Initial heuristic\n    h_val, h_tuple = gl_heuristic(U, params)\n    if params['hv']:\n        best_key = (h_tuple, h_val)\n    else:\n        best_key = (h_val, h_tuple)\n    best_U = U.copy()\n    best_op_list = op_list.copy()\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            if params['hv']:\n                keyB = (hB_tuple, hB_val)\n            else:\n                keyB = (hB_val, hB_tuple)\n            if best_dh is None or keyB < best_dh:\n                best_dh = keyB\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        hB_tuple, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        # Form the key for the new state\n        if params['hv']:\n            new_key = (hB_tuple, hB_val)\n        else:\n            new_key = (hB_val, hB_tuple)\n        if new_key < best_key:\n            best_key = new_key\n            best_U = U.copy()\n            best_op_list = op_list.copy()\n            curr_wait = 0\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            op_list = best_op_list\n            U = best_U\n            break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    if params['ht']:\n        sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    else:\n        sA = U.sum(axis=0)\n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    if params['hl']:\n        h0 = np.log(sA).sum() / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n# Single-qubit Clifford layer extraction\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 4.833333333333329,
      "additional_data": {
        "score": "4.833333",
        "total_compute_time": "6.079954",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-reasoner",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 7,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 14
    }
  },
  {
    "id": 19,
    "parent_id": 10,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    variants = [sym_cnot(U), sym_cnot(U.T)]\n    \n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'wMax': 5,\n        'max_attempts': 1\n    }\n    \n    best_result = None\n    for mat in variants:\n        result = synth_main(mat, params)\n        if best_result is None or result[1] < best_result[1]:\n            best_result = result\n            if best_result[1] <= n:  # Early exit if optimal found\n                break\n    \n    proc_time = time.time() - start\n    n, gate_count, depth, _, check, circ = best_result\n    return n, gate_count, depth, proc_time, check, circ\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, 0, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_U = U.copy()\n    best_ops = []\n    best_h = float('inf')\n    curr_wait = 0\n    \n    while True:\n        h_val = simple_heuristic(U)\n        if h_val <= 1e-5:\n            break\n            \n        candidates = []\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val = simple_heuristic(B)\n            candidates.append((hB_val, op, B))\n        \n        candidates.sort()\n        for hB_val, op_chosen, B in candidates[:3]:  # Consider top 3\n            if hB_val < h_val:\n                U = B\n                op_list.append(op_chosen)\n                if hB_val < best_h:\n                    best_h = hB_val\n                    best_U = U.copy()\n                    best_ops = op_list.copy()\n                    curr_wait = 0\n                else:\n                    curr_wait += 1\n                break\n        else:\n            curr_wait += 1\n            \n        if curr_wait > params['wMax']:\n            if best_h < float('inf'):\n                return best_ops, best_U\n            return [], A\n    \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef simple_heuristic(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    return np.sum(top)\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    opts = []\n    for i in range(n):\n        for j in range(n):\n            if i != j and top[i,j]:\n                opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef SQC2str(A):\n    SQC_tostr = {\n        '1001': 'I', '0110': 'H',\n        '1101': 'S', '1011': 'HSH',\n        '1110': 'HS', '0111': 'SH'\n    }\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 18,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 20,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved search.py with enhanced heuristic and search parameters.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 4,  # Increased heuristic weight\n        'wMax': 8  # Slightly reduced patience\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:  # No progress, try more options\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        op = ('CX', (i,j))\n                        B = apply_op(U, op)\n                        hB_val, hB_tuple = gl_heuristic(B, params)\n                        key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n                        dh = (0, key)\n                        if best_dh is None or dh < best_dh:\n                            best_dh = dh\n                            best = (hB_tuple, hB_val, op)\n                            best_B = B\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            return [], A\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    # Consider both original and transposed matrices\n    sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    sA_inv = np.concatenate([U.T.sum(axis=0), U.T.sum(axis=1)])\n    \n    # Enhanced column sum handling\n    col_weights = []\n    for s in sA[:n]:\n        if s == 1:\n            col_weights.append(0)\n        else:\n            col_weights.append(np.log(s + 1e-6))\n    \n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    \n    # Improved heuristic combining multiple factors\n    h0 = (sum(col_weights) / n + \n          (U.sum() / len(U) - 1) / 2 +\n          (sA_inv.sum() / len(sA_inv) - 1) / 2)\n    \n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": -0.8557400226593046,
      "additional_data": {
        "score": "-0.855740",
        "total_compute_time": "15.655740",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 20,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 15
    }
  },
  {
    "id": 21,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Fixed parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,\n        'wMax': 15\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            # abort and return identity mapping\n            return [], A\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    sA = top.sum(axis=0)\n    sA_inv = U[n:, n:].sum(axis=0)\n    \n    # Prioritize columns with weight close to 1\n    col_weights = []\n    for w, w_inv in zip(sA, sA_inv):\n        if w == 1 or w_inv == 1:\n            col_weights.append(0.1)\n        else:\n            col_weights.append(min(w, w_inv) + np.log(max(w, w_inv) + 1))\n    \n    h0 = np.mean(col_weights)\n    w = tuple(sorted(int(x) for x in sA))\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: cannot unpack non-iterable NoneType object",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 19,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 16
    }
  },
  {
    "id": 22,
    "parent_id": 1,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 20,\n        'beam_width': 5\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], 0)])\n    best = None\n    \n    for _ in range(1000):\n        if not beam:\n            break\n            \n        current = beam.popleft()\n        U, ops, wait = current\n        \n        if np.array_equal(U[:n,:n], np.eye(n)) and np.array_equal(U[n:,n:], np.eye(n)):\n            return ops, U\n            \n        h_val = gl_heuristic_improved(U, params)\n        \n        if h_val == 0:\n            return ops, U\n            \n        candidates = []\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    B = apply_op(U, ('CX', (i,j)))\n                    new_ops = ops + [('CX', (i,j))]\n                    new_h = gl_heuristic_improved(B, params)\n                    candidates.append((new_h, B, new_ops))\n        \n        candidates.sort()\n        for h, B, new_ops in candidates[:params['beam_width']]:\n            beam.append((B, new_ops, 0))\n            \n        if best is None or h_val < best[0]:\n            best = (h_val, U, ops)\n            wait = 0\n        else:\n            wait += 1\n            \n        if wait > params['wMax']:\n            return best[2], best[1]\n            \n    return [], A\n\ndef gl_heuristic_improved(U, params):\n    n = U.shape[1] // 2\n    top = U[:n,:n]\n    bottom = U[n:,n:]\n    \n    # Consider both matrix and its inverse/transpose\n    h_top = column_wise_heuristic(top)\n    h_bottom = column_wise_heuristic(bottom)\n    h_trans = column_wise_heuristic(top.T)\n    \n    return min(h_top, h_bottom, h_trans)\n\ndef column_wise_heuristic(mat):\n    col_sums = mat.sum(axis=0)\n    active_cols = np.sum(col_sums > 0)\n    if active_cols == 0:\n        return 0\n    log_sum = np.sum(np.log(col_sums + 1e-10))\n    return log_sum / active_cols\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 23,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 17
    }
  },
  {
    "id": 23,
    "parent_id": 1,
    "solution": "\nimport numpy as np\nimport time\nimport math\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,\n        'wMax': 8\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    sA = top.sum(axis=0)\n    sA_inv = top.sum(axis=1)\n    sA_T = top.T.sum(axis=0)\n    \n    if params['hi']:\n        sA = np.concatenate([sA, sA_inv, sA_T])\n    elif params['ht']:\n        sA = np.concatenate([sA, sA_inv])\n    else:\n        sA = top.sum(axis=0)\n    \n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    \n    if params['hl']:\n        h0 = np.sum(np.log([x if x > 0 else 1 for x in sA])) / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    \n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    # Add reverse operations\n    for j, i in zip(cols, rows):\n        if i != j:\n            opts.append(('CX', (j, i)))\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": -4.601391410827631,
      "additional_data": {
        "score": "-4.601391",
        "total_compute_time": "18.501391",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 22,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 18
    }
  },
  {
    "id": 24,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 4,  # Increased heuristic weight\n        'wMax': 15  # Increased search width\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            # Consider inverse path before giving up\n            U_inv = np.linalg.inv(U).astype(int) % 2\n            h_val_inv, h_tuple_inv = gl_heuristic(U_inv, params)\n            if h_val_inv < h_val:\n                U = U_inv\n                curr_wait = 0\n                continue\n            return [], A\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    if params['ht']:\n        sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    else:\n        sA = U.sum(axis=0)\n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    if params['hl']:\n        h0 = np.log(np.maximum(sA, 1)).sum() / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    if params['hi']:\n        U_inv = np.linalg.inv(U).astype(int) % 2\n        h_inv = gl_heuristic(U_inv, params)[0]\n        h0 = min(h0, h_inv)\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: Singular matrix",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 21,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 19
    }
  },
  {
    "id": 25,
    "parent_id": 13,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    try:\n        sym = symCNOT(U)\n        circuit = []\n        current = sym.copy()\n        \n        # Phase 1: Reduce top-left quadrant to identity\n        for target in range(n):\n            # Find pivot row\n            pivot = -1\n            for row in range(target, n):\n                if current[row, target]:\n                    pivot = row\n                    break\n            \n            if pivot == -1:\n                continue\n                \n            # Swap rows if needed\n            if pivot != target:\n                circuit.append(('SWAP', (target, pivot)))\n                current[[target, pivot]] = current[[pivot, target]]\n                current[:, [n+target, n+pivot]] = current[:, [n+pivot, n+target]]\n            \n            # Eliminate other rows\n            for row in range(n):\n                if row != target and current[row, target]:\n                    circuit.append(('CX', (target, row)))\n                    current[row] ^= current[target]\n                    current[:, n+row] ^= current[:, n+target]\n        \n        # Verify bottom-right quadrant is identity\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    if not current[n+i, n+j]:\n                        return (n, 0, 0, time.time()-start, False, \"\")\n                else:\n                    if current[n+i, n+j]:\n                        return (n, 0, 0, time.time()-start, False, \"\")\n        \n        # Count gates and calculate depth\n        gate_count = len(circuit)\n        depth = calculate_depth(circuit)\n        proc_time = time.time() - start\n        \n        # Convert circuit to string format\n        circ_str = ' '.join(f\"{op[0]}:{op[1][0]},{op[1][1]}\" if op[0] == 'CX' else f\"{op[0]}:{op[1][0]},{op[1][1]}\" for op in circuit)\n        \n        return (n, gate_count, depth, proc_time, True, circ_str)\n    \n    except:\n        return (n, 0, 0, time.time()-start, False, \"\")\n\ndef symCNOT(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n,:n] = U % 2\n    inv = binMatInv(U.T % 2)\n    S[n:,n:] = inv % 2\n    return S\n\ndef binMatInv(A):\n    n = A.shape[0]\n    inv = np.eye(n, dtype=int)\n    for col in range(n):\n        pivot = -1\n        for row in range(col, n):\n            if A[row, col]:\n                pivot = row\n                break\n        if pivot == -1:\n            raise ValueError(\"Matrix is not invertible\")\n        if pivot != col:\n            A[[col, pivot]] = A[[pivot, col]]\n            inv[[col, pivot]] = inv[[pivot, col]]\n        for row in range(n):\n            if row != col and A[row, col]:\n                A[row] ^= A[col]\n                inv[row] ^= inv[col]\n    return inv\n\ndef calculate_depth(circuit):\n    layers = []\n    for op in circuit:\n        if op[0] == 'CX':\n            c, t = op[1]\n            placed = False\n            for layer in layers:\n                if c not in layer and t not in layer:\n                    layer.update({c, t})\n                    placed = True\n                    break\n            if not placed:\n                layers.append({c, t})\n        elif op[0] == 'SWAP':\n            a, b = op[1]\n            placed = False\n            for layer in layers:\n                if a not in layer and b not in layer:\n                    layer.update({a, b})\n                    placed = True\n                    break\n            if not placed:\n                layers.append({a, b})\n    return len(layers)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 27,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 26,
    "parent_id": 9,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\nimport math\n\ndef search(U):\n    n = U.shape[0]\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': max(2, min(5, int(math.log2(n))) if n > 1 else 2),\n        'wMax': max(5, min(15, 2*n))\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    no_improve = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        best_op = None\n        best_U = None\n        best_h_new = float('inf')\n        \n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            \n            if hB_val < best_h_new:\n                best_h_new = hB_val\n                best_op = op\n                best_U = B\n                \n        if best_h_new >= h_val:\n            break\n            \n        U = best_U\n        op_list.append(best_op)\n        \n        if best_h_new < best_h:\n            best_h = best_h_new\n            no_improve = 0\n        else:\n            no_improve += 1\n            \n        if no_improve > params['wMax']:\n            break\n            \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    \n    col_sums = top.sum(axis=0) + bot.sum(axis=0)\n    row_sums = top.sum(axis=1) + bot.sum(axis=1)\n    \n    log_col = np.sum(np.log(np.maximum(col_sums, 1)))\n    log_row = np.sum(np.log(np.maximum(row_sums, 1)))\n    \n    h_sum = (col_sums.sum() + row_sums.sum()) / (4 * n)\n    h_log = (log_col + log_row) / (2 * n)\n    \n    w = tuple(sorted(int(x) for x in col_sums + row_sums))\n    return params['hr'] * (0.7 * h_log + 0.3 * h_sum), w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    opts = []\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j and top[i,j] == 1:\n                opts.append(('CX', (i,j)))\n            if i != j and bot[i,j] == 1:\n                opts.append(('CX', (j,i)))\n    \n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = []\n    for i, M in enumerate(CList):\n        key = ''.join(str(int(x)) for x in M.ravel())\n        c = SQC_tostr.get(key, 'I')\n        if c != 'I':\n            ops.append((c, (i,)))\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 26,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 27,
    "parent_id": 11,
    "solution": "\nimport numpy as np\nimport time\nimport heapq\nfrom functools import lru_cache\n\ndef search(U):\n    start_time = time.time()\n    n = U.shape[0]\n    \n    # Generate all equivalent forms to search\n    sym = symCNOT(U)\n    symT = symCNOT(U.T)\n    sym_inv = symCNOT(binMatInv(U))\n    sym_invT = symCNOT(binMatInv(U).T)\n    \n    targets = [sym, symT, sym_inv, sym_invT]\n    \n    best_result = None\n    for target in targets:\n        result = a_star_search(target, n, start_time)\n        if result and (best_result is None or result[1] < best_result[1]):\n            best_result = result\n            if best_result[1] <= 2*n:  # Early exit if near-optimal found\n                break\n    \n    if best_result is None:\n        return (n, 0, 0, time.time()-start_time, False, \"\")\n    \n    proc_time = time.time() - start_time\n    n, gate_count, depth, _, check, circ = best_result\n    return (n, gate_count, depth, proc_time, check, circ)\n\ndef a_star_search(target, n, start_time):\n    heap = []\n    initial_state = np.eye(2*n, dtype=int)\n    initial_cost = 0\n    initial_heuristic = heuristic(target, initial_state)\n    heapq.heappush(heap, (initial_cost + initial_heuristic, initial_cost, initial_heuristic, initial_state, []))\n    \n    visited = set()\n    best_heuristic = float('inf')\n    \n    while heap:\n        _, cost, h, current_state, path = heapq.heappop(heap)\n        \n        if time.time() - start_time > 15:  # Timeout\n            return None\n            \n        state_key = tuple(map(tuple, current_state))\n        if state_key in visited:\n            continue\n        visited.add(state_key)\n        \n        if np.array_equal(current_state, target):\n            depth = calculate_depth(path)\n            circ = circuit_to_string(path)\n            return (n, len(path), depth, 0, True, circ)\n        \n        if h < best_heuristic:\n            best_heuristic = h\n        \n        for op in generate_operations(current_state, n):\n            new_state = apply_operation(current_state, op)\n            new_cost = cost + 1\n            new_heuristic = heuristic(target, new_state)\n            \n            # Prune if heuristic is worse than best seen\n            if new_heuristic > best_heuristic + 2:\n                continue\n                \n            new_path = path + [op]\n            heapq.heappush(heap, (new_cost + new_heuristic, new_cost, new_heuristic, new_state, new_path))\n    \n    return None\n\ndef heuristic(target, current):\n    n = target.shape[0] // 2\n    diff = (target ^ current)[:n,:n]\n    col_sums = diff.sum(axis=0)\n    row_sums = diff.sum(axis=1)\n    \n    # Improved heuristic considering column/row weights and diagonal\n    h_col = sum(np.log2(s + 1) for s in col_sums if s > 0)\n    h_row = sum(np.log2(s + 1) for s in row_sums if s > 0)\n    h_diag = sum(1 for i in range(n) if diff[i,i] == 1)\n    \n    return (h_col + h_row + h_diag) / (3*n)\n\ndef generate_operations(state, n):\n    top = state[:n,:n]\n    operations = []\n    # Prioritize operations that affect multiple columns\n    for j in range(n):\n        sources = [i for i in range(n) if i != j and top[i,j] == 1]\n        if sources:\n            # Choose the source that affects most other columns\n            best_i = max(sources, key=lambda i: sum(top[i,k] for k in range(n)))\n            operations.append(('CX', (best_i,j)))\n    return operations\n\ndef apply_operation(state, op):\n    typ, (i,j) = op\n    n = state.shape[0] // 2\n    new_state = state.copy()\n    if typ == 'CX':\n        new_state[:,j] ^= new_state[:,i]\n        new_state[:,n+i] ^= new_state[:,n+j]\n    return new_state\n\ndef calculate_depth(path):\n    layers = []\n    for op in path:\n        typ, (i,j) = op\n        added = False\n        for layer in layers:\n            if i not in layer and j not in layer:\n                layer.update({i,j})\n                added = True\n                break\n        if not added:\n            layers.append({i,j})\n    return len(layers)\n\ndef circuit_to_string(path):\n    return ' '.join(f'CX:{i},{j}' for typ, (i,j) in path)\n\ndef symCNOT(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n,:n] = U % 2\n    inv = binMatInv(U.T % 2)\n    S[n:,n:] = inv % 2\n    return S\n\ndef binMatInv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i,i] == 0:\n            for j in range(i+1,n):\n                if aug[j,i] == 1:\n                    aug[[i,j]] = aug[[j,i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular\")\n        for j in range(n):\n            if j != i and aug[j,i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:,n:]\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 28,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 28,
    "parent_id": 8,
    "solution": "\nimport numpy as np\nimport time\nimport heapq\n\ndef search(U):\n    n = U.shape[0]\n    start_time = time.time()\n    max_time = 15  # seconds\n    \n    # Generate all equivalent matrices to consider\n    matrices = [symCNOT(U), symCNOT(binMatInv(U)), symCNOT(U.T)]\n    \n    best_result = None\n    for mat in matrices:\n        if time.time() - start_time > max_time:\n            break\n            \n        try:\n            # A* search with optimized heuristic\n            path = a_star_search(mat, start_time, max_time)\n            if path is None:\n                continue\n                \n            gate_count = len(path)\n            proc_time = time.time() - start_time\n            circ = path_to_string(path)\n            check = verify_synthesis(mat, path)\n            \n            if best_result is None or gate_count < best_result[1]:\n                best_result = (n, gate_count, len(path), proc_time, check, circ)\n                \n            # Early exit if perfect solution found\n            if gate_count <= n:\n                break\n                \n        except Exception:\n            continue\n            \n    if best_result is None:\n        return (n, 0, 0, 0, False, \"\")\n    return best_result\n\ndef a_star_search(target, start_time, max_time):\n    n = target.shape[0] // 2\n    heap = []\n    visited = set()\n    \n    # Initialize with identity matrix\n    initial = np.eye(2*n, dtype=int)\n    heapq.heappush(heap, (heuristic(initial, target), 0, [], initial))\n    \n    while heap:\n        if time.time() - start_time > max_time:\n            return None\n            \n        _, cost, path, current = heapq.heappop(heap)\n        \n        # Check if we've reached the target\n        if np.array_equal(current, target):\n            return path\n            \n        # Skip if we've already visited this state\n        state_hash = matrix_hash(current)\n        if state_hash in visited:\n            continue\n        visited.add(state_hash)\n        \n        # Generate next possible operations\n        for op in generate_operations(current, n):\n            new_matrix = apply_operation(current, op)\n            new_path = path + [op]\n            new_cost = cost + 1\n            priority = new_cost + heuristic(new_matrix, target)\n            \n            heapq.heappush(heap, (priority, new_cost, new_path, new_matrix))\n    \n    return None\n\ndef heuristic(current, target):\n    n = current.shape[0] // 2\n    diff = (current != target).astype(int)\n    \n    # Upper left block (original matrix)\n    ul = diff[:n, :n].sum()\n    # Lower right block (inverse matrix)\n    lr = diff[n:, n:].sum()\n    \n    # Column sums heuristic\n    current_ul = current[:n, :n]\n    target_ul = target[:n, :n]\n    col_heuristic = 0\n    for j in range(n):\n        col_diff = (current_ul[:,j] != target_ul[:,j]).sum()\n        if col_diff > 0:\n            col_heuristic += np.log(col_diff + 1)\n    \n    # Row sums heuristic\n    row_heuristic = 0\n    for i in range(n):\n        row_diff = (current_ul[i,:] != target_ul[i,:]).sum()\n        if row_diff > 0:\n            row_heuristic += np.log(row_diff + 1)\n    \n    return ul + lr + col_heuristic + row_heuristic\n\ndef generate_operations(matrix, n):\n    operations = []\n    top = matrix[:n, :n]\n    \n    # Generate CNOT operations\n    for i in range(n):\n        for j in range(n):\n            if i != j and top[i,j] == 1:\n                operations.append(('CNOT', i, j))\n    \n    return operations\n\ndef apply_operation(matrix, operation):\n    op_type, *qubits = operation\n    n = matrix.shape[0] // 2\n    new_matrix = matrix.copy()\n    \n    if op_type == 'CNOT':\n        control, target = qubits\n        # Apply CNOT to upper left block\n        new_matrix[:n, target] ^= new_matrix[:n, control]\n        # Apply CNOT to lower right block\n        new_matrix[n:, control] ^= new_matrix[n:, target]\n    \n    return new_matrix\n\ndef matrix_hash(matrix):\n    return hash(matrix.tobytes())\n\ndef path_to_string(path):\n    return ' '.join(f'{op[0]}:{op[1]},{op[2]}' for op in path)\n\ndef verify_synthesis(target, path):\n    n = target.shape[0] // 2\n    current = np.eye(2*n, dtype=int)\n    for op in path:\n        current = apply_operation(current, op)\n    return np.array_equal(current, target)\n\ndef symCNOT(U):\n    m,n = U.shape\n    U2 = np.zeros((2*n,2*n),dtype=int)\n    U2[:n,:n] = U\n    Uinv = binMatInv(U.T)\n    U2[n:,n:] = Uinv\n    return U2\n\ndef binMatInv(A):\n    A = A.copy()\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i,i] == 0:\n            for j in range(i+1,n):\n                if aug[j,i] == 1:\n                    aug[[i,j]] = aug[[j,i]]\n                    break\n        for j in range(n):\n            if j != i and aug[j,i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:,n:]\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 29,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 29,
    "parent_id": 6,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'beam_width': 3,\n        'max_depth': 50,\n        'timeout': 15,\n        'use_inverse': True,\n        'use_transpose': True\n    }\n    sym = symCNOT(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list = beam_search(U, params)\n    if not op_list:\n        return n, 0, 0, time.time()-start, False, \"\"\n    circ = op_list_to_string(op_list)\n    check = sym_test(U, op_list)\n    gate_count = count_entangling(op_list)\n    depth = len(op_list_layers(op_list))\n    proc_time = time.time() - start\n    return n, gate_count, depth, proc_time, check, circ\n\ndef beam_search(U, params):\n    n = U.shape[1] // 2\n    beam = [(U, [], 0)]\n    best_h = float('inf')\n    best_state = None\n    \n    for _ in range(params['max_depth']):\n        new_beam = []\n        for state in beam:\n            current_U, ops, current_h = state\n            if current_h < 1e-6:\n                return ops\n            for op in generate_ops(current_U, params):\n                new_U = apply_op(current_U, op)\n                new_ops = ops + [op]\n                h = advanced_heuristic(new_U)\n                new_beam.append((new_U, new_ops, h))\n        \n        if not new_beam:\n            break\n            \n        new_beam.sort(key=lambda x: x[2])\n        beam = new_beam[:params['beam_width']]\n        \n        if time.time() - start > params['timeout']:\n            break\n    \n    if beam:\n        return beam[0][1]\n    return []\n\ndef advanced_heuristic(U):\n    n = U.shape[1] // 2\n    top = U[:n,:n]\n    bot = U[n:,:n]\n    \n    # Column sums\n    col_sums_top = np.sum(top, axis=0)\n    col_sums_bot = np.sum(bot, axis=0)\n    \n    # Row sums\n    row_sums_top = np.sum(top, axis=1)\n    row_sums_bot = np.sum(bot, axis=1)\n    \n    # Combined metrics\n    h_col = np.sum(np.log(np.maximum(1, col_sums_top))) + np.sum(np.log(np.maximum(1, col_sums_bot)))\n    h_row = np.sum(np.log(np.maximum(1, row_sums_top))) + np.sum(np.log(np.maximum(1, row_sums_bot)))\n    h_total = (h_col + h_row) / (4 * n)\n    \n    return h_total\n\ndef generate_ops(U, params):\n    n = U.shape[1] // 2\n    top = U[:n,:n]\n    bot = U[n:,:n]\n    ops = []\n    \n    # Forward CNOTs\n    for i in range(n):\n        for j in range(n):\n            if i != j and top[j,i] == 1:\n                ops.append(('CX', (i,j)))\n    \n    # Inverse CNOTs if enabled\n    if params['use_inverse']:\n        for i in range(n):\n            for j in range(n):\n                if i != j and bot[j,i] == 1:\n                    ops.append(('CX', (j,i)))\n    \n    return ops\n\ndef symCNOT(U):\n    m,n = U.shape\n    U2 = np.zeros((2*n,2*n),dtype=int)\n    U2[:n,:n] = U\n    Uinv = binMatInv(U.T)\n    U2[n:,n:] = Uinv\n    return U2\n\ndef binMatInv(M):\n    n = M.shape[0]\n    I = np.eye(n, dtype=int)\n    M = np.hstack([M, I])\n    for i in range(n):\n        if M[i,i] == 0:\n            for j in range(i+1,n):\n                if M[j,i] == 1:\n                    M[[i,j]] = M[[j,i]]\n                    break\n        for j in range(i+1,n):\n            if M[j,i] == 1:\n                M[j] ^= M[i]\n    for i in range(n-1,-1,-1):\n        for j in range(i-1,-1,-1):\n            if M[j,i] == 1:\n                M[j] ^= M[i]\n    return M[:,n:]\n\ndef apply_op(U, op):\n    op_type, (i,j) = op\n    n = U.shape[0] // 2\n    if op_type == 'CX':\n        new_U = U.copy()\n        new_U[:n,j] ^= new_U[:n,i]\n        new_U[n:,i] ^= new_U[n:,j]\n        return new_U\n    return U\n\ndef op_list_to_string(op_list):\n    return \";\".join(f\"{op[0]}_{op[1][0]}_{op[1][1]}\" for op in op_list)\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'CX'])\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    used = set()\n    for op in op_list:\n        if op[0] == 'CX':\n            i,j = op[1]\n            if i in used or j in used:\n                layers.append(current_layer)\n                current_layer = [op]\n                used = {i,j}\n            else:\n                current_layer.append(op)\n                used.update({i,j})\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef sym_test(U, op_list):\n    n = U.shape[0] // 2\n    test_U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        test_U = apply_op(test_U, op)\n    return np.array_equal(U, test_U)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 30,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 30,
    "parent_id": 13,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved search.py with better heuristic and search parameters.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n    \"\"\"\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,  # Reduced from 3\n        'wMax': 15  # Increased from 10\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            return [], A\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    # Consider both original and transpose matrices\n    U1 = U[:n, :n]\n    U2 = U1.T\n    U3 = bin_mat_inv(U1)\n    U4 = bin_mat_inv(U1.T)\n    \n    sA = []\n    for M in [U1, U2, U3, U4]:\n        if params['ht']:\n            sA.extend(M.sum(axis=0).tolist())\n            sA.extend(M.sum(axis=1).tolist())\n        else:\n            sA.extend(M.sum(axis=0).tolist())\n    \n    # Column-wise heuristic\n    col_heuristics = []\n    for col in U1.T:\n        w = col.sum()\n        if w == 0:\n            col_heuristics.append(0)\n        else:\n            col_heuristics.append(np.log(w) if params['hl'] else w-1)\n    \n    w = tuple(sorted(int(x) for x in sA))\n    h0 = np.mean(col_heuristics)\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = (top.T @ top) % 2\n    rows, cols = np.nonzero(prod)\n    opts = []\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-reasoner",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 25,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 31,
    "parent_id": 3,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'beam_width': 10,  # Increased beam width for better exploration\n        'max_depth': 50,\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], (float('inf'), float('inf')))])\n    best_h = (float('inf'), float('inf'))\n    best_state = None\n    \n    for depth in range(params['max_depth']):\n        if not beam:\n            break\n            \n        next_beam = []\n        \n        for U, ops, _ in beam:\n            h_val = gl_heuristic(U, params)\n            if h_val[0] == 0:  # Check if primary heuristic is 0 (permutation matrix)\n                return ops, U\n                \n            for op in gl_options(U):\n                new_U = apply_op(U, op)\n                new_ops = ops + [op]\n                new_h = gl_heuristic(new_U, params)\n                next_beam.append((new_U, new_ops, new_h))\n        \n        next_beam.sort(key=lambda x: x[2])  # Sort by heuristic tuple\n        beam = deque(next_beam[:params['beam_width']])\n        \n        if beam:\n            current_best = beam[0][2]\n            if current_best < best_h:\n                best_h = current_best\n                best_state = (beam[0][0], beam[0][1])\n    \n    if best_state:\n        return best_state[1], best_state[0]\n    return [], A\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    total_ones = np.sum(top)\n    h_primary = total_ones - n  # Primary heuristic: extra ones beyond permutation matrix\n    \n    col_weights = top.sum(axis=0)\n    row_weights = top.sum(axis=1)\n    num_weight1_cols = np.count_nonzero(col_weights == 1)\n    num_weight1_rows = np.count_nonzero(row_weights == 1)\n    # Secondary: maximize total weight-1 columns+rows (minimize negative)\n    secondary = - (num_weight1_cols + num_weight1_rows)  \n    \n    return (h_primary, secondary)\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-reasoner",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 24,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  }
]