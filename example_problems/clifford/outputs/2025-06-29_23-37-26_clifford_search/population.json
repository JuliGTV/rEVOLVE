[
  {
    "id": 1,
    "parent_id": null,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Fixed parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 10\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            # abort and return identity mapping\n            return [], A\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    if params['ht']:\n        sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    else:\n        sA = U.sum(axis=0)\n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    if params['hl']:\n        h0 = np.log(sA).sum() / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n# Single-qubit Clifford layer extraction\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n\n",
    "evaluation": {
      "fitness": 4.833333333333329,
      "additional_data": {
        "score": "4.833333",
        "total_compute_time": "4.814828",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 19,
    "creation_info": null
  },
  {
    "id": 2,
    "parent_id": 1,
    "solution": "\nimport numpy as np\nimport time\n\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,\n        'wMax': 5\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U, params):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            return [], A\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    if params['ht']:\n        sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    else:\n        sA = U.sum(axis=0)\n    if params['hi']:\n        inv_U = bin_mat_inv(U[:U.shape[0]//2, :U.shape[1]//2])\n        sA_inv = np.concatenate([inv_U.sum(axis=0), inv_U.sum(axis=1)])\n        sA = np.concatenate([sA, sA_inv])\n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    if params['hl']:\n        h0 = np.log(sA + 1e-10).sum() / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    return params['hr'] * h0, w\n\n\ndef gl_options(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "43.074259",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 2,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 1,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 3,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved CNOT circuit synthesis using beam search with enhanced heuristics.\n\"\"\"\n\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,\n        'wMax': 15,\n        'beam_width': 3,\n        'lookahead': 2\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], 0)])\n    \n    for _ in range(params['wMax'] * 2):\n        new_beam = []\n        for state in beam:\n            U, ops, wait = state\n            h_val = gl_heuristic_enhanced(U, params)\n            if h_val <= 0.1:\n                return ops, U\n            \n            candidates = []\n            for op in enhanced_gl_options(U):\n                B = apply_op(U.copy(), op)\n                hB = gl_heuristic_enhanced(B, params)\n                candidates.append((hB, B, op))\n            \n            candidates.sort()\n            for hB, B, op in candidates[:params['beam_width']]:\n                new_ops = ops + [op]\n                if hB < h_val:\n                    new_beam.append((B, new_ops, 0))\n                else:\n                    new_beam.append((B, new_ops, wait + 1))\n        \n        if not new_beam:\n            break\n            \n        new_beam.sort(key=lambda x: (gl_heuristic_enhanced(x[0], params), len(x[1])))\n        beam = deque(new_beam[:params['beam_width']])\n    \n    best_state = min(beam, key=lambda x: (gl_heuristic_enhanced(x[0], params), len(x[1])))\n    return best_state[1], best_state[0]\n\ndef gl_heuristic_enhanced(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    \n    # Consider matrix and its variants\n    mats = [top]\n    if params['hi']:\n        mats.append(bin_mat_inv(top.T))\n    if params['ht']:\n        mats.append(top.T)\n    \n    min_h = float('inf')\n    for mat in mats:\n        col_sums = mat.sum(axis=0)\n        row_sums = mat.sum(axis=1)\n        \n        # Column-wise log heuristic\n        h_col = 0\n        for s in col_sums:\n            if s > 0:\n                h_col += np.log(s)\n        \n        # Row-wise log heuristic\n        h_row = 0\n        for s in row_sums:\n            if s > 0:\n                h_row += np.log(s)\n        \n        # Combined heuristic\n        h = (h_col + h_row) / (2 * n)\n        if h < min_h:\n            min_h = h\n    \n    return min_h\n\ndef enhanced_gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    options = []\n    \n    # Consider all possible CNOTs\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                options.append(('CX', (i, j)))\n    \n    return options\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()",
        "execution_method": "single_subprocess"
      }
    },
    "children": 3,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 4,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 4,
    "parent_id": 1,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,\n        'wMax': 8,\n        'beam_width': 3,\n        'max_steps': 100\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params) if params['method'] == 'beam' else csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], 0)])\n    best_h = float('inf')\n    best_state = None\n    \n    for step in range(params['max_steps']):\n        new_beam = deque()\n        for state in beam:\n            U, ops, wait = state\n            h_val, h_tuple = enhanced_heuristic(U, params)\n            \n            if h_val <= 1e-5:\n                return ops, U\n                \n            if h_val < best_h:\n                best_h = h_val\n                best_state = (U, ops, wait)\n                \n            candidates = []\n            for op in filtered_gl_options(U):\n                B = apply_op(U, op)\n                hB_val, hB_tuple = enhanced_heuristic(B, params)\n                new_ops = ops + [op]\n                candidates.append((B, new_ops, 0, hB_val))\n                \n            candidates.sort(key=lambda x: x[3])\n            new_beam.extend(candidates[:params['beam_width']])\n            \n        if not new_beam:\n            break\n        beam = new_beam\n        \n    return best_state[1], best_state[0]\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = float('inf')\n    curr_wait = 0\n    \n    for _ in range(params['max_steps']):\n        h_val, h_tuple = enhanced_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        best_op = None\n        best_h = float('inf')\n        best_U = None\n        \n        for op in filtered_gl_options(U):\n            B = apply_op(U, op)\n            hB_val, _ = enhanced_heuristic(B, params)\n            if hB_val < best_h:\n                best_h = hB_val\n                best_op = op\n                best_U = B\n                \n        if best_op is None:\n            break\n            \n        op_list.append(best_op)\n        U = best_U\n        \n        if best_h < h_min:\n            h_min = best_h\n            curr_wait = 0\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n                \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef enhanced_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    col_sums = U.sum(axis=0)\n    row_sums = U.sum(axis=1) if params['ht'] else np.zeros(2*n)\n    \n    log_sum = np.log(np.maximum(col_sums, 1)).sum()\n    sum_diff = (col_sums - 1).sum()\n    row_penalty = row_sums.sum() if params['ht'] else 0\n    \n    h0 = (log_sum + sum_diff + row_penalty) / (3 * n)\n    w = tuple(sorted(col_sums.astype(int)))\n    \n    return params['hr'] * h0, w\n\ndef filtered_gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    rows, cols = np.nonzero(prod)\n    return [('CX', (i, j)) for i, j in zip(rows, cols) if i != j]\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: too many values to unpack (expected 3)",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 3,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 3
    }
  },
  {
    "id": 5,
    "parent_id": 1,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 15,\n        'beam_width': 5,\n        'lookahead': 2\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = [(A.copy(), [], 0)]\n    best_h = float('inf')\n    best_state = None\n    \n    for _ in range(params['wMax'] * 10):\n        new_beam = []\n        for state in beam:\n            U, ops, wait = state\n            h_val, h_tuple = enhanced_heuristic(U, params)\n            \n            if h_val <= 1e-5:\n                return ops, U\n            \n            if h_val < best_h:\n                best_h = h_val\n                best_state = (U.copy(), ops.copy(), wait)\n            \n            candidates = []\n            for op in gl_options(U):\n                B = apply_op(U, op)\n                new_ops = ops + [op]\n                new_h, _ = enhanced_heuristic(B, params)\n                candidates.append((B, new_ops, wait + 1, new_h))\n            \n            candidates.sort(key=lambda x: x[3])\n            new_beam.extend(candidates[:params['beam_width']])\n        \n        beam = []\n        for state in new_beam:\n            U, ops, wait, h_val = state\n            if h_val < best_h * 1.5:\n                beam.append((U, ops, wait))\n        \n        if len(beam) == 0:\n            break\n    \n    if best_state:\n        return best_state[1], best_state[0]\n    return [], A\n\ndef enhanced_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    \n    col_sums_top = top.sum(axis=0)\n    col_sums_bot = bot.sum(axis=0)\n    row_sums_top = top.sum(axis=1)\n    row_sums_bot = bot.sum(axis=1)\n    \n    h_col = sum((s-1)**2 for s in col_sums_top) + sum((s-1)**2 for s in col_sums_bot)\n    h_row = sum((s-1)**2 for s in row_sums_top) + sum((s-1)**2 for s in row_sums_bot)\n    \n    h_entropy = 0\n    for i in range(n):\n        for j in range(n):\n            if top[i,j] == 1:\n                h_entropy += 1/(col_sums_top[j] + 1e-6)\n            if bot[i,j] == 1:\n                h_entropy += 1/(col_sums_bot[j] + 1e-6)\n    \n    h_total = h_col + h_row + 0.5 * h_entropy\n    w_tuple = tuple(sorted(col_sums_top)) + tuple(sorted(col_sums_bot))\n    \n    return h_total, w_tuple\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    prod_top = top.T @ top\n    prod_bot = bot.T @ bot\n    opts = []\n    \n    rows, cols = np.nonzero(prod_top)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    \n    rows, cols = np.nonzero(prod_bot)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (j, i)))\n    \n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation timed out after 60 seconds",
        "execution_method": "single_subprocess"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 2,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 4
    }
  },
  {
    "id": 6,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 4,  # Increased heuristic weight\n        'wMax': 8  # Reduced wait time\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    h_list = []\n    \n    # Consider original matrix\n    sA = U.sum(axis=0)\n    w = tuple(sorted(int(x) for x in sA))\n    h0 = np.log(sA + 1e-6).sum() / len(sA)\n    h_list.append((h0, w))\n    \n    # Consider transpose if enabled\n    if params['ht']:\n        sA_t = U.T.sum(axis=0)\n        w_t = tuple(sorted(int(x) for x in sA_t))\n        h0_t = np.log(sA_t + 1e-6).sum() / len(sA_t)\n        h_list.append((h0_t, w_t))\n    \n    # Consider inverse if enabled\n    if params['hi']:\n        try:\n            inv = bin_mat_inv(U[:n, :n].T % 2)\n            sA_i = inv.sum(axis=0)\n            w_i = tuple(sorted(int(x) for x in sA_i))\n            h0_i = np.log(sA_i + 1e-6).sum() / len(sA_i)\n            h_list.append((h0_i, w_i))\n        except:\n            pass\n    \n    # Return the best heuristic found\n    min_h = min(h_list)\n    return params['hr'] * min_h[0], min_h[1]\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n# Single-qubit Clifford layer extraction\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "3.366999",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 5,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 5
    }
  },
  {
    "id": 7,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,  # Reduced from 3 to balance components\n        'wMax': 8  # Reduced from 10 to speed up\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    best_h = float('inf')\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        if h_val < best_h:\n            best_h = h_val\n            curr_wait = 0\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    sA = U.sum(axis=0)\n    if params['ht']:\n        sA = np.concatenate([sA, U.sum(axis=1)])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    # Enhanced heuristic components\n    h_components = []\n    if params['hl']:\n        h_components.append(np.log(sA + 1e-10).sum() / len(sA))\n    if params['hi']:\n        inv_U = bin_mat_inv(U[:n,:n].T % 2)\n        h_components.append((inv_U.sum() / n**2))\n    \n    h0 = sum(h_components) / len(h_components) if h_components else 0\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    # Add more options based on column sums\n    col_sums = top.sum(axis=0)\n    for j in np.where(col_sums > 1)[0]:\n        for i in np.where(top[:,j] == 1)[0]:\n            if i != j:\n                opts.append(('CX', (i, j)))\n    return opts\n\n# [Rest of the helper functions remain exactly the same as in the original solution]\ndef apply_op(U, op): ...\ndef op_list_layers(op_list): ...\ndef count_entangling(op_list): ...\ndef op_list_to_string(op_list, sep=' '): ...\ndef sym_cnot(U): ...\ndef bin_mat_inv(A): ...\ndef sym_r2(U): ...\ndef perm_mat_to_ix(P): ...\ndef ix_rev(ix): ...\ndef Fmat(U, i, j): ...\ndef SQC2str(A): ...\ndef CList2opList(CList): ...\ndef mat2SQC(UC): ...\ndef op_list2sym(op_list, n): ...\ndef sym_test(U, ops): ...\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: 'NoneType' object has no attribute 'shape'",
        "execution_method": "single_subprocess"
      }
    },
    "children": 6,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 6,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 6
    }
  },
  {
    "id": 8,
    "parent_id": 1,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappush, heappop\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    # Generate all equivalent matrices to consider\n    matrices = [\n        (U, 'original'),\n        (bin_mat_inv(U.T), 'inverse_transpose'),\n        (U.T, 'transpose'),\n        (bin_mat_inv(U), 'inverse')\n    ]\n    \n    best_result = None\n    best_gates = float('inf')\n    \n    for mat, desc in matrices:\n        try:\n            sym = sym_cnot(mat)\n            op_list, UC = beam_search(sym, beam_width=3, max_depth=20)\n            sqc_ops = mat2SQC(UC)\n            full_ops = sqc_ops + op_list\n            gate_count = count_entangling(full_ops)\n            \n            if gate_count < best_gates:\n                best_gates = gate_count\n                best_result = (n, gate_count, len(op_list_layers(full_ops)), \n                              time.time() - start, True, op_list_to_string(full_ops))\n        except:\n            continue\n    \n    if best_result is None:\n        return (n, 0, 0, time.time()-start, False, \"\")\n    return best_result\n\ndef beam_search(U, beam_width=3, max_depth=20):\n    beam = [(0, [], U.copy())]\n    \n    for _ in range(max_depth):\n        new_beam = []\n        \n        for _, ops, current in beam:\n            if is_identity(current):\n                return ops, current\n                \n            for op in extended_gl_options(current):\n                new_U = apply_op(current, op)\n                new_ops = ops + [op]\n                h = advanced_heuristic(new_U)\n                heappush(new_beam, (h, new_ops, new_U))\n                \n                if len(new_beam) > beam_width * 10:\n                    new_beam = new_beam[:beam_width]\n        \n        if not new_beam:\n            break\n            \n        beam = new_beam[:beam_width]\n    \n    # Return best found if not identity\n    if beam:\n        return beam[0][1], beam[0][2]\n    return [], U\n\ndef advanced_heuristic(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    # Column-wise metrics\n    col_sums = top.sum(axis=0)\n    log_cols = np.log(np.maximum(col_sums, 1)).sum()\n    \n    # Row-wise metrics\n    row_sums = top.sum(axis=1)\n    log_rows = np.log(np.maximum(row_sums, 1)).sum()\n    \n    # Diagonal dominance\n    diag = np.trace(top)\n    off_diag = top.sum() - diag\n    \n    # Combined heuristic\n    h = (log_cols + log_rows) / (2*n) + off_diag/(n*n)\n    return h\n\ndef extended_gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    \n    # Add all possible CNOTs\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                opts.append(('CX', (i, j)))\n                opts.append(('CX', (j, i)))\n    \n    # Add permutations\n    for i in range(n):\n        for j in range(i+1, n):\n            opts.append(('QPerm', (i, j)))\n    \n    return opts\n\ndef is_identity(U):\n    n = U.shape[1] // 2\n    return np.array_equal(U[:n, :n], np.eye(n)) and np.array_equal(U[n:, n:], np.eye(n))\n\n# All other helper functions remain the same as in the original solution\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 2,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 10,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 7
    }
  },
  {
    "id": 9,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2.5,  # Tuned heuristic weight\n        'wMax': 8    # Reduced patience\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        options = gl_options(U)\n        # Sort options by potential improvement\n        options.sort(key=lambda op: gl_heuristic(apply_op(U, op), params)[0])\n        for op in options[:min(5, len(options))]:  # Limit options to top 5\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or hB_val < h_min[1]:\n            curr_wait = 0\n            h_min = (h_tuple, hB_val)\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    sA = U.sum(axis=0)\n    if params['ht']:\n        sA = np.concatenate([sA, U.sum(axis=1)])\n    if params['hi']:\n        inv_U = bin_mat_inv(U[:n,:n].T % 2)\n        sA_inv = inv_U.sum(axis=0)\n        if params['ht']:\n            sA_inv = np.concatenate([sA_inv, inv_U.sum(axis=1)])\n        sA = np.minimum(sA, sA_inv)  # Take minimum of original and inverse\n    \n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    if params['hl']:\n        h0 = np.log(np.maximum(sA, 1)).sum() / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n# Single-qubit Clifford layer extraction\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: operands could not be broadcast together with shapes (64,) (32,) ",
        "execution_method": "single_subprocess"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 8,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 8
    }
  },
  {
    "id": 10,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,  # Reduced from 3\n        'wMax': 15  # Increased from 10\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            # abort and return identity mapping\n            return [], A\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    if params['ht']:\n        sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    else:\n        sA = U.sum(axis=0)\n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    if params['hl']:\n        h0 = np.log(sA + 1e-10).sum() / Ls  # Added small epsilon\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    if params['hi']:\n        inv_U = bin_mat_inv(U[:n, :n].T)\n        h_inv = np.log(inv_U.sum(axis=0) + 1e-10).sum() / n\n        h0 = min(h0, h_inv)\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    # Add more options by considering inverse\n    inv_top = bin_mat_inv(top.T)\n    prod_inv = inv_top.T @ inv_top\n    rows, cols = np.nonzero(prod_inv)\n    for i, j in zip(rows, cols):\n        if i != j and ('CX', (i, j)) not in opts:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: name 'n' is not defined",
        "execution_method": "single_subprocess"
      }
    },
    "children": 2,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 9,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 9
    }
  },
  {
    "id": 11,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,  # Reduced from 3\n        'wMax': 8  # Reduced from 10\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5 or np.array_equal(U[:n, :n], np.eye(n)):\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            # abort and return identity mapping\n            return [], A\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    if params['ht']:\n        sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    else:\n        sA = U.sum(axis=0)\n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    \n    if params['hl']:\n        log_sums = np.log(np.maximum(sA, 1))\n        h0 = log_sums.sum() / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    \n    # Consider inverse/transpose if enabled\n    if params['hi']:\n        inv_U = bin_mat_inv(U[:n, :n].T)\n        inv_sA = inv_U.sum(axis=0)\n        if params['hl']:\n            inv_log = np.log(np.maximum(inv_sA, 1))\n            h0 = min(h0, inv_log.sum() / n)\n        else:\n            h0 = min(h0, (inv_U.sum() / n - 1))\n    \n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n# Single-qubit Clifford layer extraction\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "37.271596",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 7,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 10
    }
  },
  {
    "id": 12,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\nimport math\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 4,  # Increased from 3\n        'wMax': 15  # Increased from 10\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    best_h = float('inf')\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        if h_val < best_h - 1e-5:\n            best_h = h_val\n            curr_wait = 0\n        else:\n            curr_wait += 1\n        \n        if curr_wait > params['wMax']:\n            return [], A\n            \n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    col_sums = U.sum(axis=0)\n    row_sums = U.sum(axis=1)\n    sA = np.concatenate([col_sums, row_sums])\n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    \n    log_sum = 0\n    for x in sA:\n        if x > 0:\n            log_sum += math.log(x)\n    h0 = log_sum / Ls\n    \n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 4.799999999999997,
      "additional_data": {
        "score": "4.800000",
        "total_compute_time": "5.823775",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 4,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 11,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 11
    }
  },
  {
    "id": 13,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\nfrom collections import defaultdict\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,  # Increased heuristic resolution\n        'wMax': 15,  # Increased patience\n        'max_iters': 200,\n        'early_term': 0.01\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    no_improve = 0\n    \n    for _ in range(params['max_iters']):\n        h_val, h_tuple = enhanced_heuristic(U, params)\n        if h_val <= params['early_term']:\n            break\n            \n        best_op = None\n        best_delta = float('inf')\n        best_U = None\n        \n        for op in expanded_gl_options(U):\n            new_U = apply_op(U, op)\n            new_h, _ = enhanced_heuristic(new_U, params)\n            delta = new_h - h_val\n            \n            if delta < best_delta:\n                best_delta = delta\n                best_op = op\n                best_U = new_U\n        \n        if best_op is None:\n            break\n            \n        op_list.append(best_op)\n        U = best_U\n        \n        if h_val < best_h:\n            best_h = h_val\n            no_improve = 0\n        else:\n            no_improve += 1\n            if no_improve > params['wMax']:\n                break\n    \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef enhanced_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    # Basic metrics\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    total_sum = top.sum()\n    \n    # Log metrics\n    log_cols = np.log(np.maximum(col_sums, 1))\n    log_rows = np.log(np.maximum(row_sums, 1))\n    \n    # Column-wise metrics\n    col_metrics = tuple(sorted(col_sums))\n    row_metrics = tuple(sorted(row_sums))\n    \n    # Consider inverse and transpose\n    inv_metrics = tuple(sorted(bottom.sum(axis=0)))\n    trans_metrics = tuple(sorted(top.T.sum(axis=0)))\n    \n    # Combined heuristic value\n    h_sum = total_sum / (n*n)\n    h_log = (log_cols.sum() + log_rows.sum()) / (2*n)\n    h_col = sum(1/x for x in col_sums if x > 0) / n\n    \n    combined_h = 0.4*h_sum + 0.3*h_log + 0.3*h_col\n    \n    # Combined tuple for tie-breaking\n    h_tuple = (col_metrics, row_metrics, inv_metrics, trans_metrics)\n    \n    return combined_h, h_tuple\n\ndef expanded_gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    options = []\n    \n    # Standard CX options\n    prod = top.T @ top\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            options.append(('CX', (i, j)))\n    \n    # Additional options based on row operations\n    for i in range(n):\n        for j in range(n):\n            if i != j and top[i,j] == 1:\n                options.append(('CX', (i, j)))\n    \n    return options\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 2,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 12,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 12
    }
  },
  {
    "id": 14,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 4,  # Increased heuristic weight\n        'wMax': 8  # Reduced wait time\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or best < h_min:\n            curr_wait = 0\n            h_min = best\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            # abort and return identity mapping\n            return [], A\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    if params['ht']:\n        sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    else:\n        sA = U.sum(axis=0)\n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    if params['hl']:\n        h0 = np.log(sA + 1e-6).sum() / Ls  # Avoid log(0)\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    \n    # Consider inverse matrix if enabled\n    if params['hi']:\n        invU = bin_mat_inv(U[:n,:n].T)\n        inv_heuristic = np.log(invU.sum(axis=0) + 1).sum() / n\n        h0 = min(h0, inv_heuristic)\n    \n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n            # Also consider inverse operation\n            opts.append(('CX', (j, i)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n# Single-qubit Clifford layer extraction\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: name 'n' is not defined",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 14,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 13
    }
  },
  {
    "id": 15,
    "parent_id": 1,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import defaultdict\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 4,\n        'wMax': 15,\n        'max_iter': 200,\n        'early_term': 0.001\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    best_U = None\n    best_ops = []\n    curr_wait = 0\n    prev_h = float('inf')\n    improvement_rate = 1.0\n    \n    for iteration in range(params['max_iter']):\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        if h_val < best_h:\n            best_h = h_val\n            best_U = U.copy()\n            best_ops = op_list.copy()\n            curr_wait = 0\n        else:\n            curr_wait += 1\n            \n        if curr_wait > params['wMax']:\n            U = best_U\n            op_list = best_ops\n            break\n            \n        if iteration > 10 and abs(prev_h - h_val) / prev_h < params['early_term']:\n            break\n        prev_h = h_val\n        \n        best_op = None\n        best_dh = float('inf')\n        best_B = None\n        \n        for op in gl_options(U, params):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            dh = hB_val - h_val\n            \n            if dh < best_dh:\n                best_dh = dh\n                best_op = op\n                best_B = B\n                \n        if best_op is None:\n            break\n            \n        U = best_B\n        op_list.append(best_op)\n        \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    log_sum = np.log(np.maximum(col_sums, 1)).sum()\n    inv_log_sum = np.log(np.maximum(2 - col_sums, 1)).sum()\n    \n    h_sum = U.sum() - 2*n\n    h_log = log_sum + inv_log_sum\n    h_col = (col_sums * (col_sums - 1)).sum()\n    \n    h0 = 0.4*h_sum + 0.4*h_log + 0.2*h_col\n    w = tuple(sorted(col_sums)) + tuple(sorted(row_sums))\n    \n    return params['hr'] * h0, w\n\ndef gl_options(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    \n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n            opts.append(('CX', (j, i)))\n    \n    if params['hi']:\n        inv_top = bin_mat_inv(top)\n        inv_prod = inv_top.T @ inv_top\n        rows, cols = np.nonzero(inv_prod)\n        for i, j in zip(rows, cols):\n            if i != j:\n                opts.append(('CX_inv', (i, j)))\n                opts.append(('CX_inv', (j, i)))\n    \n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    \n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'CX_inv':\n        i, j = q\n        U_new[:, i] ^= U_new[:, j]\n        U_new[:, n + j] ^= U_new[:, n + i]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    \n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ.startswith('CX'))\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "25.485743",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 13,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 14
    }
  },
  {
    "id": 16,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved search.py - Enhanced CNOT circuit synthesis with better heuristics.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,  # Reduced from 3\n        'wMax': 8  # Reduced from 10\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        candidates = []\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            candidates.append((key, hB_val, op, B))\n        \n        # Sort candidates by heuristic\n        candidates.sort()\n        best_key, best_h_val, best_op, best_B = candidates[0]\n        \n        # Early termination if no improvement\n        if best_h_val >= h_val and curr_wait > params['wMax']//2:\n            break\n            \n        U = best_B\n        op_list.append(best_op)\n        \n        if best_h_val < best_h:\n            best_h = best_h_val\n            curr_wait = 0\n        else:\n            curr_wait += 1\n            \n        if curr_wait > params['wMax']:\n            break\n\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    \n    # Consider multiple matrix representations\n    matrices = [top]\n    if params['ht']:\n        matrices.append(top.T)\n    if params['hi']:\n        matrices.append(bin_mat_inv(top))\n    \n    # Enhanced column-wise heuristic\n    col_heuristics = []\n    for M in matrices:\n        col_sums = M.sum(axis=0)\n        col_nonzero = (M != 0).sum(axis=0)\n        col_heuristic = np.log(col_sums + 1e-6) - 0.5 * np.log(col_nonzero + 1e-6)\n        col_heuristics.append(col_heuristic)\n    \n    # Combine heuristics\n    h_col = np.mean(col_heuristics)\n    h_sum = U.sum() / (2 * n * n) - 1\n    h_total = params['hr'] * (0.6 * h_col + 0.4 * h_sum)\n    \n    # Weight tuple\n    sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    return h_total, w\n\n\n# [Rest of the helper functions remain exactly the same as in the original solution]\ndef gl_options(U): ...\ndef apply_op(U, op): ...\ndef op_list_layers(op_list): ...\ndef count_entangling(op_list): ...\ndef op_list_to_string(op_list, sep=' '): ...\ndef sym_cnot(U): ...\ndef bin_mat_inv(A): ...\ndef sym_r2(U): ...\ndef perm_mat_to_ix(P): ...\ndef ix_rev(ix): ...\ndef Fmat(U, i, j): ...\ndef SQC2str(A): ...\ndef CList2opList(CList): ...\ndef mat2SQC(UC): ...\ndef op_list2sym(op_list, n): ...\ndef sym_test(U, ops): ...\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: 'NoneType' object has no attribute 'shape'",
        "execution_method": "single_subprocess"
      }
    },
    "children": 3,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 17,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 15
    }
  },
  {
    "id": 17,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved search.py with enhanced heuristic and search strategy.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 4,  # Increased heuristic weight\n        'wMax': 8  # Reduced patience\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        best = None\n        best_dh = None\n        best_B = None\n        \n        # Consider inverse if enabled\n        if params['hi'] and np.random.rand() < 0.1:  # 10% chance to consider inverse\n            inv_U = bin_mat_inv(U[:n,:n].T)\n            inv_h, inv_tuple = gl_heuristic(inv_U, params)\n            if inv_h < h_val:\n                U = inv_U\n                op_list.append(('INV', (0,)))  # Placeholder\n                continue\n                \n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n                \n        if best is None:\n            break\n            \n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        \n        if h_min is None or hB_val < h_min[1]:\n            curr_wait = 0\n            h_min = (h_tuple, hB_val)\n        else:\n            curr_wait += 1\n            \n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            break\n            \n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    if params['ht']:\n        sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    else:\n        sA = U.sum(axis=0)\n        \n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    \n    # Enhanced heuristic with multiple components\n    h_components = []\n    if params['hl']:\n        h_components.append(np.log(sA + 1e-6).sum() / Ls)\n    h_components.append((U.sum() / len(U) - 1))\n    \n    # Consider column/row variance\n    if params['ht']:\n        col_var = np.var(U.sum(axis=0))\n        row_var = np.var(U.sum(axis=1))\n        h_components.append(-0.1 * (col_var + row_var))  # Prefer more uniform distributions\n        \n    h0 = sum(h_components) / len(h_components)\n    return params['hr'] * h0, w\n\n\n# Rest of the functions remain exactly the same as in the original solution\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: tuple index out of range",
        "execution_method": "single_subprocess"
      }
    },
    "children": 3,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 15,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 16
    }
  },
  {
    "id": 18,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 4,  # Increased heuristic weight\n        'wMax': 8  # Reduced wait threshold\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or hB_val < h_min[1]:\n            curr_wait = 0\n            h_min = (h_tuple, hB_val)\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    if params['ht']:\n        sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    else:\n        sA = U.sum(axis=0)\n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    if params['hl']:\n        h0 = np.log(sA + 1e-10).sum() / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    if params['hi']:\n        invU = bin_mat_inv(U[:n, :n].T) % 2\n        inv_sA = np.concatenate([invU.sum(axis=0), invU.sum(axis=1)])\n        inv_w = tuple(sorted(int(x) for x in inv_sA))\n        inv_h0 = np.log(inv_sA + 1e-10).sum() / Ls\n        if inv_h0 < h0:\n            h0 = inv_h0\n            w = inv_w\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "41.769639",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 16,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 17
    }
  },
  {
    "id": 19,
    "parent_id": 8,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappush, heappop\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    try:\n        # Validate input matrix\n        if not isinstance(U, np.ndarray) or U.shape[0] != U.shape[1]:\n            return (n, 0, 0, time.time()-start, False, \"\")\n        \n        # Try both original and transposed versions\n        matrices = [U, U.T]\n        best_result = None\n        best_gates = float('inf')\n        \n        for mat in matrices:\n            try:\n                op_list, _ = beam_search(mat, beam_width=5, max_depth=30)\n                gate_count = len(op_list)\n                \n                if gate_count < best_gates:\n                    best_gates = gate_count\n                    depth = len(op_list_layers(op_list))\n                    best_result = (n, gate_count, depth, \n                                  time.time() - start, True, \n                                  op_list_to_string(op_list))\n            except:\n                continue\n        \n        if best_result is None:\n            return (n, 0, 0, time.time()-start, False, \"\")\n        return best_result\n    except:\n        return (n, 0, 0, time.time()-start, False, \"\")\n\ndef beam_search(U, beam_width=5, max_depth=30):\n    beam = [(0, [], U.copy())]\n    \n    for _ in range(max_depth):\n        new_beam = []\n        \n        for _, ops, current in beam:\n            if np.array_equal(current, np.eye(current.shape[0])):\n                return ops, current\n                \n            for op in generate_cnots(current.shape[0]):\n                new_U = apply_cnot(current, op)\n                new_ops = ops + [op]\n                h = heuristic(new_U)\n                heappush(new_beam, (h, new_ops, new_U))\n        \n        if not new_beam:\n            break\n            \n        beam = sorted(new_beam, key=lambda x: x[0])[:beam_width]\n    \n    if beam:\n        return beam[0][1], beam[0][2]\n    return [], U\n\ndef heuristic(U):\n    n = U.shape[0]\n    # Weight columns with fewer 1s higher\n    col_weights = U.sum(axis=0)\n    row_weights = U.sum(axis=1)\n    return (col_weights.sum() + row_weights.sum()) / (2*n) + (col_weights.max() - col_weights.min())\n\ndef generate_cnots(n):\n    return [(i, j) for i in range(n) for j in range(n) if i != j]\n\ndef apply_cnot(U, op):\n    i, j = op\n    U_new = U.copy()\n    U_new[:, j] ^= U_new[:, i]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for (i, j) in op_list:\n        qubits = {i, j}\n        placed = False\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                placed = True\n                break\n        if not placed:\n            layers.append(qubits)\n    return len(layers)\n\ndef op_list_to_string(op_list):\n    return ' '.join(f'CNOT:{i},{j}' for (i,j) in op_list)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 20,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 20,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved CNOT circuit synthesis using beam search with enhanced heuristics.\n\"\"\"\n\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U using beam search.\n    \"\"\"\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'beam_width': 5,\n        'max_depth': 50,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 15\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = [([], A.copy(), 0)]\n    best_h = float('inf')\n    best_state = None\n    \n    for _ in range(params['max_depth']):\n        new_beam = []\n        for ops, U, wait in beam:\n            if wait > params['wMax']:\n                continue\n                \n            h_val = enhanced_heuristic(U)\n            if h_val < 1e-5:\n                return ops, U\n                \n            if h_val < best_h:\n                best_h = h_val\n                best_state = (ops.copy(), U.copy(), wait)\n                \n            for op in extended_gl_options(U):\n                new_U = apply_op(U, op)\n                new_ops = ops + [op]\n                new_h = enhanced_heuristic(new_U)\n                new_beam.append((new_ops, new_U, wait + 1 if new_h >= h_val else 0))\n        \n        if not new_beam:\n            break\n            \n        new_beam.sort(key=lambda x: enhanced_heuristic(x[1]))\n        beam = new_beam[:params['beam_width']]\n    \n    return best_state[0], best_state[1] if best_state else ([], A)\n\ndef enhanced_heuristic(U):\n    n = U.shape[1] // 2\n    # Consider both original and transposed matrix\n    U1 = U[:n, :n]\n    U2 = U[n:, n:]\n    \n    # Column and row sums\n    col_sums1 = U1.sum(axis=0)\n    row_sums1 = U1.sum(axis=1)\n    col_sums2 = U2.sum(axis=0)\n    row_sums2 = U2.sum(axis=1)\n    \n    # Logarithmic component\n    log_comp = np.log(np.maximum(col_sums1, 1)).sum() + np.log(np.maximum(row_sums1, 1)).sum()\n    \n    # Weight component\n    weight_comp = (col_sums1.sum() + row_sums1.sum() + col_sums2.sum() + row_sums2.sum()) / (4 * n)\n    \n    # Combination\n    return 0.7 * log_comp + 0.3 * weight_comp\n\ndef extended_gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    \n    # Add CNOT options\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    \n    # Add permutation options for columns that might help\n    for i in range(n):\n        for j in range(i+1, n):\n            opts.append(('QPerm', (i, j)))\n    \n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        i, j = q\n        perm = list(range(n))\n        perm[i], perm[j] = perm[j], perm[i]\n        perm = perm + [p + n for p in perm]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: too many values to unpack (expected 2)",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 18,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 18
    }
  },
  {
    "id": 21,
    "parent_id": 10,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 20\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params, n)\n        if h_val <= 1e-5:\n            break\n            \n        best = None\n        best_dh = None\n        best_B = None\n        \n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params, n)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n                \n        if best is None:\n            break\n            \n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        \n        if h_min is None or hB_val < h_min[1]:\n            curr_wait = 0\n            h_min = (h_tuple, hB_val)\n        else:\n            curr_wait += 1\n            \n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            return [], A\n            \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params, n):\n    if params['ht']:\n        sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    else:\n        sA = U.sum(axis=0)\n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    \n    if params['hl']:\n        h0 = np.log(sA + 1e-10).sum() / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n        \n    if params['hi']:\n        inv_U = bin_mat_inv(U[:n, :n].T)\n        h_inv = np.log(inv_U.sum(axis=0) + 1e-10).sum() / n\n        h0 = min(h0, h_inv)\n        \n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    \n    inv_top = bin_mat_inv(top.T)\n    prod_inv = inv_top.T @ inv_top\n    rows, cols = np.nonzero(prod_inv)\n    for i, j in zip(rows, cols):\n        if i != j and ('CX', (i, j)) not in opts:\n            opts.append(('CX', (i, j)))\n    \n    # Add SWAP options\n    for i in range(n):\n        for j in range(i+1, n):\n            opts.append(('SWAP', (i, j)))\n            \n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'SWAP':\n        i, j = q\n        U_new[:, [i, j]] = U_new[:, [j, i]]\n        U_new[:, [n+i, n+j]] = U_new[:, [n+j, n+i]]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ in ['CX', 'SWAP'])\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation timed out after 60 seconds",
        "execution_method": "single_subprocess"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 21,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 22,
    "parent_id": 7,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    if U is None or not isinstance(U, np.ndarray):\n        U = np.eye(2)\n    n = U.shape[0] // 2\n    if n == 0:\n        n = 1\n        U = np.eye(2)\n    \n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'beam_width': 3,\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,\n        'wMax': 12,\n        'timeout': 15\n    }\n    \n    start = time.time()\n    try:\n        sym = prepare_matrix(U)\n        op_list, UC = csynth_beam(sym, params, start)\n        sqc_ops = mat2SQC(UC)\n        full_ops = sqc_ops + op_list\n        depth = len(op_list_layers(full_ops))\n        gate_count = count_entangling(full_ops)\n        proc_time = time.time() - start\n        circ = op_list_to_string(full_ops)\n        check = sym_test(U, full_ops)\n        return n, gate_count, depth, proc_time, check, circ\n    except:\n        return n, 0, 0, 0, False, \"\"\n\ndef prepare_matrix(U):\n    n = U.shape[0] // 2\n    if n == 0:\n        n = 1\n    sym = np.zeros((2*n, 2*n), dtype=int)\n    sym[:n,:n] = U[:n,:n] % 2\n    sym[n:,n:] = U[n:,n:] % 2\n    sym[n:,:n] = U[n:,:n] % 2\n    sym[:n,n:] = U[:n,n:] % 2\n    return sym\n\ndef csynth_beam(A, params, start_time):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], float('inf'))])\n    best_h = float('inf')\n    best_state = (A.copy(), [])\n    \n    while beam and time.time() - start_time < params['timeout']:\n        current_U, current_ops, current_h = beam.popleft()\n        \n        h_val, _ = gl_heuristic(current_U, params)\n        if h_val < best_h:\n            best_h = h_val\n            best_state = (current_U.copy(), current_ops.copy())\n        \n        if h_val <= 1e-5:\n            break\n            \n        candidates = []\n        for op in gl_options(current_U):\n            new_U = apply_op(current_U, op)\n            new_ops = current_ops + [op]\n            h_new, _ = gl_heuristic(new_U, params)\n            candidates.append((new_U, new_ops, h_new))\n        \n        candidates.sort(key=lambda x: x[2])\n        beam.extend(candidates[:params['beam_width']])\n    \n    return best_state[1], best_state[0]\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n,:n]\n    bottom = U[n:,n:]\n    \n    # Column sums\n    col_sums = top.sum(axis=0) + bottom.sum(axis=0)\n    row_sums = top.sum(axis=1) + bottom.sum(axis=1)\n    \n    # Combined weights\n    w = tuple(sorted(int(x) for x in col_sums + row_sums))\n    \n    # Multiple heuristic components\n    h_components = []\n    \n    if params['hl']:\n        log_sum = np.log(col_sums + 1e-10).sum() / n\n        h_components.append(log_sum)\n    \n    if params['hi']:\n        try:\n            inv_top = bin_mat_inv(top.T % 2)\n            h_components.append(inv_top.sum() / n**2)\n        except:\n            h_components.append(1.0)\n    \n    if params['ht']:\n        trans_sum = (top.T + bottom.T).sum() / (2*n**2)\n        h_components.append(trans_sum)\n    \n    h0 = sum(h_components) / len(h_components) if h_components else 0\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    opts = []\n    \n    # Column-based options\n    col_sums = top.sum(axis=0)\n    for j in np.where(col_sums > 1)[0]:\n        for i in np.where(top[:,j] == 1)[0]:\n            if i != j:\n                opts.append(('CX', (i, j)))\n    \n    # Row-based options\n    row_sums = top.sum(axis=1)\n    for i in np.where(row_sums > 1)[0]:\n        for j in np.where(top[i,:] == 1)[0]:\n            if i != j:\n                opts.append(('CX', (i, j)))\n    \n    return list(set(opts))\n\ndef apply_op(U, op):\n    n = U.shape[0] // 2\n    V = U.copy()\n    if op[0] == 'CX':\n        c, t = op[1]\n        if c < n and t < n:\n            V[:n,t] ^= V[:n,c]\n            V[n:,t] ^= V[n:,c]\n    return V\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            can_add = True\n            for prev_op in current_layer:\n                if op[1][0] == prev_op[1][1] or op[1][1] == prev_op[1][0]:\n                    can_add = False\n                    break\n            if can_add:\n                current_layer.append(op)\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'CX'])\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f\"{op[0]}{op[1]}\" for op in op_list)\n\ndef bin_mat_inv(A):\n    n = A.shape[0]\n    inv = np.eye(n, dtype=int)\n    for j in range(n):\n        pivot = A[j,j]\n        if pivot == 0:\n            for i in range(j+1, n):\n                if A[i,j] == 1:\n                    A[[j,i]] = A[[i,j]]\n                    inv[[j,i]] = inv[[i,j]]\n                    break\n        for i in range(n):\n            if i != j and A[i,j] == 1:\n                A[i] ^= A[j]\n                inv[i] ^= inv[j]\n    return inv\n\ndef sym_test(U, ops):\n    try:\n        n = U.shape[0] // 2\n        reconstructed = op_list2sym(ops, n)\n        return np.array_equal(U % 2, reconstructed % 2)\n    except:\n        return False\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        if op[0] == 'CX':\n            c, t = op[1]\n            U[t] ^= U[c]\n    return U\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    ops = []\n    for j in range(n):\n        for i in range(j+1, n):\n            if UC[i,j]:\n                ops.append(('CX', (i, j)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 4,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 22,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 23,
    "parent_id": 16,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 5\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        candidates = []\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            candidates.append((key, hB_val, op, B))\n        \n        candidates.sort()\n        if not candidates:\n            break\n            \n        best_key, best_h_val, best_op, best_B = candidates[0]\n        \n        if best_h_val >= h_val:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n        else:\n            curr_wait = 0\n            \n        U = best_B\n        op_list.append(best_op)\n        best_h = min(best_h, best_h_val)\n\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    \n    matrices = [top]\n    if params['ht']:\n        matrices.append(top.T)\n    if params['hi']:\n        matrices.append(bin_mat_inv(top))\n    \n    col_heuristics = []\n    for M in matrices:\n        col_sums = M.sum(axis=0)\n        col_nonzero = (M != 0).sum(axis=0)\n        col_heuristic = np.sum(np.log(col_sums + 1e-6) - 0.5 * np.sum(np.log(col_nonzero + 1e-6))\n        col_heuristics.append(col_heuristic)\n    \n    h_col = np.mean(col_heuristics)\n    h_sum = U.sum() / (2 * n * n) - 1\n    h_total = params['hr'] * (0.7 * h_col + 0.3 * h_sum)\n    \n    sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    return h_total, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    options = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                options.append(('cnot', i, j))\n    return options\n\ndef apply_op(U, op):\n    op_type, i, j = op\n    n = U.shape[1] // 2\n    if op_type == 'cnot':\n        F = np.eye(2*n)\n        F[i, j] = 1\n        return F @ U\n    return U\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            can_add = True\n            for existing_op in current_layer:\n                if op[1] == existing_op[1] or op[1] == existing_op[2] or op[2] == existing_op[1] or op[2] == existing_op[2]:\n                    can_add = False\n                    break\n            if can_add:\n                current_layer.append(op)\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'cnot'])\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join([f'{op[0]}_{op[1]}_{op[2]}' for op in op_list])\n\ndef sym_cnot(U):\n    n = U.shape[1] // 2\n    I = np.eye(n)\n    Z = np.zeros((n,n))\n    return np.block([[I, Z], [Z, I]]) @ U\n\ndef bin_mat_inv(A):\n    return np.linalg.inv(A).astype(int) % 2\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    reconstructed = op_list2sym(ops, n)\n    return np.array_equal(U, reconstructed)\n\ndef op_list2sym(op_list, n):\n    mat = np.eye(2*n)\n    for op in op_list:\n        if op[0] == 'cnot':\n            i, j = op[1], op[2]\n            F = np.eye(2*n)\n            F[i,j] = 1\n            mat = F @ mat\n    return mat\n\ndef mat2SQC(UC):\n    n = UC.shape[1] // 2\n    I = np.eye(n)\n    Z = np.zeros((n,n))\n    S = np.block([[Z, I], [I, Z]])\n    return [('SQC', 0, 0)] if np.array_equal(UC, S) else []\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Result file not found. Return code: 1, stderr:   File \"/var/folders/28/81_7stz56pj25dz5bc6t2lh40000gn/T/tmpxujrvi17.py\", line 114\n    col_heuristic = np.sum(np.log(col_sums + 1e-6) - 0.5 * np.sum(np.log(col_nonzero + 1e-6))\n                          ^\nSyntaxError: '(' was never closed\n",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 23,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 24,
    "parent_id": 9,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2.0,  # Adjusted heuristic weight\n        'wMax': 6    # Reduced patience\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    \n    if np.array_equal(U, np.eye(2*n, dtype=int)):\n        return op_list, U\n        \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        options = gl_options(U)\n        options.sort(key=lambda op: gl_heuristic(apply_op(U, op), params)[0])\n        for op in options[:min(8, len(options))]:\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or hB_val < h_min[1]:\n            curr_wait = 0\n            h_min = (h_tuple, hB_val)\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    sA = U.sum(axis=0)\n    if params['ht']:\n        sA = np.concatenate([sA, U.sum(axis=1)])\n    if params['hi']:\n        inv_U = bin_mat_inv(U[:n,:n].T % 2)\n        sA_inv = inv_U.sum(axis=0)\n        if params['ht']:\n            sA_inv = np.concatenate([sA_inv, inv_U.sum(axis=1)])\n        sA = np.minimum(sA, sA_inv)\n    \n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    if params['hl']:\n        h0 = np.log(np.maximum(sA, 1)).sum() / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: operands could not be broadcast together with shapes (64,) (32,) ",
        "execution_method": "single_subprocess"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 24,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 25,
    "parent_id": 7,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\n\ndef search(U):\n    if U is None or not isinstance(U, np.ndarray):\n        return (0, 0, 0, 0, False, \"\")\n    \n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 6\n    }\n    try:\n        sym = sym_cnot(U)\n        return synth_main(sym, params)\n    except:\n        return (U.shape[1]//2 if U is not None else 0, 0, 0, 0, False, \"\")\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    if not op_list:\n        return (n, 0, 0, time.time()-start, False, \"\")\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    if A is None:\n        return [], None\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    curr_wait = 0\n    best_h = float('inf')\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        if h_val < best_h:\n            best_h = h_val\n            curr_wait = 0\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    sA = U.sum(axis=0)\n    if params['ht']:\n        sA = np.concatenate([sA, U.sum(axis=1)])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    h_components = []\n    if params['hl']:\n        h_components.append(np.log(sA + 1e-10).sum() / len(sA))\n    if params['hi']:\n        try:\n            inv_U = bin_mat_inv(U[:n,:n].T % 2)\n            h_components.append((inv_U.sum() / n**2))\n        except:\n            h_components.append(1.0)\n    \n    h0 = sum(h_components) / len(h_components) if h_components else 0\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    col_sums = top.sum(axis=0)\n    for j in np.where(col_sums > 1)[0]:\n        for i in np.where(top[:,j] == 1)[0]:\n            if i != j:\n                opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op):\n    if U is None or op is None:\n        return None\n    n = U.shape[1] // 2\n    V = U.copy()\n    if op[0] == 'CX':\n        i, j = op[1]\n        V[:n,j] = (V[:n,j] + V[:n,i]) % 2\n        V[n:,i] = (V[n:,i] + V[n:,j]) % 2\n    return V\n\ndef op_list_layers(op_list):\n    if not op_list:\n        return []\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            can_add = True\n            for existing_op in current_layer:\n                if op[1][0] == existing_op[1][0] or op[1][1] == existing_op[1][1] or op[1][0] == existing_op[1][1] or op[1][1] == existing_op[1][0]:\n                    can_add = False\n                    break\n            if can_add:\n                current_layer.append(op)\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    if not op_list:\n        return 0\n    return sum(1 for op in op_list if op[0] == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    if not op_list:\n        return \"\"\n    return sep.join(f\"{op[0]}{op[1][0]}{op[1][1]}\" for op in op_list)\n\ndef sym_cnot(U):\n    if U is None:\n        return None\n    n = U.shape[1] // 2\n    return np.vstack([np.hstack([U[:n,:n], np.zeros((n,n))]), np.hstack([U[n:,:n], U[:n,:n].T % 2])])\n\ndef bin_mat_inv(A):\n    if A is None:\n        return None\n    n = A.shape[0]\n    identity = np.eye(n, dtype=int)\n    inv = np.eye(n, dtype=int)\n    for j in range(n):\n        pivot = A[j,j]\n        if pivot == 0:\n            for i in range(j+1, n):\n                if A[i,j] == 1:\n                    A[[j,i]] = A[[i,j]]\n                    inv[[j,i]] = inv[[i,j]]\n                    break\n        for i in range(n):\n            if i != j and A[i,j] == 1:\n                A[i] = (A[i] + A[j]) % 2\n                inv[i] = (inv[i] + inv[j]) % 2\n    return inv\n\ndef sym_test(U, ops):\n    if U is None or not ops:\n        return False\n    n = U.shape[1] // 2\n    reconstructed = op_list2sym(ops, n)\n    return np.array_equal(U, reconstructed)\n\ndef op_list2sym(op_list, n):\n    if not op_list:\n        return None\n    U = np.eye(2*n, dtype=int)\n    for op in reversed(op_list):\n        U = apply_op(U, op)\n    return U\n\ndef mat2SQC(UC):\n    if UC is None:\n        return []\n    n = UC.shape[1] // 2\n    A = UC[:n,:n]\n    ops = []\n    for j in range(n):\n        for i in range(j+1, n):\n            if A[i,j] == 1:\n                ops.append(('CX', (i, j)))\n                A[i] = (A[i] + A[j]) % 2\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 2,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 25,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 26,
    "parent_id": 5,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,\n        'wMax': 10,\n        'beam_width': 3,\n        'lookahead': 1\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = [(A.copy(), [], 0)]\n    best_h = float('inf')\n    best_state = None\n    unchanged_count = 0\n    \n    for _ in range(params['wMax']):\n        new_beam = []\n        for state in beam:\n            U, ops, wait = state\n            h_val = fast_heuristic(U)\n            \n            if h_val <= 1e-5:\n                return ops, U\n            \n            if h_val < best_h:\n                best_h = h_val\n                best_state = (U.copy(), ops.copy(), wait)\n                unchanged_count = 0\n            else:\n                unchanged_count += 1\n            \n            if unchanged_count > 3:\n                break\n                \n            candidates = []\n            for op in gl_options(U):\n                B = apply_op(U, op)\n                new_ops = ops + [op]\n                new_h = fast_heuristic(B)\n                candidates.append((B, new_ops, wait + 1, new_h))\n            \n            candidates.sort(key=lambda x: x[3])\n            new_beam.extend(candidates[:params['beam_width']])\n        \n        beam = []\n        for state in new_beam:\n            U, ops, wait, h_val = state\n            if h_val < best_h * 1.5:\n                beam.append((U, ops, wait))\n        \n        if len(beam) == 0:\n            break\n    \n    if best_state:\n        return best_state[1], best_state[0]\n    return [], A\n\ndef fast_heuristic(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    return np.sum(top) + np.sum(bot) - 2*n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    opts = []\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j and top[i,j] == 1:\n                opts.append(('CX', (i,j)))\n            if i != j and bot[i,j] == 1:\n                opts.append(('CX', (j,i)))\n    \n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 28,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 27,
    "parent_id": 2,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': False,\n        'ht': False,\n        'hl': False,\n        'hr': 2,\n        'wMax': 10\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = float('inf')\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U, params):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if hB_val < h_min:\n            curr_wait = 0\n            h_min = hB_val\n        else:\n            curr_wait += 1\n            if params['wMax'] > 0 and curr_wait > params['wMax']:\n                break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    col_sums = U.sum(axis=0)\n    w = tuple(sorted(int(x) for x in col_sums))\n    h0 = (col_sums.sum() - len(col_sums)) / len(col_sums)\n    return params['hr'] * h0, w\n\ndef gl_options(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    max_col = np.argmax(col_sums)\n    opts = []\n    for j in range(n):\n        if j != max_col and top[max_col, j]:\n            opts.append(('CX', (max_col, j)))\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 2,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 27,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 28,
    "parent_id": 12,
    "solution": "\nimport numpy as np\nimport time\nimport math\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',  # Now supports 'greedy', 'beam', or 'hybrid'\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,  # More aggressive heuristic weighting\n        'wMax': 12,\n        'beam_width': 3,  # For beam search\n        'restart_threshold': 5,  # Local minima detection\n        'max_restarts': 2\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    \n    # Try multiple methods with fallback\n    methods = [params['method']]\n    if params['method'] != 'greedy':\n        methods.append('greedy')\n        \n    best_result = None\n    for method in methods:\n        current_params = params.copy()\n        current_params['method'] = method\n        op_list, UC = csynth_optimized(U, current_params)\n        if op_list:\n            if best_result is None or len(op_list) < len(best_result[0]):\n                best_result = (op_list, UC)\n    \n    if best_result is None:\n        return n, 0, 0, time.time()-start, False, \"\"\n    \n    op_list, UC = best_result\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_optimized(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    restarts = 0\n    stagnation = 0\n    \n    while True:\n        h_val, h_tuple = enhanced_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        if h_val < best_h - 1e-5:\n            best_h = h_val\n            stagnation = 0\n        else:\n            stagnation += 1\n            \n        if stagnation > params['wMax']:\n            if restarts < params['max_restarts']:\n                U = A.copy()\n                op_list = []\n                best_h = float('inf')\n                stagnation = 0\n                restarts += 1\n                continue\n            return [], A\n            \n        if params['method'] == 'greedy':\n            best_op, best_U = greedy_step(U, params)\n        elif params['method'] == 'beam':\n            best_op, best_U = beam_step(U, params)\n        else:  # hybrid\n            if len(op_list) < n*2:\n                best_op, best_U = greedy_step(U, params)\n            else:\n                best_op, best_U = beam_step(U, params)\n                \n        if best_op is None:\n            return [], A\n            \n        U = best_U\n        op_list.append(best_op)\n        \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef enhanced_heuristic(U, params):\n    n = U.shape[1] // 2\n    GL = U[:n, :n]\n    GR = U[:n, n:]\n    \n    # Column/row sums\n    col_sums = U.sum(axis=0)\n    row_sums = U.sum(axis=1)\n    sA = np.concatenate([col_sums, row_sums])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    # Log sum heuristic\n    log_sum = sum(math.log(x) if x > 0 else 0 for x in sA)\n    h0 = log_sum / len(sA)\n    \n    # Matrix norm heuristic\n    h1 = np.linalg.norm(GL, 'fro') + np.linalg.norm(GR, 'fro')\n    \n    # Column completion heuristic\n    complete_cols = sum(1 for x in col_sums[:n] if x == 1)\n    h2 = (n - complete_cols) / n\n    \n    # Combined heuristic\n    combined = params['hr'] * (0.5*h0 + 0.3*h1 + 0.2*h2)\n    \n    # Consider inverse/transpose if enabled\n    if params['hi'] or params['ht']:\n        min_h = combined\n        if params['hi']:\n            inv_h, _ = enhanced_heuristic(bin_mat_inv(U.T), params)\n            min_h = min(min_h, inv_h)\n        if params['ht']:\n            trans_h, _ = enhanced_heuristic(U.T), params)\n            min_h = min(min_h, trans_h)\n        combined = min_h\n    \n    return combined, w\n\ndef greedy_step(U, params):\n    best_op = None\n    best_U = None\n    best_h = float('inf')\n    \n    for op in extended_gl_options(U):\n        B = apply_op(U, op)\n        hB_val, _ = enhanced_heuristic(B, params)\n        if hB_val < best_h:\n            best_h = hB_val\n            best_op = op\n            best_U = B\n    \n    return best_op, best_U\n\ndef beam_step(U, params):\n    beam = deque()\n    beam.append((U, [], 0))\n    \n    for _ in range(params['beam_width']):\n        if not beam:\n            break\n            \n        current_U, current_ops, current_h = beam.popleft()\n        \n        for op in extended_gl_options(current_U):\n            B = apply_op(current_U, op)\n            hB_val, _ = enhanced_heuristic(B, params)\n            new_ops = current_ops + [op]\n            beam.append((B, new_ops, hB_val))\n        \n        beam = deque(sorted(beam, key=lambda x: x[2])[:params['beam_width']])\n    \n    if beam:\n        best_U, best_ops, _ = beam[0]\n        return best_ops[0], best_U\n    return None, None\n\ndef extended_gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n            opts.append(('CX', (j, i)))  # Also consider reverse CNOT\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Result file not found. Return code: 1, stderr:   File \"/var/folders/28/81_7stz56pj25dz5bc6t2lh40000gn/T/tmpgt7gz273.py\", line 163\n    trans_h, _ = enhanced_heuristic(U.T), params)\n                                                ^\nSyntaxError: unmatched ')'\n",
        "execution_method": "single_subprocess"
      }
    },
    "children": 3,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 26,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 29,
    "parent_id": 19,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappush, heappop\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    try:\n        if not isinstance(U, np.ndarray) or U.shape[0] != U.shape[1]:\n            return (n, 0, 0, time.time()-start, False, \"\")\n        \n        matrices = [U, U.T, np.linalg.inv(U).astype(int) % 2]\n        best_result = None\n        best_gates = float('inf')\n        \n        for mat in matrices:\n            try:\n                op_list, _ = beam_search(mat, beam_width=7, max_depth=30)\n                gate_count = len(op_list)\n                \n                if gate_count < best_gates:\n                    best_gates = gate_count\n                    depth = len(op_list_layers(op_list))\n                    best_result = (n, gate_count, depth, \n                                  time.time() - start, True, \n                                  op_list_to_string(op_list))\n            except:\n                continue\n        \n        if best_result is None:\n            return (n, 0, 0, time.time()-start, False, \"\")\n        return best_result\n    except:\n        return (n, 0, 0, time.time()-start, False, \"\")\n\ndef beam_search(U, beam_width=7, max_depth=30):\n    beam = [(0, [], U.copy())]\n    \n    for _ in range(max_depth):\n        new_beam = []\n        \n        for _, ops, current in beam:\n            if np.array_equal(current, np.eye(current.shape[0])):\n                return ops, current\n                \n            for op in generate_cnots(current.shape[0]):\n                new_U = apply_cnot(current, op)\n                new_ops = ops + [op]\n                h = heuristic(new_U)\n                heappush(new_beam, (h, new_ops, new_U))\n                if len(new_beam) > 2*beam_width:\n                    new_beam = sorted(new_beam, key=lambda x: x[0])[:beam_width]\n        \n        if not new_beam:\n            break\n            \n        beam = sorted(new_beam, key=lambda x: x[0])[:beam_width]\n    \n    if beam:\n        return beam[0][1], beam[0][2]\n    return [], U\n\ndef heuristic(U):\n    col_weights = U.sum(axis=0)\n    row_weights = U.sum(axis=1)\n    col_priority = sum(np.log2(w + 1) if w > 0 else 0 for w in col_weights)\n    return col_priority + (col_weights.max() - col_weights.min())\n\ndef generate_cnots(n):\n    return [(i, j) for i in range(n) for j in range(n) if i != j]\n\ndef apply_cnot(U, op):\n    i, j = op\n    U_new = U.copy()\n    U_new[:, j] ^= U_new[:, i]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for (i, j) in op_list:\n        qubits = {i, j}\n        placed = False\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                placed = True\n                break\n        if not placed:\n            layers.append(qubits)\n    return len(layers)\n\ndef op_list_to_string(op_list):\n    return ' '.join(f'CNOT:{i},{j}' for (i,j) in op_list)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 30,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 30,
    "parent_id": 8,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappush, heappop\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    # Only consider original and transpose to save time\n    matrices = [(U, 'original'), (U.T, 'transpose')]\n    \n    best_result = None\n    best_gates = float('inf')\n    \n    for mat, desc in matrices:\n        try:\n            sym = np.zeros((2*n, 2*n), dtype=int)\n            sym[:n, :n] = mat % 2\n            sym[n:, n:] = bin_mat_inv(mat.T) % 2\n            \n            op_list, UC = beam_search(sym, beam_width=5, max_depth=30)\n            if not is_identity(UC):\n                continue\n                \n            gate_count = count_entangling(op_list)\n            if gate_count < best_gates:\n                best_gates = gate_count\n                best_result = (n, gate_count, len(op_list_layers(op_list)), \n                              time.time() - start, True, op_list_to_string(op_list))\n        except:\n            continue\n    \n    if best_result is None:\n        return (n, 0, 0, time.time()-start, False, \"\")\n    return best_result\n\ndef beam_search(U, beam_width=5, max_depth=30):\n    n = U.shape[0] // 2\n    beam = [(heuristic(U), [], U.copy())]\n    \n    for _ in range(max_depth):\n        new_beam = []\n        \n        for _, ops, current in beam:\n            if is_identity(current):\n                return ops, current\n                \n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        # Try CNOT in both directions\n                        for ctrl, targ in [(i,j), (j,i)]:\n                            new_U = apply_cnot(current, ctrl, targ)\n                            new_ops = ops + [('CX', (ctrl, targ))]\n                            h = heuristic(new_U)\n                            heappush(new_beam, (h, new_ops, new_U))\n                            \n                            if len(new_beam) > beam_width * 10:\n                                new_beam = new_beam[:beam_width]\n        \n        if not new_beam:\n            break\n            \n        beam = new_beam[:beam_width]\n    \n    if beam:\n        return beam[0][1], beam[0][2]\n    return [], U\n\ndef heuristic(U):\n    n = U.shape[0] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    return (col_sums.sum() + row_sums.sum()) / (2*n) + (col_sums.max() + row_sums.max())\n\ndef is_identity(U):\n    n = U.shape[0] // 2\n    return np.array_equal(U[:n, :n], np.eye(n)) and np.array_equal(U[n:, n:], np.eye(n))\n\ndef apply_cnot(U, ctrl, targ):\n    n = U.shape[0] // 2\n    U_new = U.copy()\n    U_new[:, targ] ^= U_new[:, ctrl]\n    U_new[:, n + ctrl] ^= U_new[:, n + targ]\n    return U_new\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q)\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f'{typ}:{q[0]},{q[1]}' for typ, q in op_list)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 4,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 29,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 31,
    "parent_id": 22,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    if U is None or not isinstance(U, np.ndarray):\n        U = np.eye(2)\n    n = U.shape[0] // 2\n    if n == 0:\n        n = 1\n        U = np.eye(2)\n    \n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'beam_width': 2,\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 1,\n        'wMax': 8,\n        'timeout': 8\n    }\n    \n    start = time.time()\n    try:\n        sym = prepare_matrix(U)\n        op_list, UC = csynth_beam(sym, params, start)\n        sqc_ops = mat2SQC(UC)\n        full_ops = sqc_ops + op_list\n        depth = len(op_list_layers(full_ops))\n        gate_count = count_entangling(full_ops)\n        proc_time = time.time() - start\n        circ = op_list_to_string(full_ops)\n        check = sym_test(U, full_ops)\n        return n, gate_count, depth, proc_time, check, circ\n    except:\n        return n, 0, 0, 0, False, \"\"\n\ndef prepare_matrix(U):\n    n = U.shape[0] // 2\n    if n == 0:\n        n = 1\n    sym = np.zeros((2*n, 2*n), dtype=int)\n    sym[:n,:n] = U[:n,:n] % 2\n    sym[n:,n:] = U[n:,n:] % 2\n    sym[n:,:n] = U[n:,:n] % 2\n    sym[:n,n:] = U[:n,n:] % 2\n    return sym\n\ndef csynth_beam(A, params, start_time):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], float('inf'))])\n    best_h = float('inf')\n    best_state = (A.copy(), [])\n    \n    while beam and time.time() - start_time < params['timeout']:\n        current_U, current_ops, current_h = beam.popleft()\n        \n        if np.array_equal(current_U, np.eye(2*n)):\n            best_state = (current_U, current_ops)\n            break\n            \n        h_val, h_weights = gl_heuristic(current_U, params)\n        if h_val < best_h:\n            best_h = h_val\n            best_state = (current_U.copy(), current_ops.copy())\n        \n        if h_val <= 1e-5:\n            break\n            \n        candidates = []\n        for op in gl_options(current_U):\n            new_U = apply_op(current_U, op)\n            new_ops = current_ops + [op]\n            h_new, _ = gl_heuristic(new_U, params)\n            candidates.append((new_U, new_ops, h_new))\n        \n        candidates.sort(key=lambda x: (x[2], len(x[1])))\n        beam.extend(candidates[:params['beam_width']])\n    \n    return best_state[1], best_state[0]\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n,:n]\n    bottom = U[n:,n:]\n    \n    # Column sums\n    col_sums = top.sum(axis=0) + bottom.sum(axis=0)\n    row_sums = top.sum(axis=1) + bottom.sum(axis=1)\n    \n    # Combined weights as tuple\n    w = tuple(sorted(int(x) for x in col_sums + row_sums))\n    \n    # Multiple heuristic components\n    h_components = []\n    \n    # Basic matrix sum\n    h_components.append(U.sum() / (4*n**2))\n    \n    if params['hl']:\n        log_sum = np.log(col_sums + 1e-10).sum() / n\n        h_components.append(log_sum)\n    \n    if params['hi']:\n        try:\n            inv_top = bin_mat_inv(top.T % 2)\n            h_components.append(inv_top.sum() / n**2)\n        except:\n            pass\n    \n    if params['ht']:\n        trans_sum = (top.T + bottom.T).sum() / (2*n**2)\n        h_components.append(trans_sum)\n    \n    h0 = sum(h_components) / len(h_components) if h_components else 0\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    opts = []\n    \n    # Column-based options\n    col_sums = top.sum(axis=0)\n    for j in np.where(col_sums > 1)[0]:\n        for i in np.where(top[:,j] == 1)[0]:\n            if i != j:\n                opts.append(('CX', (i, j)))\n    \n    # Row-based options\n    row_sums = top.sum(axis=1)\n    for i in np.where(row_sums > 1)[0]:\n        for j in np.where(top[i,:] == 1)[0]:\n            if i != j:\n                opts.append(('CX', (i, j)))\n    \n    return list(set(opts))\n\ndef apply_op(U, op):\n    n = U.shape[0] // 2\n    V = U.copy()\n    if op[0] == 'CX':\n        c, t = op[1]\n        if c < n and t < n:\n            V[:n,t] ^= V[:n,c]\n            V[n:,t] ^= V[n:,c]\n    return V\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            can_add = True\n            for prev_op in current_layer:\n                if op[1][0] == prev_op[1][1] or op[1][1] == prev_op[1][0]:\n                    can_add = False\n                    break\n            if can_add:\n                current_layer.append(op)\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'CX'])\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f\"{op[0]}{op[1]}\" for op in op_list)\n\ndef bin_mat_inv(A):\n    n = A.shape[0]\n    inv = np.eye(n, dtype=int)\n    for j in range(n):\n        pivot = A[j,j]\n        if pivot == 0:\n            for i in range(j+1, n):\n                if A[i,j] == 1:\n                    A[[j,i]] = A[[i,j]]\n                    inv[[j,i]] = inv[[i,j]]\n                    break\n        for i in range(n):\n            if i != j and A[i,j] == 1:\n                A[i] ^= A[j]\n                inv[i] ^= inv[j]\n    return inv\n\ndef sym_test(U, ops):\n    try:\n        n = U.shape[0] // 2\n        reconstructed = op_list2sym(ops, n)\n        return np.array_equal(U % 2, reconstructed % 2)\n    except:\n        return False\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        if op[0] == 'CX':\n            c, t = op[1]\n            U[t] ^= U[c]\n    return U\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    ops = []\n    for j in range(n):\n        for i in range(j+1, n):\n            if UC[i,j]:\n                ops.append(('CX', (i, j)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 31,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 32,
    "parent_id": 3,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,\n        'wMax': 15,\n        'beam_width': 3,\n        'lookahead': 2\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], 0)])\n    \n    for _ in range(params['wMax'] * 2):\n        new_beam = []\n        for state in beam:\n            U, ops, wait = state\n            if np.array_equal(U[:n,:n], np.eye(n, dtype=int)):\n                return ops, U\n            \n            h_val = gl_heuristic_simple(U)\n            candidates = []\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        op = ('CX', (i, j))\n                        B = apply_op(U.copy(), op)\n                        hB = gl_heuristic_simple(B)\n                        candidates.append((hB, B, op))\n            \n            candidates.sort()\n            for hB, B, op in candidates[:params['beam_width']]:\n                new_ops = ops + [op]\n                if hB < h_val:\n                    new_beam.append((B, new_ops, 0))\n                else:\n                    new_beam.append((B, new_ops, wait + 1))\n        \n        if not new_beam:\n            break\n            \n        new_beam.sort(key=lambda x: (gl_heuristic_simple(x[0]), len(x[1])))\n        beam = deque(new_beam[:params['beam_width']])\n    \n    best_state = min(beam, key=lambda x: (gl_heuristic_simple(x[0]), len(x[1])))\n    return best_state[1], best_state[0]\n\ndef gl_heuristic_simple(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    return np.sum(top)\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    CList = [np.eye(2, dtype=int) for _ in range(n)]\n    ops = []\n    for i, M in enumerate(CList):\n        if not np.array_equal(M, np.eye(2, dtype=int)):\n            ops.append(('S', (i,)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()",
        "execution_method": "single_subprocess"
      }
    },
    "children": 3,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 32,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 33,
    "parent_id": 22,
    "solution": "\nimport numpy as np\nimport time\nimport heapq\nfrom collections import defaultdict\n\ndef search(U):\n    start_time = time.time()\n    n = U.shape[0] // 2 if U is not None and isinstance(U, np.ndarray) else 1\n    timeout = 15\n    \n    try:\n        # Validate and prepare matrix\n        if U is None or not isinstance(U, np.ndarray):\n            U = np.eye(2*n)\n        sym = prepare_matrix(U)\n        if not is_valid_gl_matrix(sym):\n            return n, 0, 0, 0, False, \"\"\n        \n        # Search parameters\n        params = {\n            'mode': 'GL',\n            'hl': True,    # Logarithmic heuristic\n            'hi': True,    # Inverse heuristic\n            'ht': True,    # Transpose heuristic\n            'hr': 3,       # Heuristic weight\n            'wMax': 15,    # Max operations to consider\n            'timeout': timeout\n        }\n        \n        # Perform A* search\n        op_list, final_matrix = a_star_search(sym, params, start_time)\n        \n        # Process results\n        if not op_list:\n            return n, 0, 0, 0, False, \"\"\n        \n        sqc_ops = mat2SQC(final_matrix)\n        full_ops = sqc_ops + op_list\n        depth = len(op_list_layers(full_ops))\n        gate_count = count_entangling(full_ops)\n        proc_time = time.time() - start_time\n        circ = op_list_to_string(full_ops)\n        check = sym_test(U, full_ops)\n        \n        return n, gate_count, depth, proc_time, check, circ\n    \n    except:\n        return n, 0, 0, 0, False, \"\"\n\ndef prepare_matrix(U):\n    n = U.shape[0] // 2 if U.shape[0] > 2 else 1\n    sym = np.zeros((2*n, 2*n), dtype=int)\n    sym[:n,:n] = U[:n,:n] % 2\n    sym[n:,n:] = U[n:,n:] % 2\n    sym[n:,:n] = U[n:,:n] % 2\n    sym[:n,n:] = U[:n,n:] % 2\n    return sym\n\ndef is_valid_gl_matrix(U):\n    n = U.shape[0] // 2\n    top = U[:n,:n]\n    bottom = U[n:,n:]\n    return (top @ bottom.T % 2 == np.eye(n, dtype=int)).all()\n\ndef a_star_search(A, params, start_time):\n    n = A.shape[0] // 2\n    open_set = []\n    heapq.heappush(open_set, (0, 0, A.copy(), []))\n    \n    visited = {}\n    counter = 1  # tie-breaker for heap\n    \n    best_state = (float('inf'), A.copy(), [])\n    \n    while open_set and time.time() - start_time < params['timeout']:\n        _, _, current_U, current_ops = heapq.heappop(open_set)\n        \n        # Check if we've reached the identity\n        if np.array_equal(current_U, np.eye(2*n, dtype=int)):\n            return current_ops, current_U\n        \n        # Generate candidate operations\n        candidates = generate_candidates(current_U, current_ops, params)\n        \n        for new_U, new_ops in candidates:\n            # Check if we've found a better path to this state\n            state_key = tuple(new_U.flatten())\n            if state_key in visited and len(new_ops) >= visited[state_key]:\n                continue\n            \n            visited[state_key] = len(new_ops)\n            \n            # Calculate heuristic and priority\n            h_val, _ = gl_heuristic(new_U, params)\n            priority = len(new_ops) + h_val\n            \n            # Update best state found so far\n            if h_val < best_state[0]:\n                best_state = (h_val, new_U.copy(), new_ops.copy())\n            \n            # Add to open set\n            heapq.heappush(open_set, (priority, counter, new_U, new_ops))\n            counter += 1\n    \n    # Return best found solution if timeout\n    return best_state[2], best_state[1]\n\ndef generate_candidates(U, current_ops, params):\n    n = U.shape[0] // 2\n    candidates = []\n    top = U[:n,:n]\n    \n    # Generate column operations\n    col_sums = top.sum(axis=0)\n    for j in np.where(col_sums > 1)[0]:\n        sources = np.where(top[:,j] == 1)[0]\n        for i in sources:\n            if i != j:\n                new_U = apply_op(U, ('CX', (i, j)))\n                new_ops = current_ops + [('CX', (i, j))]\n                candidates.append((new_U, new_ops))\n    \n    # Generate row operations\n    row_sums = top.sum(axis=1)\n    for i in np.where(row_sums > 1)[0]:\n        targets = np.where(top[i,:] == 1)[0]\n        for j in targets:\n            if i != j:\n                new_U = apply_op(U, ('CX', (i, j)))\n                new_ops = current_ops + [('CX', (i, j))]\n                candidates.append((new_U, new_ops))\n    \n    return candidates[:params['wMax']]\n\ndef gl_heuristic(U, params):\n    n = U.shape[0] // 2\n    top = U[:n,:n]\n    bottom = U[n:,n:]\n    \n    # Multiple heuristic components\n    h_components = []\n    \n    # Column sums heuristic\n    if True:  # Always enabled\n        col_sums = top.sum(axis=0) + bottom.sum(axis=0)\n        h_col = np.sum(np.log(col_sums + 1e-10)) / n\n        h_components.append(h_col)\n    \n    # Inverse heuristic\n    if params['hi']:\n        try:\n            inv_top = bin_mat_inv(top.T % 2)\n            h_inv = inv_top.sum() / n**2\n            h_components.append(h_inv)\n        except:\n            pass\n    \n    # Transpose heuristic\n    if params['ht']:\n        h_trans = (top.T + bottom.T).sum() / (2*n**2)\n        h_components.append(h_trans)\n    \n    # Weight combination\n    h0 = sum(h_components) / len(h_components) if h_components else 0\n    return params['hr'] * h0, tuple(sorted(top.sum(axis=0) + bottom.sum(axis=0)))\n\ndef apply_op(U, op):\n    n = U.shape[0] // 2\n    V = U.copy()\n    if op[0] == 'CX':\n        c, t = op[1]\n        V[t] ^= V[c]\n    return V\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            can_add = True\n            for prev_op in current_layer:\n                if op[1][0] == prev_op[1][1] or op[1][1] == prev_op[1][0]:\n                    can_add = False\n                    break\n            if can_add:\n                current_layer.append(op)\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'CX'])\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f\"{op[0]}{op[1]}\" for op in op_list)\n\ndef bin_mat_inv(A):\n    n = A.shape[0]\n    inv = np.eye(n, dtype=int)\n    for j in range(n):\n        pivot = A[j,j]\n        if pivot == 0:\n            for i in range(j+1, n):\n                if A[i,j] == 1:\n                    A[[j,i]] = A[[i,j]]\n                    inv[[j,i]] = inv[[i,j]]\n                    break\n        for i in range(n):\n            if i != j and A[i,j] == 1:\n                A[i] ^= A[j]\n                inv[i] ^= inv[j]\n    return inv\n\ndef sym_test(U, ops):\n    try:\n        n = U.shape[0] // 2\n        reconstructed = op_list2sym(ops, n)\n        return np.array_equal(U % 2, reconstructed % 2)\n    except:\n        return False\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        if op[0] == 'CX':\n            c, t = op[1]\n            U[t] ^= U[c]\n    return U\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    ops = []\n    for j in range(n):\n        for i in range(j+1, n):\n            if UC[i,j]:\n                ops.append(('CX', (i, j)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 34,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 34,
    "parent_id": 30,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappush, heappop\nimport math\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    matrices = [(U, 'original'), (U.T, 'transpose'), (bin_mat_inv(U), 'inverse')]\n    \n    best_result = None\n    best_gates = float('inf')\n    \n    for mat, desc in matrices:\n        try:\n            sym = np.zeros((2*n, 2*n), dtype=int)\n            sym[:n, :n] = mat % 2\n            sym[n:, n:] = bin_mat_inv(mat.T) % 2\n            \n            op_list, UC = beam_search(sym, beam_width=20, max_depth=50)\n            if not is_identity(UC):\n                continue\n                \n            gate_count = count_entangling(op_list)\n            if gate_count < best_gates:\n                best_gates = gate_count\n                best_result = (n, gate_count, len(op_list_layers(op_list)), \n                              time.time() - start, True, op_list_to_string(op_list))\n                if time.time() - start > 10:  # Early termination\n                    return best_result\n        except:\n            continue\n    \n    if best_result is None:\n        return (n, 0, 0, time.time()-start, False, \"\")\n    return best_result\n\ndef beam_search(U, beam_width=20, max_depth=50):\n    n = U.shape[0] // 2\n    beam = [(heuristic(U), [], U.copy())]\n    \n    for _ in range(max_depth):\n        new_beam = []\n        \n        for _, ops, current in beam:\n            if is_identity(current):\n                return ops, current\n                \n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        for ctrl, targ in [(i,j), (j,i)]:\n                            new_U = apply_cnot(current, ctrl, targ)\n                            new_ops = ops + [('CX', (ctrl, targ))]\n                            h = heuristic(new_U)\n                            heappush(new_beam, (h, new_ops, new_U))\n                            \n                            if len(new_beam) > beam_width * 100:\n                                new_beam = sorted(new_beam, key=lambda x: x[0])[:beam_width]\n        \n        if not new_beam:\n            break\n            \n        beam = sorted(new_beam, key=lambda x: x[0])[:beam_width]\n    \n    if beam:\n        return beam[0][1], beam[0][2]\n    return [], U\n\ndef heuristic(U):\n    n = U.shape[0] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    log_col = sum(math.log2(x + 1) for x in col_sums)\n    log_row = sum(math.log2(x + 1) for x in row_sums)\n    return log_col + log_row + (col_sums.max() + row_sums.max())\n\ndef is_identity(U):\n    n = U.shape[0] // 2\n    return np.array_equal(U[:n, :n], np.eye(n)) and np.array_equal(U[n:, n:], np.eye(n))\n\ndef apply_cnot(U, ctrl, targ):\n    n = U.shape[0] // 2\n    U_new = U.copy()\n    U_new[:, targ] ^= U_new[:, ctrl]\n    U_new[:, n + ctrl] ^= U_new[:, n + targ]\n    return U_new\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q)\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f'{typ}:{q[0]},{q[1]}' for typ, q in op_list)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 36,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 35,
    "parent_id": 16,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 5\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    if U is None:\n        n = 0\n        return n, 0, 0, 0.0, False, \"\"\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        candidates = []\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            candidates.append((key, hB_val, op, B))\n        \n        if not candidates:\n            break\n            \n        candidates.sort()\n        best_key, best_h_val, best_op, best_B = candidates[0]\n        \n        if best_h_val >= h_val:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n        else:\n            curr_wait = 0\n            \n        U = best_B\n        op_list.append(best_op)\n        best_h = min(best_h, best_h_val)\n\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    \n    matrices = [top]\n    if params['ht']:\n        matrices.append(top.T)\n    if params['hi']:\n        matrices.append(bin_mat_inv(top))\n    \n    col_metrics = []\n    for M in matrices:\n        col_sums = M.sum(axis=0)\n        col_nonzero = (M != 0).sum(axis=0)\n        col_priority = np.where(col_sums == 1, 0, 1)\n        col_metric = (np.log(col_sums + 1e-6) * col_priority) - 0.3 * np.log(col_nonzero + 1e-6)\n        col_metrics.append(col_metric)\n    \n    h_col = np.mean(col_metrics)\n    h_sum = U.sum() / (2 * n * n) - 1\n    h_total = params['hr'] * (0.7 * h_col + 0.3 * h_sum)\n    \n    sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    return h_total, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    ops = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                ops.append(('cnot', i, j))\n                ops.append(('cnot', j, i))\n    return ops\n\ndef apply_op(U, op):\n    n = U.shape[1] // 2\n    V = U.copy()\n    if op[0] == 'cnot':\n        c, t = op[1], op[2]\n        V[:n,:] ^= np.outer(V[:n,t], V[:n,c])\n        V[n:,:] ^= np.outer(V[n:,t], V[n:,c])\n    return V\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            last_op = current_layer[-1]\n            if op[0] == 'cnot' and last_op[0] == 'cnot':\n                if op[1] != last_op[1] and op[1] != last_op[2] and op[2] != last_op[1] and op[2] != last_op[2]:\n                    current_layer.append(op)\n                else:\n                    layers.append(current_layer)\n                    current_layer = [op]\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'cnot'])\n\ndef op_list_to_string(op_list, sep=' '):\n    strs = []\n    for op in op_list:\n        if op[0] == 'cnot':\n            strs.append(f'CNOT({op[1]},{op[2]})')\n    return sep.join(strs)\n\ndef sym_cnot(U):\n    n = U.shape[1] // 2\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n,:n] = U[:n,:n]\n    S[n:,n:] = U[n:,n:]\n    return S\n\ndef bin_mat_inv(A):\n    try:\n        return np.linalg.inv(A).astype(int) % 2\n    except:\n        return A\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    V = np.eye(2*n, dtype=int)\n    for op in ops:\n        if op[0] == 'cnot':\n            c, t = op[1], op[2]\n            V[:n,:] ^= np.outer(V[:n,t], V[:n,c])\n            V[n:,:] ^= np.outer(V[n:,t], V[n:,c])\n    return np.array_equal(V, U)\n\ndef mat2SQC(UC):\n    n = UC.shape[1] // 2\n    ops = []\n    for i in range(n):\n        for j in range(n):\n            if UC[i,j] and i != j:\n                ops.append(('cnot', j, i))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: operands could not be broadcast together with shapes (8,16) (8,8) (8,16) ",
        "execution_method": "single_subprocess"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 35,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 36,
    "parent_id": 1,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Fixed parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': False,  # Disable log heuristic\n        'hr': 1,     # Reduced heuristic multiplier\n        'wMax': 10\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or (hB_val, hB_tuple) < h_min:\n            curr_wait = 0\n            h_min = (hB_val, hB_tuple)\n        else:\n            curr_wait += 1\n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            return [], A\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    col_sums = tuple(sorted(U.sum(axis=0)))\n    row_sums = tuple(sorted(U.sum(axis=1)))\n    w = (col_sums, row_sums)\n    h0 = U.sum()\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    # X part: columns 0 to n-1\n    inner_X = U[:, :n].T @ U[:, :n]\n    # Z part: columns n to 2n-1\n    inner_Z = U[:, n:].T @ U[:, n:]\n    # Combine non-zero pairs from both parts\n    pairs = set()\n    rows1, cols1 = np.nonzero(inner_X)\n    for i, j in zip(rows1, cols1):\n        if i != j:\n            pairs.add((i, j))\n    rows2, cols2 = np.nonzero(inner_Z)\n    for i, j in zip(rows2, cols2):\n        if i != j:\n            pairs.add((i, j))\n    return [('CX', (i, j)) for (i, j) in pairs]\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n# Single-qubit Clifford layer extraction\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": -4.933333333333337,
      "additional_data": {
        "score": "-4.933333",
        "total_compute_time": "7.083941",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-reasoner",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 19,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 19
    }
  },
  {
    "id": 37,
    "parent_id": 35,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': False,\n        'ht': False,\n        'hl': False,\n        'hr': 2,\n        'wMax': 3\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    if U is None:\n        n = 0\n        return n, 0, 0, 0.0, False, \"\"\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        candidates = []\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            candidates.append((key, hB_val, op, B))\n        \n        if not candidates:\n            break\n            \n        candidates.sort()\n        best_key, best_h_val, best_op, best_B = candidates[0]\n        \n        if best_h_val >= h_val:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n        else:\n            curr_wait = 0\n            \n        U = best_B\n        op_list.append(best_op)\n        best_h = min(best_h, best_h_val)\n\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    col_nonzero = (top != 0).sum(axis=0)\n    h_col = np.sum(np.log(col_sums + 1e-6) * (col_sums > 1)) - 0.1 * np.sum(np.log(col_nonzero + 1e-6))\n    h_sum = U.sum() / (2 * n * n) - 1\n    h_total = params['hr'] * (0.8 * h_col + 0.2 * h_sum)\n    sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    w = tuple(sorted(int(x) for x in sA))\n    return h_total, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    ops = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                ops.append(('cnot', i, j))\n                ops.append(('cnot', j, i))\n    return ops\n\ndef apply_op(U, op):\n    n = U.shape[1] // 2\n    V = U.copy()\n    if op[0] == 'cnot':\n        c, t = op[1], op[2]\n        V[:n,:n] ^= np.outer(V[:n,t], V[:n,c])\n        V[n:,n:] ^= np.outer(V[n:,t], V[n:,c])\n    return V\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            last_op = current_layer[-1]\n            if op[0] == 'cnot' and last_op[0] == 'cnot':\n                if op[1] != last_op[1] and op[1] != last_op[2] and op[2] != last_op[1] and op[2] != last_op[2]:\n                    current_layer.append(op)\n                else:\n                    layers.append(current_layer)\n                    current_layer = [op]\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'cnot'])\n\ndef op_list_to_string(op_list, sep=' '):\n    strs = []\n    for op in op_list:\n        if op[0] == 'cnot':\n            strs.append(f'CNOT({op[1]},{op[2]})')\n    return sep.join(strs)\n\ndef sym_cnot(U):\n    n = U.shape[1] // 2\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n,:n] = U[:n,:n]\n    S[n:,n:] = U[n:,n:]\n    return S\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    V = np.eye(2*n, dtype=int)\n    for op in ops:\n        if op[0] == 'cnot':\n            c, t = op[1], op[2]\n            V[:n,:n] ^= np.outer(V[:n,t], V[:n,c])\n            V[n:,n:] ^= np.outer(V[n:,t], V[n:,c])\n    return np.array_equal(V, U)\n\ndef mat2SQC(UC):\n    n = UC.shape[1] // 2\n    ops = []\n    for i in range(n):\n        for j in range(n):\n            if UC[i,j] and i != j:\n                ops.append(('cnot', j, i))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()",
        "execution_method": "single_subprocess"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 39,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 38,
    "parent_id": 13,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\nfrom collections import defaultdict\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 8,\n        'max_iters': 100,\n        'early_term': 0.001\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    no_improve = 0\n    \n    for _ in range(params['max_iters']):\n        h_val, h_tuple = enhanced_heuristic(U, params)\n        if h_val <= params['early_term']:\n            break\n            \n        best_op = None\n        best_delta = float('inf')\n        best_U = None\n        \n        for op in expanded_gl_options(U):\n            new_U = apply_op(U, op)\n            new_h, _ = enhanced_heuristic(new_U, params)\n            delta = new_h - h_val\n            \n            if delta < best_delta:\n                best_delta = delta\n                best_op = op\n                best_U = new_U\n        \n        if best_op is None:\n            break\n            \n        op_list.append(best_op)\n        U = best_U\n        \n        if h_val < best_h:\n            best_h = h_val\n            no_improve = 0\n        else:\n            no_improve += 1\n            if no_improve > params['wMax']:\n                break\n    \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef enhanced_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    total_sum = top.sum()\n    \n    log_cols = np.log(np.maximum(col_sums, 1))\n    log_rows = np.log(np.maximum(row_sums, 1))\n    \n    col_metrics = tuple(sorted(col_sums))\n    row_metrics = tuple(sorted(row_sums))\n    inv_metrics = tuple(sorted(bottom.sum(axis=0)))\n    trans_metrics = tuple(sorted(top.T.sum(axis=0)))\n    \n    h_sum = total_sum / (n*n)\n    h_log = (log_cols.sum() + log_rows.sum()) / (2*n)\n    h_col = sum(1/x for x in col_sums if x > 0) / n\n    \n    combined_h = 0.5*h_sum + 0.25*h_log + 0.25*h_col\n    h_tuple = (col_metrics, row_metrics, inv_metrics, trans_metrics)\n    \n    return combined_h, h_tuple\n\ndef expanded_gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    options = []\n    \n    # Standard CX options\n    for i in range(n):\n        for j in range(n):\n            if i != j and top[i,j] == 1:\n                options.append(('CX', (i, j)))\n    \n    # Additional options based on column operations\n    for j in range(n):\n        if top[:,j].sum() > 1:\n            for i in range(n):\n                if top[i,j] == 1:\n                    options.append(('CX', (i, j)))\n    \n    return options\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 37,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 39,
    "parent_id": 27,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 20\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = float('inf')\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U, params):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if hB_val < h_min:\n            curr_wait = 0\n            h_min = hB_val\n        else:\n            curr_wait += 1\n            if params['wMax'] > 0 and curr_wait > params['wMax']:\n                break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    \n    # Column-based heuristic\n    h_col = sum(np.log2(cs + 1) for cs in col_sums)\n    \n    # Row-based heuristic\n    h_row = sum(np.log2(rs + 1) for rs in row_sums)\n    \n    # Combined heuristic\n    h0 = min(h_col, h_row)\n    \n    if params['hi']:\n        inv_top = bin_mat_inv(top.T).T\n        h_inv = sum(np.log2(cs + 1) for cs in inv_top.sum(axis=0))\n        h0 = min(h0, h_inv)\n    \n    if params['ht']:\n        trans_top = top.T\n        h_trans = sum(np.log2(cs + 1) for cs in trans_top.sum(axis=0))\n        h0 = min(h0, h_trans)\n    \n    w = tuple(sorted(int(x) for x in col_sums))\n    return params['hr'] * h0, w\n\ndef gl_options(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    opts = []\n    \n    # Add CNOTs from max column\n    max_col = np.argmax(col_sums)\n    for j in range(n):\n        if j != max_col and top[max_col, j]:\n            opts.append(('CX', (max_col, j)))\n    \n    # Add CNOTs to max row\n    max_row = np.argmax(row_sums)\n    for j in range(n):\n        if j != max_row and top[j, max_row]:\n            opts.append(('CX', (j, max_row)))\n    \n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 3,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 38,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 40,
    "parent_id": 30,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappush, heappop\nimport math\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    # Consider original, transpose, and inverse\n    matrices = [(U, 'original'), (U.T, 'transpose'), (bin_mat_inv(U), 'inverse')]\n    \n    best_result = None\n    best_gates = float('inf')\n    \n    for mat, desc in matrices:\n        try:\n            sym = np.zeros((2*n, 2*n), dtype=int)\n            sym[:n, :n] = mat % 2\n            sym[n:, n:] = bin_mat_inv(mat.T) % 2\n            \n            op_list, UC = beam_search(sym, beam_width=10, max_depth=50)\n            if not is_identity(UC):\n                continue\n                \n            gate_count = count_entangling(op_list)\n            if gate_count < best_gates:\n                best_gates = gate_count\n                best_result = (n, gate_count, len(op_list_layers(op_list)), \n                              time.time() - start, True, op_list_to_string(op_list))\n        except:\n            continue\n    \n    if best_result is None:\n        return (n, 0, 0, time.time()-start, False, \"\")\n    return best_result\n\ndef beam_search(U, beam_width=10, max_depth=50):\n    n = U.shape[0] // 2\n    beam = [(heuristic(U), [], U.copy())]\n    \n    for _ in range(max_depth):\n        new_beam = []\n        \n        for _, ops, current in beam:\n            if is_identity(current):\n                return ops, current\n                \n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        for ctrl, targ in [(i,j), (j,i)]:\n                            new_U = apply_cnot(current, ctrl, targ)\n                            new_ops = ops + [('CX', (ctrl, targ))]\n                            h = heuristic(new_U)\n                            heappush(new_beam, (h, new_ops, new_U))\n                            \n                            if len(new_beam) > beam_width * 20:\n                                new_beam = new_beam[:beam_width]\n        \n        if not new_beam:\n            break\n            \n        beam = new_beam[:beam_width]\n        if is_identity(beam[0][2]):\n            return beam[0][1], beam[0][2]\n    \n    if beam:\n        return beam[0][1], beam[0][2]\n    return [], U\n\ndef heuristic(U):\n    n = U.shape[0] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    \n    # Improved heuristic with logarithmic weights and column-wise metrics\n    col_heuristic = sum(math.log2(s + 1) if s > 0 else 0 for s in col_sums)\n    row_heuristic = sum(math.log2(s + 1) if s > 0 else 0 for s in row_sums)\n    \n    # Column-wise progress metric\n    col_progress = sum(1 for s in col_sums if s == 1)\n    \n    return (col_heuristic + row_heuristic) / (2*n) - col_progress/n\n\ndef is_identity(U):\n    n = U.shape[0] // 2\n    return np.array_equal(U[:n, :n], np.eye(n)) and np.array_equal(U[n:, n:], np.eye(n))\n\ndef apply_cnot(U, ctrl, targ):\n    n = U.shape[0] // 2\n    U_new = U.copy()\n    U_new[:, targ] ^= U_new[:, ctrl]\n    U_new[:, n + ctrl] ^= U_new[:, n + targ]\n    return U_new\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q)\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f'{typ}:{q[0]},{q[1]}' for typ, q in op_list)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 40,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 41,
    "parent_id": 31,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    if U is None or not isinstance(U, np.ndarray):\n        U = np.eye(2)\n    n = U.shape[0] // 2\n    if n == 0:\n        n = 1\n        U = np.eye(2)\n    \n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'beam_width': 4,\n        'minDepth': False,\n        'hv': True,\n        'hi': False,\n        'ht': False,\n        'hl': True,\n        'hr': 2,\n        'wMax': 10,\n        'timeout': 10\n    }\n    \n    start = time.time()\n    try:\n        sym = prepare_matrix(U)\n        op_list, UC = csynth_beam(sym, params, start)\n        sqc_ops = mat2SQC(UC)\n        full_ops = sqc_ops + op_list\n        depth = len(op_list_layers(full_ops))\n        gate_count = count_entangling(full_ops)\n        proc_time = time.time() - start\n        circ = op_list_to_string(full_ops)\n        check = sym_test(U, full_ops)\n        return n, gate_count, depth, proc_time, check, circ\n    except:\n        return n, 0, 0, 0, False, \"\"\n\ndef prepare_matrix(U):\n    n = U.shape[0] // 2\n    if n == 0:\n        n = 1\n    sym = np.zeros((2*n, 2*n), dtype=int)\n    sym[:n,:n] = U[:n,:n] % 2\n    sym[n:,n:] = U[n:,n:] % 2\n    sym[n:,:n] = U[n:,:n] % 2\n    sym[:n,n:] = U[:n,n:] % 2\n    return sym\n\ndef csynth_beam(A, params, start_time):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], float('inf'))])\n    best_h = float('inf')\n    best_state = (A.copy(), [])\n    \n    while beam and time.time() - start_time < params['timeout']:\n        current_U, current_ops, current_h = beam.popleft()\n        \n        if np.array_equal(current_U, np.eye(2*n)):\n            best_state = (current_U, current_ops)\n            break\n            \n        h_val, h_weights = gl_heuristic(current_U, params)\n        if h_val < best_h:\n            best_h = h_val\n            best_state = (current_U.copy(), current_ops.copy())\n        \n        if h_val <= 1e-5:\n            break\n            \n        candidates = []\n        for op in gl_options(current_U):\n            new_U = apply_op(current_U, op)\n            new_ops = current_ops + [op]\n            h_new, _ = gl_heuristic(new_U, params)\n            candidates.append((new_U, new_ops, h_new))\n        \n        candidates.sort(key=lambda x: (x[2], len(x[1])))\n        beam.extend(candidates[:params['beam_width']])\n    \n    return best_state[1], best_state[0]\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n,:n]\n    bottom = U[n:,n:]\n    \n    col_sums = top.sum(axis=0) + bottom.sum(axis=0)\n    row_sums = top.sum(axis=1) + bottom.sum(axis=1)\n    \n    w = tuple(sorted(int(x) for x in col_sums + row_sums))\n    \n    h_components = []\n    h_components.append(U.sum() / (4*n**2))\n    \n    if params['hl']:\n        log_sum = np.log(col_sums + 1).sum() / n\n        h_components.append(log_sum)\n    \n    h0 = sum(h_components) / len(h_components) if h_components else 0\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    opts = []\n    \n    for j in range(n):\n        for i in range(n):\n            if i != j and top[i,j] == 1:\n                opts.append(('CX', (i, j)))\n    \n    return list(set(opts))\n\ndef apply_op(U, op):\n    n = U.shape[0] // 2\n    V = U.copy()\n    if op[0] == 'CX':\n        c, t = op[1]\n        if c < n and t < n:\n            V[:n,t] ^= V[:n,c]\n            V[n:,t] ^= V[n:,c]\n    return V\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            can_add = True\n            for prev_op in current_layer:\n                if op[1][0] == prev_op[1][1] or op[1][1] == prev_op[1][0]:\n                    can_add = False\n                    break\n            if can_add:\n                current_layer.append(op)\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'CX'])\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f\"{op[0]}{op[1]}\" for op in op_list)\n\ndef sym_test(U, ops):\n    try:\n        n = U.shape[0] // 2\n        reconstructed = op_list2sym(ops, n)\n        return np.array_equal(U % 2, reconstructed % 2)\n    except:\n        return False\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        if op[0] == 'CX':\n            c, t = op[1]\n            U[t] ^= U[c]\n    return U\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    ops = []\n    for j in range(n):\n        for i in range(j+1, n):\n            if UC[i,j]:\n                ops.append(('CX', (i, j)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 43,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 42,
    "parent_id": 3,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved CNOT circuit synthesis using beam search with enhanced heuristics.\n\"\"\"\n\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,\n        'wMax': 15,\n        'beam_width': 3,\n        'lookahead': 2\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], 0)])\n    \n    for _ in range(params['wMax'] * 2):\n        new_beam = []\n        for state in beam:\n            U, ops, wait = state\n            h_val = gl_heuristic_enhanced(U, params)\n            if h_val <= 0.1:\n                return ops, U\n            \n            candidates = []\n            for op in enhanced_gl_options(U):\n                B = apply_op(U.copy(), op)\n                hB = gl_heuristic_enhanced(B, params)\n                candidates.append((hB, B, op))\n            \n            candidates.sort()\n            for hB, B, op in candidates[:params['beam_width']]:\n                new_ops = ops + [op]\n                if hB < h_val:\n                    new_beam.append((B, new_ops, 0))\n                else:\n                    new_beam.append((B, new_ops, wait + 1))\n        \n        if not new_beam:\n            break\n            \n        new_beam.sort(key=lambda x: (gl_heuristic_enhanced(x[0], params), len(x[1])))\n        beam = deque(new_beam[:params['beam_width']])\n    \n    best_state = min(beam, key=lambda x: (gl_heuristic_enhanced(x[0], params), len(x[1])))\n    return best_state[1], best_state[0]\n\ndef gl_heuristic_enhanced(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    \n    mats = [top]\n    if params['hi']:\n        mats.append(bin_mat_inv(top))\n    if params['ht']:\n        mats.append(top.T)\n    if params['hv']:\n        mats.append(bin_mat_inv(top.T))\n    \n    min_h = float('inf')\n    for mat in mats:\n        col_sums = mat.sum(axis=0)\n        row_sums = mat.sum(axis=1)\n        \n        h_col = np.sum(np.log(col_sums + (col_sums == 0)))\n        h_row = np.sum(np.log(row_sums + (row_sums == 0)))\n        \n        h = (h_col + h_row) / (2 * n)\n        if h < min_h:\n            min_h = h\n    \n    return min_h\n\ndef enhanced_gl_options(U):\n    n = U.shape[1] // 2\n    options = []\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                options.append(('CX', (i, j)))\n    \n    return options\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    synthesized = op_list2sym(ops, n)\n    return np.array_equal(U, synthesized)\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()",
        "execution_method": "single_subprocess"
      }
    },
    "children": 3,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 42,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 43,
    "parent_id": 17,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved search.py with fixed dimension handling and robust heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n    \"\"\"\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': False,  # Disabled to prevent dimension issues\n        'hl': True,\n        'hr': 4,\n        'wMax': 8\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        best = None\n        best_dh = None\n        best_B = None\n        \n        if params['hi'] and np.random.rand() < 0.1:\n            inv_U = bin_mat_inv(U[:n,:n].T)\n            inv_h, inv_tuple = gl_heuristic(inv_U, params)\n            if inv_h < h_val:\n                U = inv_U\n                op_list.append(('INV', (0,)))\n                continue\n                \n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n                \n        if best is None:\n            break\n            \n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        \n        if h_min is None or hB_val < h_min[1]:\n            curr_wait = 0\n            h_min = (h_tuple, hB_val)\n        else:\n            curr_wait += 1\n            \n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            break\n            \n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    sA = U[:n,:n].sum(axis=0)  # Only consider top-left block\n        \n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    \n    h_components = []\n    if params['hl']:\n        h_components.append(np.log(sA + 1e-6).sum() / Ls)\n    h_components.append((U[:n,:n].sum() / (n*n) - 1))\n    \n    h0 = sum(h_components) / len(h_components)\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: tuple index out of range",
        "execution_method": "single_subprocess"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 41,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 44,
    "parent_id": 34,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappush, heappop\nimport math\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    matrices = [\n        (U, 'original'),\n        (U.T, 'transpose'),\n        (bin_mat_inv(U), 'inverse'),\n        (bin_mat_inv(U).T, 'inverse_transpose')\n    ]\n    \n    best_result = None\n    best_gates = float('inf')\n    \n    for mat, desc in matrices:\n        try:\n            sym = np.zeros((2*n, 2*n), dtype=int)\n            sym[:n, :n] = mat % 2\n            sym[n:, n:] = bin_mat_inv(mat.T) % 2\n            \n            op_list, UC = beam_search(sym, beam_width=10, max_depth=30)\n            if not is_identity(UC):\n                continue\n                \n            gate_count = count_entangling(op_list)\n            if gate_count < best_gates:\n                best_gates = gate_count\n                best_result = (n, gate_count, len(op_list_layers(op_list)), \n                              time.time() - start, True, op_list_to_string(op_list))\n                if time.time() - start > 15:  # More generous early termination\n                    return best_result\n        except:\n            continue\n    \n    if best_result is None:\n        return (n, 0, 0, time.time()-start, False, \"\")\n    return best_result\n\ndef beam_search(U, beam_width=10, max_depth=30):\n    n = U.shape[0] // 2\n    beam = [(heuristic(U), [], U.copy())]\n    \n    for _ in range(max_depth):\n        new_beam = []\n        \n        for _, ops, current in beam:\n            if is_identity(current):\n                return ops, current\n                \n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        for ctrl, targ in [(i,j), (j,i)]:\n                            new_U = apply_cnot(current, ctrl, targ)\n                            new_ops = ops + [('CX', (ctrl, targ))]\n                            h = heuristic(new_U)\n                            heappush(new_beam, (h, new_ops, new_U))\n                            \n                            if len(new_beam) > beam_width * 50:\n                                new_beam = sorted(new_beam, key=lambda x: x[0])[:beam_width]\n        \n        if not new_beam:\n            break\n            \n        beam = sorted(new_beam, key=lambda x: x[0])[:beam_width]\n    \n    if beam:\n        return beam[0][1], beam[0][2]\n    return [], U\n\ndef heuristic(U):\n    n = U.shape[0] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    col_metric = sum(math.log2(x + 1) for x in col_sums) + max(col_sums)\n    row_metric = sum(math.log2(x + 1) for x in row_sums) + max(row_sums)\n    return (col_metric, row_metric)  # Tuple heuristic avoids local minima\n\ndef is_identity(U):\n    n = U.shape[0] // 2\n    return np.array_equal(U[:n, :n], np.eye(n)) and np.array_equal(U[n:, n:], np.eye(n))\n\ndef apply_cnot(U, ctrl, targ):\n    n = U.shape[0] // 2\n    U_new = U.copy()\n    U_new[:, targ] ^= U_new[:, ctrl]\n    U_new[:, n + ctrl] ^= U_new[:, n + targ]\n    return U_new\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q)\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f'{typ}:{q[0]},{q[1]}' for typ, q in op_list)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 46,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 45,
    "parent_id": 22,
    "solution": "\nimport numpy as np\nimport time\nimport heapq\nfrom collections import defaultdict\n\ndef search(U):\n    start_time = time.time()\n    n = U.shape[0] // 2 if U is not None and isinstance(U, np.ndarray) else 1\n    if U is None or not isinstance(U, np.ndarray) or U.shape[0] == 0:\n        U = np.eye(2)\n    \n    try:\n        sym = prepare_matrix(U)\n        params = {\n            'timeout': 20,\n            'heuristic_weights': [0.4, 0.3, 0.2, 0.1],\n            'max_depth': 4*n,\n            'use_inverse': True,\n            'use_transpose': True\n        }\n        \n        result = a_star_search(sym, params, start_time)\n        if result is None:\n            return n, 0, 0, 0, False, \"\"\n        \n        op_list, final_matrix = result\n        full_ops = mat2SQC(final_matrix) + op_list\n        gate_count = count_entangling(full_ops)\n        depth = len(op_list_layers(full_ops))\n        proc_time = time.time() - start_time\n        circ = op_list_to_string(full_ops)\n        check = sym_test(U, full_ops)\n        return n, gate_count, depth, proc_time, check, circ\n    except:\n        return n, 0, 0, 0, False, \"\"\n\ndef prepare_matrix(U):\n    n = U.shape[0] // 2\n    sym = np.zeros((2*n, 2*n), dtype=int)\n    sym[:n,:n] = U[:n,:n] % 2\n    sym[n:,n:] = U[n:,n:] % 2\n    sym[n:,:n] = U[n:,:n] % 2\n    sym[:n,n:] = U[:n,n:] % 2\n    return sym\n\ndef a_star_search(initial_matrix, params, start_time):\n    open_set = []\n    closed_set = set()\n    \n    initial_heuristic = combined_heuristic(initial_matrix, params)\n    heapq.heappush(open_set, (initial_heuristic, 0, [], initial_matrix))\n    \n    best_solution = None\n    best_gates = float('inf')\n    \n    while open_set and time.time() - start_time < params['timeout']:\n        _, cost_so_far, path, current_matrix = heapq.heappop(open_set)\n        \n        if is_identity(current_matrix):\n            if len(path) < best_gates:\n                best_solution = (path, current_matrix)\n                best_gates = len(path)\n                if best_gates <= 2*n:  # Early termination for optimal solutions\n                    break\n            continue\n        \n        if cost_so_far > params['max_depth']:\n            continue\n        \n        matrix_hash = matrix_to_hash(current_matrix)\n        if matrix_hash in closed_set:\n            continue\n        closed_set.add(matrix_hash)\n        \n        for op in generate_operations(current_matrix):\n            new_matrix = apply_operation(current_matrix, op)\n            new_path = path + [op]\n            new_cost = cost_so_far + 1\n            \n            heuristic = combined_heuristic(new_matrix, params)\n            total_cost = new_cost + heuristic\n            \n            if total_cost < best_gates:\n                heapq.heappush(open_set, (total_cost, new_cost, new_path, new_matrix))\n    \n    return best_solution\n\ndef combined_heuristic(matrix, params):\n    n = matrix.shape[0] // 2\n    top = matrix[:n, :n]\n    bottom = matrix[n:, n:]\n    \n    heuristics = []\n    \n    # Column sum heuristic\n    col_sums = top.sum(axis=0) + bottom.sum(axis=0)\n    h_col = np.sum(np.log2(np.maximum(col_sums, 1)))\n    heuristics.append(h_col)\n    \n    # Row sum heuristic\n    row_sums = top.sum(axis=1) + bottom.sum(axis=1)\n    h_row = np.sum(np.log2(np.maximum(row_sums, 1)))\n    heuristics.append(h_row)\n    \n    # Matrix rank heuristic\n    try:\n        rank = np.linalg.matrix_rank(top)\n        h_rank = (n - rank) * 2\n        heuristics.append(h_rank)\n    except:\n        heuristics.append(0)\n    \n    # Diagonal heuristic\n    diag = np.diag(top) + np.diag(bottom)\n    h_diag = n - np.sum(diag)\n    heuristics.append(h_diag)\n    \n    # Weighted combination\n    weights = params['heuristic_weights']\n    weighted_sum = sum(w*h for w, h in zip(weights, heuristics[:len(weights)]))\n    \n    return weighted_sum\n\ndef is_identity(matrix):\n    n = matrix.shape[0] // 2\n    return (np.array_equal(matrix[:n,:n], np.eye(n)) and \n            np.array_equal(matrix[n:,n:], np.eye(n)) and\n            np.all(matrix[n:,:n] == 0) and \n            np.all(matrix[:n,n:] == 0))\n\ndef generate_operations(matrix):\n    n = matrix.shape[0] // 2\n    top = matrix[:n, :n]\n    operations = set()\n    \n    # Column operations\n    for j in range(n):\n        ones = np.where(top[:,j] == 1)[0]\n        if len(ones) > 1:\n            for i in ones:\n                if i != j:\n                    operations.add(('CX', (i, j)))\n    \n    # Row operations\n    for i in range(n):\n        ones = np.where(top[i,:] == 1)[0]\n        if len(ones) > 1:\n            for j in ones:\n                if i != j:\n                    operations.add(('CX', (j, i)))\n    \n    return list(operations)\n\ndef apply_operation(matrix, op):\n    n = matrix.shape[0] // 2\n    new_matrix = matrix.copy()\n    if op[0] == 'CX':\n        c, t = op[1]\n        new_matrix[:n,t] ^= new_matrix[:n,c]\n        new_matrix[n:,t] ^= new_matrix[n:,c]\n    return new_matrix\n\ndef matrix_to_hash(matrix):\n    return hash(matrix.tobytes())\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            can_add = True\n            for prev_op in current_layer:\n                if op[1][0] == prev_op[1][1] or op[1][1] == prev_op[1][0]:\n                    can_add = False\n                    break\n            if can_add:\n                current_layer.append(op)\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'CX'])\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f\"{op[0]}{op[1]}\" for op in op_list)\n\ndef sym_test(U, ops):\n    try:\n        n = U.shape[0] // 2\n        reconstructed = op_list2sym(ops, n)\n        return np.array_equal(U % 2, reconstructed % 2)\n    except:\n        return False\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        if op[0] == 'CX':\n            c, t = op[1]\n            U[t] ^= U[c]\n    return U\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    ops = []\n    for j in range(n):\n        for i in range(j+1, n):\n            if UC[i,j]:\n                ops.append(('CX', (i, j)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 45,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 3
    }
  },
  {
    "id": 46,
    "parent_id": 15,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import defaultdict\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': False,  # Disabled inverse ops for speed\n        'ht': True,\n        'hl': True,\n        'hr': 3,  # Reduced heuristic repeat\n        'wMax': 10,  # Reduced wait max\n        'max_iter': 100,  # Reduced iterations\n        'early_term': 0.01  # More aggressive early termination\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    best_U = None\n    best_ops = []\n    curr_wait = 0\n    prev_h = float('inf')\n    \n    for iteration in range(params['max_iter']):\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        if h_val < best_h:\n            best_h = h_val\n            best_U = U.copy()\n            best_ops = op_list.copy()\n            curr_wait = 0\n        else:\n            curr_wait += 1\n            \n        if curr_wait > params['wMax']:\n            U = best_U\n            op_list = best_ops\n            break\n            \n        if iteration > 5 and abs(prev_h - h_val) / (prev_h + 1e-9) < params['early_term']:\n            break\n        prev_h = h_val\n        \n        best_op = None\n        best_dh = float('inf')\n        best_B = None\n        \n        for op in gl_options(U, params):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            dh = hB_val - h_val\n            \n            if dh < best_dh:\n                best_dh = dh\n                best_op = op\n                best_B = B\n                \n        if best_op is None:\n            break\n            \n        U = best_B\n        op_list.append(best_op)\n        \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    \n    col_sums = top.sum(axis=0)\n    h_sum = U.sum() - 2*n\n    h_log = np.log(np.maximum(col_sums, 1)).sum()\n    h_col = (col_sums * (col_sums - 1)).sum()\n    \n    h0 = 0.6*h_sum + 0.3*h_log + 0.1*h_col\n    w = tuple(sorted(col_sums))\n    \n    return params['hr'] * h0, w\n\ndef gl_options(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    \n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    \n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    \n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    \n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ.startswith('CX'))\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.958392",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 49,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 47,
    "parent_id": 12,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\nimport math\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 4,  # Increased from 3\n        'wMax': 20  # Increased from 15\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    best_h = float('inf')\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        if h_val < best_h - 1e-5:\n            best_h = h_val\n            curr_wait = 0\n        else:\n            curr_wait += 1\n        \n        if curr_wait > params['wMax']:\n            return [], A\n            \n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    # Extract the U part (top-left) and V part (bottom-right)\n    top_left = U[:n, :n]\n    bottom_right = U[n:, n:]\n    col_sums_U = top_left.sum(axis=0)   # shape (n,)\n    col_sums_V = bottom_right.sum(axis=0) # shape (n,)\n    sA = np.concatenate([col_sums_U, col_sums_V])\n    log_sum = 0\n    for x in sA:\n        log_sum += math.log(x)\n    h0 = log_sum / (2 * n)   # average over 2n\n    w = tuple(sorted(sA))\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    opts = set()\n    # For top part\n    prod_top = (top.T @ top) % 2\n    rows, cols = np.nonzero(prod_top)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.add(('CX', (i, j)))\n    # For bottom part\n    prod_bottom = (bottom.T @ bottom) % 2\n    rows, cols = np.nonzero(prod_bottom)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.add(('CX', (i, j)))\n    return list(opts)\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.229786",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-reasoner",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 33,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 48,
    "parent_id": 12,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\nimport math\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,  # Increased from 4\n        'wMax': 12  # Balanced between quality and speed\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    best_h = float('inf')\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        if h_val < best_h - 1e-5:\n            best_h = h_val\n            curr_wait = 0\n        else:\n            curr_wait += 1\n        \n        if curr_wait > params['wMax']:\n            return [], A\n            \n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    # Consider both original and transposed matrices\n    col_sums = U.sum(axis=0)\n    row_sums = U.sum(axis=1)\n    sA = np.concatenate([col_sums, row_sums])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    # Improved heuristic components\n    log_sum = 0\n    for x in sA:\n        if x > 0:\n            log_sum += math.log(x)\n    h0 = log_sum / (2*n)\n    \n    # Additional component for column/row balance\n    col_balance = sum(1 for x in col_sums[:n] if x == 1)\n    row_balance = sum(1 for x in row_sums[:n] if x == 1)\n    h1 = (col_balance + row_balance) / (2*n)\n    \n    # Combined heuristic\n    h = params['hr'] * (h0 + 0.5 * h1)\n    \n    return h, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: cannot unpack non-iterable NoneType object",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 50,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 3
    }
  },
  {
    "id": 49,
    "parent_id": 39,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': True,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,\n        'wMax': 30,\n        'timeout': 15\n    }\n    start_time = time.time()\n    n = U.shape[1] // 2\n    best_result = (n, float('inf'), float('inf'), 0.0, False, \"\")\n    \n    # Try original matrix\n    result = try_synthesis(U, params, start_time)\n    if result[4] and result[1] < best_result[1]:\n        best_result = result\n    \n    # Try transpose\n    if time.time() - start_time < params['timeout']:\n        U_trans = U.T.copy()\n        result = try_synthesis(U_trans, params, start_time)\n        if result[4] and result[1] < best_result[1]:\n            best_result = result\n    \n    # Try inverse\n    if time.time() - start_time < params['timeout']:\n        try:\n            U_inv = np.linalg.inv(U).astype(int) % 2\n            result = try_synthesis(U_inv, params, start_time)\n            if result[4] and result[1] < best_result[1]:\n                best_result = result\n        except:\n            pass\n    \n    return best_result\n\ndef try_synthesis(U, params, start_time):\n    sym = sym_cnot(U)\n    return synth_main(sym, params, start_time)\n\ndef synth_main(U, params, start_time):\n    n = U.shape[1] // 2\n    op_list, UC = csynth_greedy(U, params, start_time)\n    if op_list is None:\n        return (n, float('inf'), float('inf'), time.time() - start_time, False, \"\")\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start_time\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params, start_time):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = float('inf')\n    curr_wait = 0\n    \n    while time.time() - start_time < params['timeout']:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        best = None\n        best_dh = None\n        best_B = None\n        \n        for op in generate_all_cnots(n):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            \n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n                \n        if best is None:\n            break\n            \n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        \n        if hB_val < h_min:\n            curr_wait = 0\n            h_min = hB_val\n        else:\n            curr_wait += 1\n            if params['wMax'] > 0 and curr_wait > params['wMax']:\n                break\n                \n    if time.time() - start_time >= params['timeout']:\n        return None, None\n        \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef generate_all_cnots(n):\n    ops = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                ops.append(('CX', (i, j)))\n                ops.append(('CX', (j, i)))\n    return ops\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    \n    # Enhanced logarithmic heuristic\n    h_col = sum(np.log2(cs + 1) ** 2 for cs in col_sums)\n    h_row = sum(np.log2(rs + 1) ** 2 for rs in row_sums)\n    h0 = min(h_col, h_row)\n    \n    if params['hi']:\n        try:\n            inv_top = bin_mat_inv(top.T).T\n            h_inv = sum(np.log2(cs + 1) ** 2 for cs in inv_top.sum(axis=0))\n            h0 = min(h0, h_inv)\n        except:\n            pass\n    \n    if params['ht']:\n        trans_top = top.T\n        h_trans = sum(np.log2(cs + 1) ** 2 for cs in trans_top.sum(axis=0))\n        h0 = min(h0, h_trans)\n    \n    w = tuple(sorted(int(x) for x in col_sums))\n    return params['hr'] * h0, w\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef CList2opList(CList):\n    SQC_tostr = {\n        '1001': 'I', '0110': 'H',\n        '1101': 'S', '1011': 'HSH',\n        '1110': 'HS', '0111': 'SH'\n    }\n    ops = []\n    for i, M in enumerate(CList):\n        key = ''.join(str(int(x)) for x in M.ravel())\n        c = SQC_tostr.get(key, 'I')\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 51,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 50,
    "parent_id": 41,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    if U is None or not isinstance(U, np.ndarray):\n        U = np.eye(2)\n    n = U.shape[0] // 2\n    if n == 0:\n        n = 1\n        U = np.eye(2)\n    \n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'beam_width': 8,\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 15,\n        'timeout': 15\n    }\n    \n    start = time.time()\n    try:\n        sym = prepare_matrix(U)\n        op_list, UC = csynth_beam(sym, params, start)\n        sqc_ops = mat2SQC(UC)\n        full_ops = sqc_ops + op_list\n        depth = len(op_list_layers(full_ops))\n        gate_count = count_entangling(full_ops)\n        proc_time = time.time() - start\n        circ = op_list_to_string(full_ops)\n        check = sym_test(U, full_ops)\n        return n, gate_count, depth, proc_time, check, circ\n    except:\n        return n, 0, 0, 0, False, \"\"\n\ndef prepare_matrix(U):\n    n = U.shape[0] // 2\n    if n == 0:\n        n = 1\n    sym = np.zeros((2*n, 2*n), dtype=int)\n    sym[:n,:n] = U[:n,:n] % 2\n    sym[n:,n:] = U[n:,n:] % 2\n    sym[n:,:n] = U[n:,:n] % 2\n    sym[:n,n:] = U[:n,n:] % 2\n    return sym\n\ndef csynth_beam(A, params, start_time):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], float('inf'))])\n    best_h = float('inf')\n    best_state = (A.copy(), [])\n    \n    while beam and time.time() - start_time < params['timeout']:\n        current_U, current_ops, current_h = beam.popleft()\n        \n        if np.array_equal(current_U, np.eye(2*n)):\n            best_state = (current_U, current_ops)\n            break\n            \n        h_val, h_weights = gl_heuristic(current_U, params)\n        if h_val < best_h:\n            best_h = h_val\n            best_state = (current_U.copy(), current_ops.copy())\n        \n        if h_val <= 0.1:\n            break\n            \n        candidates = []\n        for op in gl_options(current_U):\n            new_U = apply_op(current_U, op)\n            new_ops = current_ops + [op]\n            h_new, _ = gl_heuristic(new_U, params)\n            candidates.append((new_U, new_ops, h_new))\n        \n        candidates.sort(key=lambda x: (x[2], len(x[1])))\n        beam.extend(candidates[:min(params['beam_width'], len(candidates))])\n    \n    return best_state[1], best_state[0]\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n,:n]\n    bottom = U[n:,n:]\n    \n    col_sums = top.sum(axis=0) + bottom.sum(axis=0)\n    row_sums = top.sum(axis=1) + bottom.sum(axis=1)\n    \n    w = tuple(sorted(int(x) for x in col_sums + row_sums))\n    \n    h_components = []\n    h_components.append(U.sum() / (4*n**2))\n    \n    if params['hl']:\n        log_sum = np.log(col_sums + 1).sum() / n\n        h_components.append(log_sum)\n    \n    if params['hi']:\n        inv_U = np.linalg.inv(U) % 2\n        h_components.append(inv_U.sum() / (4*n**2))\n    \n    if params['ht']:\n        trans_U = U.T % 2\n        h_components.append(trans_U.sum() / (4*n**2))\n    \n    h0 = sum(h_components) / len(h_components) if h_components else 0\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    opts = []\n    \n    for j in range(n):\n        for i in range(n):\n            if i != j and top[i,j] == 1:\n                opts.append(('CX', (i, j)))\n    \n    return list(set(opts))\n\ndef apply_op(U, op):\n    n = U.shape[0] // 2\n    V = U.copy()\n    if op[0] == 'CX':\n        c, t = op[1]\n        if c < n and t < n:\n            V[:n,t] ^= V[:n,c]\n            V[n:,t] ^= V[n:,c]\n    return V\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            can_add = True\n            for prev_op in current_layer:\n                if op[1][0] == prev_op[1][1] or op[1][1] == prev_op[1][0]:\n                    can_add = False\n                    break\n            if can_add:\n                current_layer.append(op)\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'CX'])\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f\"{op[0]}{op[1]}\" for op in op_list)\n\ndef sym_test(U, ops):\n    try:\n        n = U.shape[0] // 2\n        reconstructed = op_list2sym(ops, n)\n        return np.array_equal(U % 2, reconstructed % 2)\n    except:\n        return False\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        if op[0] == 'CX':\n            c, t = op[1]\n            U[t] ^= U[c]\n    return U\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    ops = []\n    for j in range(n):\n        for i in range(j+1, n):\n            if UC[i,j]:\n                ops.append(('CX', (i, j)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 52,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 51,
    "parent_id": 22,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    if U is None or not isinstance(U, np.ndarray):\n        U = np.eye(2)\n    n = U.shape[0] // 2\n    if n == 0:\n        n = 1\n        U = np.eye(2)\n    \n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'beam_width': 5,\n        'minDepth': False,\n        'wMax': 15,\n        'timeout': 10\n    }\n    \n    start = time.time()\n    try:\n        sym = prepare_matrix(U)\n        op_list, UC = csynth_beam(sym, params, start)\n        depth = len(op_list_layers(op_list))\n        gate_count = len(op_list)\n        proc_time = time.time() - start\n        circ = op_list_to_string(op_list)\n        check = sym_test(U, op_list, n)\n        return n, gate_count, depth, proc_time, check, circ\n    except Exception as e:\n        return n, 0, 0, 0, False, \"\"\n\ndef prepare_matrix(U):\n    n = U.shape[0] // 2\n    if n == 0:\n        n = 1\n    sym = np.zeros((2*n, 2*n), dtype=int)\n    sym[:n,:n] = U[:n,:n] % 2\n    sym[n:,n:] = U[n:,n:] % 2\n    sym[n:,:n] = U[n:,:n] % 2\n    sym[:n,n:] = U[:n,n:] % 2\n    return sym\n\ndef csynth_beam(A, params, start_time):\n    n2 = A.shape[0]\n    n = n2 // 2\n    identity = np.eye(n2, dtype=int)\n    beam = deque([(A.copy(), [], (0,0))])\n    best_state = (A.copy(), [])\n    best_heuristic = (float('inf'), float('inf'))\n    \n    while beam and time.time() - start_time < params['timeout']:\n        current_U, current_ops, current_heuristic = beam.popleft()\n        \n        if np.array_equal(current_U, identity):\n            best_state = (current_U, current_ops)\n            break\n            \n        if current_heuristic < best_heuristic:\n            best_heuristic = current_heuristic\n            best_state = (current_U.copy(), current_ops.copy())\n        \n        candidates = []\n        for op in gl_options(current_U):\n            new_U = apply_op(current_U, op)\n            new_ops = current_ops + [op]\n            h_new = gl_heuristic(new_U)\n            candidates.append((new_U, new_ops, h_new))\n        \n        candidates.sort(key=lambda x: x[2])\n        beam.extend(candidates[:params['beam_width']])\n    \n    return best_state[1], best_state[0]\n\ndef gl_heuristic(U):\n    n2 = U.shape[0]\n    extra_ones = 0\n    for j in range(n2):\n        weight = np.count_nonzero(U[:, j])\n        if weight > 1:\n            extra_ones += weight - 1\n    total_ones = np.count_nonzero(U)\n    return (extra_ones, total_ones)\n\ndef gl_options(U):\n    n2 = U.shape[0]\n    n = n2 // 2\n    opts = []\n    for j in range(n):\n        col_vals = U[:, j]\n        if np.count_nonzero(col_vals) > 1:\n            for i in range(n):\n                if U[i, j] == 1 and i != j:\n                    opts.append(('CX', (i, j)))\n    return list(set(opts))\n\ndef apply_op(U, op):\n    n2 = U.shape[0]\n    n = n2 // 2\n    V = U.copy()\n    if op[0] == 'CX':\n        c, t = op[1]\n        V[:n, t] ^= V[:n, c]\n        V[n:, t] ^= V[n:, c]\n    return V\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            can_add = True\n            for prev_op in current_layer:\n                if op[1][0] == prev_op[1][1] or op[1][1] == prev_op[1][0]:\n                    can_add = False\n                    break\n            if can_add:\n                current_layer.append(op)\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'CX'])\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f\"{op[0]}{op[1]}\" for op in op_list)\n\ndef sym_test(original, op_list, n):\n    try:\n        reconstructed = op_list2sym(op_list, n)\n        return np.array_equal(original % 2, reconstructed % 2)\n    except:\n        return False\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        if op[0] == 'CX':\n            c, t = op[1]\n            U[:n, t] ^= U[:n, c]\n            U[n:, t] ^= U[n:, c]\n    return U\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-reasoner",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 44,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 4
    }
  },
  {
    "id": 52,
    "parent_id": 42,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved CNOT circuit synthesis using beam search with enhanced heuristics.\nFixed CNOT application and symplectic matrix handling.\n\"\"\"\n\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,\n        'wMax': 12,\n        'beam_width': 4,\n        'lookahead': 1\n    }\n    return synth_main(U, params)\n\ndef synth_main(U, params):\n    U = U.astype(int) % 2\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], 0)])\n    \n    for step in range(params['wMax']):\n        new_beam = []\n        for state in beam:\n            U, ops, wait = state\n            h_val = gl_heuristic_enhanced(U, params)\n            if h_val <= 0.1:\n                return ops, U\n            \n            candidates = []\n            for op in enhanced_gl_options(U):\n                B = apply_op(U.copy(), op)\n                hB = gl_heuristic_enhanced(B, params)\n                candidates.append((hB, B, op))\n            \n            candidates.sort(key=lambda x: x[0])\n            for idx, (hB, B, op) in enumerate(candidates[:params['beam_width']]):\n                new_ops = ops + [op]\n                if hB < h_val:\n                    new_beam.append((B, new_ops, 0))\n                else:\n                    new_beam.append((B, new_ops, wait + 1))\n        \n        if not new_beam:\n            break\n            \n        new_beam.sort(key=lambda x: (gl_heuristic_enhanced(x[0], params), len(x[1])))\n        beam = deque(new_beam[:params['beam_width']])\n    \n    best_state = min(beam, key=lambda x: (gl_heuristic_enhanced(x[0], params), len(x[1])))\n    return best_state[1], best_state[0]\n\ndef gl_heuristic_enhanced(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot_right = U[n:, n:]\n    \n    mats = []\n    blocks = [top, bot_right]\n    for block in blocks:\n        mats.append(block)\n        if params['hi']:\n            try:\n                inv_block = bin_mat_inv(block)\n                mats.append(inv_block)\n            except:\n                pass\n        if params['ht']:\n            mats.append(block.T)\n        if params['hv']:\n            try:\n                inv_trans_block = bin_mat_inv(block.T)\n                mats.append(inv_trans_block)\n            except:\n                pass\n    \n    min_h = float('inf')\n    for mat in mats:\n        col_sums = mat.sum(axis=0)\n        row_sums = mat.sum(axis=1)\n        h_col = np.sum(np.log(col_sums + (col_sums == 0)))\n        h_row = np.sum(np.log(row_sums + (row_sums == 0)))\n        h = (h_col + h_row) / (2 * n)\n        if h < min_h:\n            min_h = h\n    \n    return min_h\n\ndef enhanced_gl_options(U):\n    n = U.shape[1] // 2\n    options = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                options.append(('CX', (i, j)))\n    return options\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:n, j] ^= U_new[:n, i]\n        U_new[n:, i] ^= U_new[n:, j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        if typ == 'QPerm':\n            qubits = set(range(len(q)))\n        else:\n            qubits = set(q) if isinstance(q, tuple) else {q}\n        placed = False\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                placed = True\n                break\n        if not placed:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    synthesized = op_list2sym(ops, n)\n    return np.array_equal(U, synthesized)\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] - F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: tuple index out of range",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-reasoner",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 47,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 53,
    "parent_id": 28,
    "solution": "\nimport numpy as np\nimport time\nimport math\nfrom collections import deque\nimport random\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'hybrid',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 4,\n        'wMax': 10,\n        'beam_width': 2,\n        'restart_threshold': 5,\n        'max_restarts': 2,\n        'random_perturb': 0.1\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    \n    methods = [params['method']]\n    if params['method'] != 'greedy':\n        methods.append('greedy')\n        \n    best_result = None\n    for method in methods:\n        current_params = params.copy()\n        current_params['method'] = method\n        op_list, UC = csynth_optimized(U, current_params)\n        if op_list:\n            if best_result is None or len(op_list) < len(best_result[0]):\n                best_result = (op_list, UC)\n    \n    if best_result is None:\n        return n, 0, 0, time.time()-start, False, \"\"\n    \n    op_list, UC = best_result\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_optimized(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    restarts = 0\n    stagnation = 0\n    \n    while True:\n        h_val, h_tuple = enhanced_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        if h_val < best_h - 1e-5:\n            best_h = h_val\n            stagnation = 0\n        else:\n            stagnation += 1\n            \n        if stagnation > params['wMax']:\n            if restarts < params['max_restarts']:\n                U = A.copy()\n                op_list = []\n                best_h = float('inf')\n                stagnation = 0\n                restarts += 1\n                continue\n            return [], A\n            \n        if params['method'] == 'greedy':\n            best_op, best_U = greedy_step(U, params)\n        elif params['method'] == 'beam':\n            best_op, best_U = beam_step(U, params)\n        else:\n            if len(op_list) < n*2:\n                best_op, best_U = greedy_step(U, params)\n            else:\n                best_op, best_U = beam_step(U, params)\n                \n        if best_op is None:\n            if random.random() < params['random_perturb']:\n                best_op = random.choice(extended_gl_options(U))\n                best_U = apply_op(U, best_op)\n            else:\n                return [], A\n            \n        U = best_U\n        op_list.append(best_op)\n        \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef enhanced_heuristic(U, params):\n    n = U.shape[1] // 2\n    GL = U[:n, :n]\n    GR = U[:n, n:]\n    \n    col_sums = U.sum(axis=0)\n    row_sums = U.sum(axis=1)\n    sA = np.concatenate([col_sums, row_sums])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    log_sum = sum(math.log(x) if x > 0 else 0 for x in sA)\n    h0 = log_sum / len(sA)\n    \n    h1 = np.linalg.norm(GL, 'fro') + np.linalg.norm(GR, 'fro')\n    \n    complete_cols = sum(1 for x in col_sums[:n] if x == 1)\n    h2 = (n - complete_cols) / n\n    \n    combined = params['hr'] * (0.4*h0 + 0.3*h1 + 0.3*h2)\n    \n    if params['hi'] or params['ht']:\n        min_h = combined\n        if params['hi']:\n            inv_h, _ = enhanced_heuristic(bin_mat_inv(U.T), params)\n            min_h = min(min_h, inv_h)\n        if params['ht']:\n            trans_h, _ = enhanced_heuristic(U.T, params)\n            min_h = min(min_h, trans_h)\n        combined = min_h\n    \n    return combined, w\n\ndef greedy_step(U, params):\n    best_op = None\n    best_U = None\n    best_h = float('inf')\n    \n    for op in extended_gl_options(U):\n        B = apply_op(U, op)\n        hB_val, _ = enhanced_heuristic(B, params)\n        if hB_val < best_h:\n            best_h = hB_val\n            best_op = op\n            best_U = B\n    \n    return best_op, best_U\n\ndef beam_step(U, params):\n    beam = deque()\n    beam.append((U, [], 0))\n    \n    for _ in range(params['beam_width']):\n        if not beam:\n            break\n            \n        current_U, current_ops, current_h = beam.popleft()\n        \n        for op in extended_gl_options(current_U):\n            B = apply_op(current_U, op)\n            hB_val, _ = enhanced_heuristic(B, params)\n            new_ops = current_ops + [op]\n            beam.append((B, new_ops, hB_val))\n        \n        beam = deque(sorted(beam, key=lambda x: x[2])[:params['beam_width']])\n    \n    if beam:\n        best_U, best_ops, _ = beam[0]\n        return best_ops[0], best_U\n    return None, None\n\ndef extended_gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n            opts.append(('CX', (j, i)))\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: maximum recursion depth exceeded",
        "execution_method": "single_subprocess"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 53,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 54,
    "parent_id": 37,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': False,\n        'ht': False,\n        'hl': False,\n        'hr': 1,\n        'wMax': 3\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    if U is None:\n        n = 0\n        return n, 0, 0, 0.0, False, \"\"\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val == 0:\n            break\n            \n        candidates = []\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            candidates.append((key, hB_val, op, B))\n        \n        if not candidates:\n            break\n            \n        candidates.sort()\n        best_key, best_h_val, best_op, best_B = candidates[0]\n        \n        if best_h_val >= h_val:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n        else:\n            curr_wait = 0\n            \n        U = best_B\n        op_list.append(best_op)\n        best_h = min(best_h, best_h_val)\n\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    eye = np.eye(n, dtype=int)\n    manhattan_top = np.sum(np.abs(top - eye))\n    manhattan_bottom = np.sum(np.abs(bottom - eye))\n    h_val = manhattan_top + manhattan_bottom\n    col_sums_top = top.sum(axis=0)\n    col_sums_bottom = bottom.sum(axis=0)\n    sA = np.concatenate([col_sums_top, col_sums_bottom])\n    w = tuple(sorted(int(x) for x in sA))\n    return h_val, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    ops = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                ops.append(('cnot', i, j))\n                ops.append(('cnot', j, i))\n    return ops\n\ndef apply_op(U, op):\n    n = U.shape[1] // 2\n    V = U.copy()\n    if op[0] == 'cnot':\n        c, t = op[1], op[2]\n        V[:n,:n] ^= np.outer(V[:n,t], V[:n,c])\n        V[n:,n:] ^= np.outer(V[n:,t], V[n:,c])\n    return V\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            last_op = current_layer[-1]\n            if op[0] == 'cnot' and last_op[0] == 'cnot':\n                if op[1] != last_op[1] and op[1] != last_op[2] and op[2] != last_op[1] and op[2] != last_op[2]:\n                    current_layer.append(op)\n                else:\n                    layers.append(current_layer)\n                    current_layer = [op]\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'cnot'])\n\ndef op_list_to_string(op_list, sep=' '):\n    strs = []\n    for op in op_list:\n        if op[0] == 'cnot':\n            strs.append(f'CNOT({op[1]},{op[2]})')\n    return sep.join(strs)\n\ndef sym_cnot(U):\n    n = U.shape[1] // 2\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n,:n] = U[:n,:n].astype(int)\n    S[n:,n:] = U[n:,n:].astype(int)\n    return S\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    V = np.eye(2*n, dtype=int)\n    for op in ops:\n        if op[0] == 'cnot':\n            c, t = op[1], op[2]\n            V[:n,:n] ^= np.outer(V[:n,t], V[:n,c])\n            V[n:,n:] ^= np.outer(V[n:,t], V[n:,c])\n    return np.array_equal(V, U)\n\ndef mat2SQC(UC):\n    n = UC.shape[1] // 2\n    ops = []\n    for i in range(n):\n        for j in range(n):\n            if UC[i,j] != 0 and i != j:\n                ops.append(('cnot', j, i))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-reasoner",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 48,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 55,
    "parent_id": 29,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappop, heappush\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    try:\n        if not isinstance(U, np.ndarray) or U.shape[0] != U.shape[1]:\n            return (n, 0, 0, time.time()-start, False, \"\")\n        \n        # Consider all equivalent matrix forms\n        matrices = [\n            U,\n            U.T,\n            np.linalg.inv(U).astype(int) % 2,\n            np.linalg.inv(U.T).astype(int) % 2\n        ]\n        \n        best_result = None\n        best_gates = float('inf')\n        \n        for mat in matrices:\n            try:\n                path = a_star_search(mat)\n                if path is None:\n                    continue\n                    \n                gate_count = len(path)\n                if gate_count < best_gates:\n                    depth = calculate_depth(path)\n                    best_gates = gate_count\n                    best_result = (\n                        n, gate_count, depth,\n                        time.time() - start, True,\n                        path_to_string(path)\n                    )\n                    \n                    # Early exit if perfect solution found\n                    if best_gates == n:\n                        break\n            except:\n                continue\n        \n        if best_result is None:\n            return (n, 0, 0, time.time()-start, False, \"\")\n        return best_result\n    except:\n        return (n, 0, 0, time.time()-start, False, \"\")\n\ndef a_star_search(U):\n    n = U.shape[0]\n    open_set = []\n    closed_set = set()\n    \n    # Store matrix as tuple for hashing\n    initial_state = tuple(U.flatten())\n    heappush(open_set, (heuristic(U), 0, [], initial_state))\n    \n    while open_set:\n        _, cost, path, state = heappop(open_set)\n        current = np.array(state).reshape(n, n)\n        \n        if np.array_equal(current, np.eye(n)):\n            return path\n            \n        if state in closed_set:\n            continue\n        closed_set.add(state)\n        \n        # Generate CNOTs in order of most promising first\n        for op in prioritized_cnots(current):\n            new_mat = apply_cnot(current, op)\n            new_state = tuple(new_mat.flatten())\n            if new_state not in closed_set:\n                new_cost = cost + 1\n                priority = new_cost + heuristic(new_mat)\n                heappush(open_set, (priority, new_cost, path + [op], new_state))\n    \n    return None\n\ndef heuristic(U):\n    col_weights = U.sum(axis=0)\n    row_weights = U.sum(axis=1)\n    \n    # Column metric favors sparse columns\n    col_metric = sum(np.log2(w + 1) if w > 0 else 0 for w in col_weights)\n    \n    # Row metric favors rows matching target basis vectors\n    row_metric = 0\n    for i in range(U.shape[0]):\n        row = U[i,:]\n        if sum(row) == 1 and row[i] == 1:\n            continue  # already correct\n        row_metric += sum(row)\n    \n    return col_metric + row_metric\n\ndef prioritized_cnots(U):\n    n = U.shape[0]\n    ops = []\n    \n    # First prioritize CNOTs that create basis vectors\n    for j in range(n):\n        col = U[:,j]\n        if sum(col) == 1 and col[j] == 1:\n            continue  # already correct\n            \n        for i in range(n):\n            if i != j and U[i,j] == 1:\n                ops.append((i, j))\n    \n    # Then add remaining possible CNOTs\n    for i in range(n):\n        for j in range(n):\n            if i != j and (i,j) not in ops:\n                ops.append((i,j))\n    \n    return ops\n\ndef apply_cnot(U, op):\n    i, j = op\n    U_new = U.copy()\n    U_new[:, j] ^= U_new[:, i]\n    return U_new\n\ndef calculate_depth(path):\n    if not path:\n        return 0\n    layers = []\n    for (i,j) in path:\n        found_layer = False\n        for layer in layers:\n            if i not in layer and j not in layer:\n                layer.add(i)\n                layer.add(j)\n                found_layer = True\n                break\n        if not found_layer:\n            layers.append({i,j})\n    return len(layers)\n\ndef path_to_string(path):\n    return ' '.join(f'CNOT:{i},{j}' for (i,j) in path)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation timed out after 60 seconds",
        "execution_method": "single_subprocess"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 56,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 56,
    "parent_id": 10,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Improved CNOT circuit synthesis using optimized heuristic search.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 20\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, n, params)\n        if h_val <= 1e-5:\n            break\n            \n        best = None\n        best_dh = None\n        best_B = None\n        \n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, n, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n                \n        if best is None:\n            break\n            \n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        \n        if h_min is None or hB_val < h_min[1]:\n            curr_wait = 0\n            h_min = (h_tuple, hB_val)\n        else:\n            curr_wait += 1\n            \n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            return [], A\n            \n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, n, params):\n    if params['ht']:\n        sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    else:\n        sA = U.sum(axis=0)\n        \n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    \n    if params['hl']:\n        h0 = np.log(sA + 1e-10).sum() / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n        \n    if params['hi']:\n        inv_U = bin_mat_inv(U[:n, :n].T)\n        h_inv = np.log(inv_U.sum(axis=0) + 1e-10).sum() / n\n        h0 = min(h0, h_inv)\n        \n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    \n    inv_top = bin_mat_inv(top.T)\n    prod_inv = inv_top.T @ inv_top\n    rows, cols = np.nonzero(prod_inv)\n    for i, j in zip(rows, cols):\n        if i != j and ('CX', (i, j)) not in opts:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "46.655965",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 55,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 57,
    "parent_id": 7,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\n\ndef search(U):\n    # Input validation\n    if U is None or not isinstance(U, np.ndarray):\n        n = 0\n        gate_count = 0\n        depth = 0\n        proc_time = 0\n        check = False\n        circ = \"\"\n        return n, gate_count, depth, proc_time, check, circ\n    \n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 10\n    }\n    try:\n        sym = sym_cnot(U)\n        return synth_main(sym, params)\n    except:\n        n = U.shape[1] // 2 if U is not None else 0\n        gate_count = 0\n        depth = 0\n        proc_time = 0\n        check = False\n        circ = \"\"\n        return n, gate_count, depth, proc_time, check, circ\n\ndef synth_main(U, params):\n    if U is None:\n        return 0, 0, 0, 0, False, \"\"\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    if op_list is None:\n        return n, 0, 0, time.time()-start, False, \"\"\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    if A is None:\n        return None, None\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    best_h = float('inf')\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        if h_val < best_h:\n            best_h = h_val\n            curr_wait = 0\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    sA = U.sum(axis=0)\n    if params['ht']:\n        sA = np.concatenate([sA, U.sum(axis=1)])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    h_components = []\n    if params['hl']:\n        h_components.append(np.log(sA + 1e-10).sum() / len(sA))\n    if params['hi']:\n        try:\n            inv_U = bin_mat_inv(U[:n,:n].T % 2)\n            h_components.append((inv_U.sum() / n**2))\n        except:\n            h_components.append(1.0)\n    \n    h0 = sum(h_components) / len(h_components) if h_components else 0\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    if U is None:\n        return []\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    col_sums = top.sum(axis=0)\n    for j in np.where(col_sums > 1)[0]:\n        for i in np.where(top[:,j] == 1)[0]:\n            if i != j:\n                opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op): \n    if U is None or op is None:\n        return None\n    n = U.shape[1] // 2\n    V = U.copy()\n    if op[0] == 'CX':\n        i, j = op[1]\n        V[:n,j] ^= V[:n,i]\n        V[n:,i] ^= V[n:,j]\n    return V\n\ndef op_list_layers(op_list):\n    if not op_list:\n        return []\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            conflicts = False\n            for prev_op in current_layer:\n                if (op[1][0] in prev_op[1] or op[1][1] in prev_op[1]):\n                    conflicts = True\n                    break\n            if conflicts:\n                layers.append(current_layer)\n                current_layer = [op]\n            else:\n                current_layer.append(op)\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    if not op_list:\n        return 0\n    return len([op for op in op_list if op[0] == 'CX'])\n\ndef op_list_to_string(op_list, sep=' '):\n    if not op_list:\n        return \"\"\n    return sep.join(f\"{op[0]}{op[1][0]}{op[1][1]}\" for op in op_list)\n\ndef sym_cnot(U):\n    if U is None:\n        return None\n    n = U.shape[1] // 2\n    UC = np.zeros((2*n, 2*n), dtype=int)\n    UC[:n,:n] = U[:n,:n].T % 2\n    UC[n:,n:] = U[:n,:n].T % 2\n    UC[:n,n:] = U[n:,:n].T % 2\n    UC[n:,:n] = U[:n,n:].T % 2\n    return UC\n\ndef bin_mat_inv(A):\n    if A is None:\n        return None\n    n = A.shape[0]\n    A = A.copy()\n    inv = np.eye(n, dtype=int)\n    for col in range(n):\n        pivot = -1\n        for row in range(col, n):\n            if A[row,col] == 1:\n                pivot = row\n                break\n        if pivot == -1:\n            raise ValueError(\"Matrix is not invertible\")\n        if pivot != col:\n            A[[col,pivot]] = A[[pivot,col]]\n            inv[[col,pivot]] = inv[[pivot,col]]\n        for row in range(n):\n            if row != col and A[row,col] == 1:\n                A[row] ^= A[col]\n                inv[row] ^= inv[col]\n    return inv\n\ndef sym_test(U, ops):\n    if U is None or ops is None:\n        return False\n    n = U.shape[1] // 2\n    S = op_list2sym(ops, n)\n    return np.array_equal(U, S)\n\ndef op_list2sym(op_list, n):\n    if op_list is None:\n        return None\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        if op[0] == 'CX':\n            i, j = op[1]\n            U[:n,j] ^= U[:n,i]\n            U[n:,i] ^= U[n:,j]\n    return U\n\ndef mat2SQC(UC):\n    if UC is None:\n        return []\n    n = UC.shape[1] // 2\n    L = UC[:n,:n].T\n    R = UC[:n,n:].T\n    ops = []\n    for j in range(n):\n        for i in range(j+1, n):\n            if L[i,j] == 1:\n                ops.append(('CX', (i, j)))\n    for j in range(n):\n        for i in range(j):\n            if R[i,j] == 1:\n                ops.append(('CX', (i, j)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 57,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 3
    }
  },
  {
    "id": 58,
    "parent_id": 30,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappush, heappop\nfrom collections import deque\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    matrices = [\n        (U, 'original'),\n        (U.T, 'transpose'),\n        (bin_mat_inv(U), 'inverse'),\n        (bin_mat_inv(U).T, 'inverse_transpose')\n    ]\n    \n    best_result = None\n    best_gates = float('inf')\n    \n    for mat, desc in matrices:\n        try:\n            sym = np.zeros((2*n, 2*n), dtype=int)\n            sym[:n, :n] = mat % 2\n            sym[n:, n:] = bin_mat_inv(mat.T) % 2\n            \n            op_list = hybrid_search(sym, n)\n            if not is_identity(apply_operations(sym.copy(), op_list)):\n                continue\n                \n            gate_count = count_entangling(op_list)\n            if gate_count < best_gates:\n                best_gates = gate_count\n                best_result = (n, gate_count, len(op_list_layers(op_list)), \n                              time.time() - start, True, op_list_to_string(op_list))\n                if time.time() - start > 15:\n                    break\n        except:\n            continue\n    \n    if best_result is None:\n        return (n, 0, 0, time.time()-start, False, \"\")\n    return best_result\n\ndef hybrid_search(U, n):\n    # Try both greedy and beam search, return best result\n    greedy_ops = greedy_search(U.copy(), n)\n    beam_ops = beam_search(U.copy(), n)\n    \n    if len(greedy_ops) <= len(beam_ops):\n        return greedy_ops\n    return beam_ops\n\ndef greedy_search(U, n):\n    ops = []\n    current = U.copy()\n    \n    while not is_identity(current):\n        best_move = None\n        best_h = float('inf')\n        \n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    for ctrl, targ in [(i,j), (j,i)]:\n                        new_U = apply_cnot(current, ctrl, targ)\n                        h = advanced_heuristic(new_U, n)\n                        if h < best_h:\n                            best_h = h\n                            best_move = ('CX', (ctrl, targ))\n                            temp_U = new_U\n        \n        if best_move is None:\n            break\n            \n        ops.append(best_move)\n        current = temp_U\n        \n        if len(ops) > 3*n:\n            break\n    \n    return ops\n\ndef beam_search(U, n, beam_width=10, max_depth=3*n):\n    beam = [(advanced_heuristic(U, n), [], U.copy())]\n    \n    for _ in range(max_depth):\n        new_beam = []\n        \n        for _, ops, current in beam:\n            if is_identity(current):\n                return ops\n                \n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        for ctrl, targ in [(i,j), (j,i)]:\n                            new_U = apply_cnot(current, ctrl, targ)\n                            new_ops = ops + [('CX', (ctrl, targ))]\n                            h = advanced_heuristic(new_U, n)\n                            heappush(new_beam, (h, new_ops, new_U))\n                            \n                            if len(new_beam) > beam_width * 10:\n                                new_beam = new_beam[:beam_width]\n        \n        if not new_beam:\n            break\n            \n        beam = new_beam[:beam_width]\n    \n    if beam:\n        return beam[0][1]\n    return []\n\ndef advanced_heuristic(U, n):\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    col_sums_top = top.sum(axis=0)\n    row_sums_top = top.sum(axis=1)\n    col_sums_bottom = bottom.sum(axis=0)\n    row_sums_bottom = bottom.sum(axis=1)\n    \n    h_top = (col_sums_top.sum() + row_sums_top.sum()) / (2*n)\n    h_bottom = (col_sums_bottom.sum() + row_sums_bottom.sum()) / (2*n)\n    \n    log_penalty = sum(np.log2(x + 1) for x in col_sums_top if x > 0)\n    \n    return h_top + h_bottom + log_penalty\n\ndef is_identity(U):\n    n = U.shape[0] // 2\n    return np.array_equal(U[:n, :n], np.eye(n)) and np.array_equal(U[n:, n:], np.eye(n))\n\ndef apply_cnot(U, ctrl, targ):\n    n = U.shape[0] // 2\n    U_new = U.copy()\n    U_new[:, targ] ^= U_new[:, ctrl]\n    U_new[:, n + ctrl] ^= U_new[:, n + targ]\n    return U_new\n\ndef apply_operations(U, op_list):\n    current = U.copy()\n    for typ, (ctrl, targ) in op_list:\n        current = apply_cnot(current, ctrl, targ)\n    return current\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q)\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f'{typ}:{q[0]},{q[1]}' for typ, q in op_list)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Result file not found. Return code: 1, stderr: Traceback (most recent call last):\n  File \"/var/folders/28/81_7stz56pj25dz5bc6t2lh40000gn/T/tmpthj7xwte.py\", line 110, in <module>\n    def beam_search(U, n, beam_width=10, max_depth=3*n):\n                                                     ^\nNameError: name 'n' is not defined. Did you mean: 'np'?\n",
        "execution_method": "single_subprocess"
      }
    },
    "children": 2,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 58,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 3
    }
  },
  {
    "id": 59,
    "parent_id": 32,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,\n        'wMax': 15,\n        'beam_width': 3,\n        'lookahead': 2\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], 0)])\n    \n    for _ in range(params['wMax'] * 2):\n        new_beam = []\n        for state in beam:\n            U, ops, wait = state\n            if np.array_equal(U[:n,:n], np.eye(n, dtype=int)):\n                return ops, U\n            \n            h_val = gl_heuristic_improved(U)\n            candidates = []\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        op = ('CX', (i, j))\n                        B = apply_op(U.copy(), op)\n                        hB = gl_heuristic_improved(B)\n                        candidates.append((hB, B, op))\n            \n            candidates.sort()\n            for hB, B, op in candidates[:params['beam_width']]:\n                new_ops = ops + [op]\n                if hB < h_val:\n                    new_beam.append((B, new_ops, 0))\n                else:\n                    new_beam.append((B, new_ops, wait + 1))\n        \n        if not new_beam:\n            break\n            \n        new_beam.sort(key=lambda x: (gl_heuristic_improved(x[0]), len(x[1])))\n        beam = deque(new_beam[:params['beam_width']])\n    \n    best_state = min(beam, key=lambda x: (gl_heuristic_improved(x[0]), len(x[1])))\n    return best_state[1], best_state[0]\n\ndef gl_heuristic_improved(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_sums = np.sum(top, axis=0)\n    log_col_sums = np.sum(np.log2(col_sums + 1))\n    inv = bin_mat_inv(top.T % 2)\n    inv_sum = np.sum(inv)\n    trans_sum = np.sum(top.T)\n    return min(np.sum(top), log_col_sums, inv_sum, trans_sum)\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    CList = [np.eye(2, dtype=int) for _ in range(n)]\n    ops = []\n    for i, M in enumerate(CList):\n        if not np.array_equal(M, np.eye(2, dtype=int)):\n            ops.append(('S', (i,)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 60,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 60,
    "parent_id": 42,
    "solution": "\nimport numpy as np\nimport time\nimport heapq\nfrom collections import deque\n\ndef search(U):\n    n = U.shape[0]\n    sym = sym_cnot(U)\n    start = time.time()\n    \n    # Initialize search\n    open_set = []\n    closed_set = set()\n    \n    # Use tuple representation for hashability\n    initial_state = (tuple(map(tuple, sym)), ())\n    heapq.heappush(open_set, (0, initial_state))\n    \n    # Search parameters\n    max_depth = 3 * n  # Empirical upper bound\n    max_time = 10  # Seconds\n    best_solution = None\n    best_gates = float('inf')\n    \n    while open_set and time.time() - start < max_time:\n        _, current = heapq.heappop(open_set)\n        mat_tuple, ops = current\n        current_mat = np.array(mat_tuple)\n        \n        if is_identity(current_mat):\n            best_solution = ops\n            break\n        \n        if len(ops) >= best_gates:\n            continue\n            \n        if len(ops) > max_depth:\n            continue\n            \n        # Generate neighbors\n        for op in generate_ops(n):\n            new_mat = apply_op(current_mat.copy(), op)\n            new_mat_tuple = tuple(map(tuple, new_mat))\n            new_ops = ops + (op,)\n            \n            if new_mat_tuple in closed_set:\n                continue\n                \n            h = heuristic(new_mat)\n            g = len(new_ops)\n            f = g + h\n            \n            heapq.heappush(open_set, (f, (new_mat_tuple, new_ops)))\n            closed_set.add(new_mat_tuple)\n    \n    if best_solution is None:\n        return n, 0, 0, time.time()-start, False, \"\"\n    \n    # Process results\n    full_ops = mat2SQC(sym) + list(best_solution)\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(sym, full_ops)\n    \n    return n, gate_count, depth, proc_time, check, circ\n\ndef heuristic(mat):\n    n = mat.shape[0] // 2\n    top = mat[:n, :n]\n    bot = mat[n:, n:]\n    \n    # Column and row sums\n    col_sums_top = top.sum(axis=0)\n    row_sums_top = top.sum(axis=1)\n    col_sums_bot = bot.sum(axis=0)\n    row_sums_bot = bot.sum(axis=1)\n    \n    # Distance metrics\n    h_col_top = np.sum(np.log(col_sums_top + (col_sums_top == 0)))\n    h_row_top = np.sum(np.log(row_sums_top + (row_sums_top == 0)))\n    h_col_bot = np.sum(np.log(col_sums_bot + (col_sums_bot == 0)))\n    h_row_bot = np.sum(np.log(row_sums_bot + (row_sums_bot == 0)))\n    \n    # Consider all variants (original, inverse, transpose)\n    variants = [\n        (h_col_top + h_row_top + h_col_bot + h_row_bot),\n        heuristic(bin_mat_inv(top)) + heuristic(bin_mat_inv(bot)),\n        heuristic(top.T) + heuristic(bot.T)),\n        heuristic(bin_mat_inv(top.T)) + heuristic(bin_mat_inv(bot.T)))\n    ]\n    \n    return min(variants) / (4 * n)\n\ndef is_identity(mat):\n    n = mat.shape[0] // 2\n    return np.array_equal(mat[:n, :n], np.eye(n)) and np.array_equal(mat[n:, n:], np.eye(n))\n\ndef generate_ops(n):\n    ops = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                ops.append(('CX', (i, j)))\n    return ops\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[0] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_test(U, ops):\n    n = U.shape[0] // 2\n    synthesized = op_list2sym(ops, n)\n    return np.array_equal(U, synthesized)\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    ops = []\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Result file not found. Return code: 1, stderr:   File \"/var/folders/28/81_7stz56pj25dz5bc6t2lh40000gn/T/tmp828ojnc2.py\", line 117\n    heuristic(top.T) + heuristic(bot.T)),\n                                       ^\nSyntaxError: closing parenthesis ')' does not match opening parenthesis '[' on line 114\n",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 61,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 61,
    "parent_id": 16,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    if U is None:\n        n = 0\n        return n, 0, 0, 0.0, False, \"\"\n    \n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,\n        'wMax': 8\n    }\n    \n    try:\n        sym = sym_cnot(U)\n        if sym is None:\n            n = U.shape[1] // 2 if hasattr(U, 'shape') else 0\n            return n, 0, 0, 0.0, False, \"\"\n        return synth_main(sym, params)\n    except:\n        n = U.shape[1] // 2 if hasattr(U, 'shape') else 0\n        return n, 0, 0, 0.0, False, \"\"\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5 or len(op_list) > 3*n:\n            break\n            \n        candidates = []\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            candidates.append((key, hB_val, op, B))\n        \n        if not candidates:\n            break\n            \n        candidates.sort()\n        best_key, best_h_val, best_op, best_B = candidates[0]\n        \n        if best_h_val >= h_val and curr_wait > params['wMax']//2:\n            break\n            \n        U = best_B\n        op_list.append(best_op)\n        \n        if best_h_val < best_h:\n            best_h = best_h_val\n            curr_wait = 0\n        else:\n            curr_wait += 1\n            \n        if curr_wait > params['wMax']:\n            break\n\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    \n    matrices = [top]\n    if params['ht']:\n        matrices.append(top.T)\n    if params['hi']:\n        matrices.append(bin_mat_inv(top))\n    \n    col_heuristics = []\n    for M in matrices:\n        col_sums = M.sum(axis=0)\n        col_nonzero = (M != 0).sum(axis=0)\n        col_heuristic = np.log(col_sums + 1e-6) - 0.5 * np.log(col_nonzero + 1e-6)\n        col_heuristics.append(col_heuristic)\n    \n    h_col = np.mean(col_heuristics)\n    h_sum = U.sum() / (2 * n * n) - 1\n    h_total = params['hr'] * (0.7 * h_col + 0.3 * h_sum)\n    \n    sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    return h_total, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    options = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                options.append(('cnot', i, j))\n                options.append(('cnot', j, i))\n    return options\n\ndef apply_op(U, op):\n    op_type, i, j = op\n    n = U.shape[1] // 2\n    if op_type == 'cnot':\n        F = np.eye(2*n)\n        F[i,j] = 1\n        return F @ U\n    return U\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            can_add = True\n            for existing_op in current_layer:\n                if (op[1] == existing_op[1] or op[1] == existing_op[2] or \n                    op[2] == existing_op[1] or op[2] == existing_op[2]):\n                    can_add = False\n                    break\n            if can_add:\n                current_layer.append(op)\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'cnot'])\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join([f\"{op[0]}_{op[1]}_{op[2]}\" for op in op_list])\n\ndef sym_cnot(U):\n    if U is None:\n        return None\n    try:\n        n = U.shape[1] // 2\n        S = np.zeros((2*n, 2*n), dtype=int)\n        S[:n, :n] = U[:n, :n]\n        S[n:, n:] = U[n:, n:]\n        return S\n    except:\n        return None\n\ndef bin_mat_inv(A):\n    try:\n        return np.linalg.inv(A).astype(int) % 2\n    except:\n        return A\n\ndef sym_test(U, ops):\n    try:\n        n = U.shape[1] // 2\n        reconstructed = op_list2sym(ops, n)\n        return np.array_equal(U, reconstructed)\n    except:\n        return False\n\ndef op_list2sym(op_list, n):\n    mat = np.eye(2*n)\n    for op in op_list:\n        if op[0] == 'cnot':\n            i, j = op[1], op[2]\n            mat[i,j] = 1\n    return mat\n\ndef mat2SQC(UC):\n    n = UC.shape[1] // 2\n    ops = []\n    for i in range(n):\n        if UC[i,i] == 0:\n            for j in range(n):\n                if UC[j,i] == 1:\n                    ops.append(('cnot', j, i))\n                    break\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 2,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 62,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 3
    }
  },
  {
    "id": 62,
    "parent_id": 39,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 50\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = float('inf')\n    curr_wait = 0\n    while True:\n        if np.array_equal(U[:n,:n], np.eye(n, dtype=int)):\n            break\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U, params):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if hB_val < h_min:\n            curr_wait = 0\n            h_min = hB_val\n        else:\n            curr_wait += 1\n            if params['wMax'] > 0 and curr_wait > params['wMax']:\n                break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    \n    # Combined row+column heuristic\n    h_comb = sum(np.log2(cs + rs + 1) for cs, rs in zip(col_sums, row_sums))\n    \n    if params['hi']:\n        inv_top = bin_mat_inv(top.T).T\n        h_inv = sum(np.log2(cs + rs + 1) for cs, rs in zip(inv_top.sum(axis=0), inv_top.sum(axis=1)))\n        h_comb = min(h_comb, h_inv)\n    \n    if params['ht']:\n        trans_top = top.T\n        h_trans = sum(np.log2(cs + rs + 1) for cs, rs in zip(trans_top.sum(axis=0), trans_top.sum(axis=1)))\n        h_comb = min(h_comb, h_trans)\n    \n    w = tuple(sorted(int(x) for x in col_sums))\n    return params['hr'] * h_comb, w\n\ndef gl_options(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    opts = []\n    \n    # Consider all possible CNOTs that reduce the heuristic\n    for i in range(n):\n        for j in range(n):\n            if i != j and top[i,j]:\n                opts.append(('CX', (i,j)))\n    \n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 59,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 63,
    "parent_id": 32,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 10,\n        'beam_width': 5,\n        'lookahead': 1\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], 0)])\n    \n    for _ in range(params['wMax']):\n        new_beam = []\n        for state in beam:\n            U, ops, wait = state\n            if np.array_equal(U[:n,:n], np.eye(n, dtype=int)):\n                return ops, U\n            \n            h_val = gl_heuristic(U)\n            candidates = []\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        op = ('CX', (i, j))\n                        B = apply_op(U.copy(), op)\n                        hB = gl_heuristic(B)\n                        candidates.append((hB, B, op))\n            \n            candidates.sort()\n            for hB, B, op in candidates[:params['beam_width']]:\n                new_ops = ops + [op]\n                if hB < h_val:\n                    new_beam.append((B, new_ops, 0))\n                else:\n                    if wait < params['hr']:\n                        new_beam.append((B, new_ops, wait + 1))\n        \n        if not new_beam:\n            break\n            \n        new_beam.sort(key=lambda x: (gl_heuristic(x[0]), len(x[1])))\n        beam = deque(new_beam[:params['beam_width']])\n    \n    best_state = min(beam, key=lambda x: (gl_heuristic(x[0]), len(x[1])))\n    return best_state[1], best_state[0]\n\ndef gl_heuristic(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_weights = np.sum(top, axis=0)\n    row_weights = np.sum(top, axis=1)\n    return (np.sum(col_weights * (col_weights - 1)) + \n            np.sum(row_weights * (row_weights - 1)))\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    CList = [np.eye(2, dtype=int) for _ in range(n)]\n    ops = []\n    for i, M in enumerate(CList):\n        if not np.array_equal(M, np.eye(2, dtype=int)):\n            ops.append(('S', (i,)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 63,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 64,
    "parent_id": 3,
    "solution": "\nimport numpy as np\nimport time\nimport heapq\nfrom collections import defaultdict\n\ndef search(U):\n    n = U.shape[0]\n    start_time = time.time()\n    \n    # Convert to symplectic representation\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv_UT = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv_UT % 2\n    \n    # A* search setup\n    open_set = []\n    heapq.heappush(open_set, (0, 0, S.copy(), []))\n    visited = set()\n    \n    best_state = None\n    best_heuristic = float('inf')\n    \n    max_gates = 3 * n  # Empirical upper bound\n    timeout = 10  # seconds\n    \n    while open_set and time.time() - start_time < timeout:\n        _, cost, current, path = heapq.heappop(open_set)\n        \n        # Check if we've reached the identity\n        if np.array_equal(current, np.eye(2*n, dtype=int)):\n            proc_time = time.time() - start_time\n            gate_count = len(path)\n            depth = calculate_depth(path)\n            circ = op_list_to_string(path)\n            return n, gate_count, depth, proc_time, True, circ\n        \n        # Generate neighbors\n        for op in generate_ops(n):\n            new_matrix = apply_op(current.copy(), op)\n            new_path = path + [op]\n            \n            # Skip if already visited\n            mat_hash = hash_matrix(new_matrix)\n            if mat_hash in visited:\n                continue\n            visited.add(mat_hash)\n            \n            # Calculate heuristic and cost\n            h = heuristic(new_matrix)\n            new_cost = cost + 1\n            \n            # Update best found solution\n            if h < best_heuristic:\n                best_heuristic = h\n                best_state = (new_matrix, new_path)\n            \n            # Add to open set\n            priority = new_cost + h\n            heapq.heappush(open_set, (priority, new_cost, new_matrix, new_path))\n    \n    # Return best found solution if timeout\n    if best_state:\n        proc_time = time.time() - start_time\n        gate_count = len(best_state[1])\n        depth = calculate_depth(best_state[1])\n        circ = op_list_to_string(best_state[1])\n        return n, gate_count, depth, proc_time, True, circ\n    \n    # Fallback if no solution found\n    proc_time = time.time() - start_time\n    return n, 0, 0, proc_time, False, \"\"\n\ndef heuristic(S):\n    n = S.shape[0] // 2\n    top = S[:n, :n]\n    bot = S[n:, n:]\n    \n    # Column and row sums\n    col_sums_top = top.sum(axis=0)\n    row_sums_top = top.sum(axis=1)\n    col_sums_bot = bot.sum(axis=0)\n    row_sums_bot = bot.sum(axis=1)\n    \n    # Combined heuristic\n    h_top = sum(np.log(s + 1) for s in col_sums_top) + sum(np.log(s + 1) for s in row_sums_top)\n    h_bot = sum(np.log(s + 1) for s in col_sums_bot) + sum(np.log(s + 1) for s in row_sums_bot)\n    \n    return (h_top + h_bot) / (4 * n)\n\ndef generate_ops(n):\n    ops = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                ops.append(('CX', (i, j)))\n    return ops\n\ndef apply_op(S, op):\n    typ, q = op\n    if typ == 'CX':\n        i, j = q\n        n = S.shape[0] // 2\n        S[:, j] ^= S[:, i]\n        S[:, n + i] ^= S[:, n + j]\n    return S\n\ndef calculate_depth(op_list):\n    layers = []\n    for op in op_list:\n        qubits = set(op[1])\n        placed = False\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                placed = True\n                break\n        if not placed:\n            layers.append(qubits)\n    return len(layers)\n\ndef op_list_to_string(op_list):\n    return ' '.join(f'{op[0]}:{op[1][0]},{op[1][1]}' for op in op_list)\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef hash_matrix(S):\n    return hash(tuple(S.ravel()))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 65,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 3
    }
  },
  {
    "id": 65,
    "parent_id": 42,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,\n        'wMax': 15,\n        'beam_width': 3,\n        'lookahead': 2\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], 0)])\n    \n    for _ in range(params['wMax'] * 2):\n        new_beam = []\n        for state in beam:\n            U, ops, wait = state\n            h_val = gl_heuristic_enhanced(U, params)\n            if h_val <= 0.1:\n                return ops, U\n            \n            candidates = []\n            for op in enhanced_gl_options(U):\n                B = apply_op(U.copy(), op)\n                hB = gl_heuristic_enhanced(B, params)\n                candidates.append((hB, B, op))\n            \n            candidates.sort()\n            for hB, B, op in candidates[:params['beam_width']]:\n                new_ops = ops + [op]\n                if hB < h_val:\n                    new_beam.append((B, new_ops, 0))\n                else:\n                    new_beam.append((B, new_ops, wait + 1))\n        \n        if not new_beam:\n            break\n            \n        new_beam.sort(key=lambda x: (gl_heuristic_enhanced(x[0], params), len(x[1])))\n        beam = deque(new_beam[:params['beam_width']])\n    \n    best_state = min(beam, key=lambda x: (gl_heuristic_enhanced(x[0], params), len(x[1])))\n    return best_state[1], best_state[0]\n\ndef gl_heuristic_enhanced(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    \n    mats = [top]\n    if params['hi']:\n        mats.append(bin_mat_inv(top))\n    if params['ht']:\n        mats.append(top.T)\n    if params['hv']:\n        mats.append(bin_mat_inv(top.T))\n    \n    min_h = float('inf')\n    for mat in mats:\n        col_sums = mat.sum(axis=0)\n        row_sums = mat.sum(axis=1)\n        \n        h_col = np.sum(np.log(col_sums + (col_sums == 0)))\n        h_row = np.sum(np.log(row_sums + (row_sums == 0)))\n        \n        h = float((h_col + h_row) / (2 * n))\n        if h < min_h:\n            min_h = h\n    \n    return min_h\n\ndef enhanced_gl_options(U):\n    n = U.shape[1] // 2\n    options = []\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                options.append(('CX', (i, j)))\n    \n    return options\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    synthesized = op_list2sym(ops, n)\n    return np.array_equal(U, synthesized)\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 64,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 3
    }
  },
  {
    "id": 66,
    "parent_id": 17,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    n = U.shape[0]\n    if n != U.shape[1]:\n        raise ValueError(\"Input matrix must be square\")\n    \n    start_time = time.time()\n    circuit = []\n    current_matrix = U.copy()\n    \n    # Phase 1: Row reduction\n    for target_col in range(n):\n        # Find pivot row\n        pivot = -1\n        for row in range(target_col, n):\n            if current_matrix[row, target_col] == 1:\n                pivot = row\n                break\n        \n        if pivot == -1:\n            continue  # Column already zeroed out\n            \n        # Swap rows if needed\n        if pivot != target_col:\n            current_matrix[[target_col, pivot]] = current_matrix[[pivot, target_col]]\n            circuit.append(('SWAP', (target_col, pivot)))\n        \n        # Eliminate other rows\n        for row in range(n):\n            if row != target_col and current_matrix[row, target_col] == 1:\n                current_matrix[row] ^= current_matrix[target_col]\n                circuit.append(('CX', (target_col, row)))\n    \n    # Phase 2: Column reduction\n    for target_row in range(n):\n        # Find pivot column\n        pivot = -1\n        for col in range(target_row, n):\n            if current_matrix[target_row, col] == 1:\n                pivot = col\n                break\n        \n        if pivot == -1:\n            continue\n            \n        # Swap columns if needed\n        if pivot != target_row:\n            current_matrix[:, [target_row, pivot]] = current_matrix[:, [pivot, target_row]]\n            circuit.append(('SWAP', (target_row, pivot)))\n        \n        # Eliminate other columns\n        for col in range(n):\n            if col != target_row and current_matrix[target_row, col] == 1:\n                current_matrix[:, col] ^= current_matrix[:, target_row]\n                circuit.append(('CX', (col, target_row)))\n    \n    # Verify result is identity\n    check = np.array_equal(current_matrix, np.eye(n, dtype=int))\n    \n    # Convert to standard format\n    gate_count = len(circuit)\n    depth = len(op_list_layers(circuit))\n    proc_time = time.time() - start_time\n    circ_str = op_list_to_string(circuit)\n    \n    return n, gate_count, depth, proc_time, check, circ_str\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        placed = False\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                placed = True\n                break\n        if not placed:\n            layers.append(set(qubits))\n    return layers\n\ndef op_list_to_string(op_list):\n    parts = []\n    for typ, q in op_list:\n        if typ == 'CX':\n            parts.append(f'CNOT {q[0]} {q[1]}')\n        elif typ == 'SWAP':\n            parts.append(f'SWAP {q[0]} {q[1]}')\n    return '; '.join(parts)\n",
    "evaluation": {
      "fitness": -51.7,
      "additional_data": {
        "score": "-51.700000",
        "total_compute_time": "0.006251",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 69,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 67,
    "parent_id": 24,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 1.8,\n        'wMax': 5\n    }\n    n = U.shape[0]\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    \n    if np.array_equal(U, np.eye(2*n, dtype=int)):\n        return op_list, U\n        \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        options = gl_options(U)\n        options.sort(key=lambda op: gl_heuristic(apply_op(U, op), params)[0])\n        for op in options[:min(10, len(options))]:\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or hB_val < h_min[1]:\n            curr_wait = 0\n            h_min = (h_tuple, hB_val)\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    sA = U.sum(axis=0)\n    if params['ht']:\n        sA = np.concatenate([sA, U.sum(axis=1)])\n    if params['hi']:\n        inv_U = bin_mat_inv(U[:n,:n].T % 2)\n        sA_inv = inv_U.sum(axis=0)\n        if params['ht']:\n            sA_inv = np.concatenate([sA_inv, inv_U.sum(axis=1)])\n        sA = np.minimum(sA, sA_inv)\n    \n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    if params['hl']:\n        h0 = np.log(np.maximum(sA, 1)).sum() / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    synthesized = op_list2sym(ops, n)\n    return np.array_equal(U, synthesized)\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: operands could not be broadcast together with shapes (64,) (32,) ",
        "execution_method": "single_subprocess"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 66,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 68,
    "parent_id": 44,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappush, heappop\nimport math\nfrom functools import lru_cache\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    matrices = [\n        (U, 'original'),\n        (U.T, 'transpose'),\n        (bin_mat_inv(U), 'inverse'),\n        (bin_mat_inv(U).T, 'inverse_transpose')\n    ]\n    \n    best_result = None\n    best_gates = float('inf')\n    \n    for mat, desc in matrices:\n        if time.time() - start > 15:\n            break\n            \n        try:\n            sym = np.zeros((2*n, 2*n), dtype=int)\n            sym[:n, :n] = mat % 2\n            sym[n:, n:] = bin_mat_inv(mat.T) % 2\n            \n            op_list, UC = astar_search(sym, time_limit=15-(time.time()-start))\n            if not is_identity(UC):\n                continue\n                \n            gate_count = count_entangling(op_list)\n            if gate_count < best_gates:\n                best_gates = gate_count\n                best_result = (n, gate_count, len(op_list_layers(op_list)), \n                              time.time() - start, True, op_list_to_string(op_list))\n        except:\n            continue\n    \n    if best_result is None:\n        return (n, 0, 0, time.time()-start, False, \"\")\n    return best_result\n\ndef astar_search(U, time_limit=15):\n    n = U.shape[0] // 2\n    open_set = []\n    heappush(open_set, (heuristic(U), 0, [], U.copy()))\n    closed_set = set()\n    \n    start_time = time.time()\n    \n    while open_set and time.time() - start_time < time_limit:\n        _, cost, ops, current = heappop(open_set)\n        \n        if is_identity(current):\n            return ops, current\n            \n        current_hash = matrix_hash(current)\n        if current_hash in closed_set:\n            continue\n        closed_set.add(current_hash)\n        \n        # Generate neighbors in order of likely usefulness\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    for ctrl, targ in [(i,j), (j,i)]:\n                        new_U = apply_cnot(current, ctrl, targ)\n                        new_ops = ops + [('CX', (ctrl, targ))]\n                        new_cost = cost + 1\n                        h = heuristic(new_U)\n                        priority = new_cost + h\n                        heappush(open_set, (priority, new_cost, new_ops, new_U))\n    \n    return [], U\n\n@lru_cache(maxsize=None)\ndef heuristic(U_tuple):\n    U = np.array(U_tuple)\n    n = U.shape[0] // 2\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    # Column metrics\n    col_sums_top = top.sum(axis=0)\n    col_sums_bottom = bottom.sum(axis=0)\n    col_metric = sum(math.log2(x + 1) for x in col_sums_top) + sum(col_sums_bottom)\n    \n    # Row metrics\n    row_sums_top = top.sum(axis=1)\n    row_sums_bottom = bottom.sum(axis=1)\n    row_metric = sum(math.log2(x + 1) for x in row_sums_top) + sum(row_sums_bottom)\n    \n    # Diagonal metrics\n    diag_top = np.diag(top)\n    diag_bottom = np.diag(bottom)\n    diag_metric = (n - sum(diag_top)) + (n - sum(diag_bottom))\n    \n    # Combined heuristic\n    return (col_metric + row_metric + diag_metric)\n\ndef matrix_hash(U):\n    return hash(U.tobytes())\n\ndef is_identity(U):\n    n = U.shape[0] // 2\n    return np.array_equal(U[:n, :n], np.eye(n)) and np.array_equal(U[n:, n:], np.eye(n))\n\ndef apply_cnot(U, ctrl, targ):\n    n = U.shape[0] // 2\n    U_new = U.copy()\n    U_new[:, targ] ^= U_new[:, ctrl]\n    U_new[:, n + ctrl] ^= U_new[:, n + targ]\n    return U_new\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q)\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f'{typ}:{q[0]},{q[1]}' for typ, q in op_list)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 68,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 69,
    "parent_id": 7,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\n\ndef is_identity(U, n):\n    n2 = 2 * n\n    total_ones = U.sum()\n    trace = np.trace(U)\n    return total_ones == n2 and trace == n2\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': False,  # Disabled inverse component\n        'ht': False,  # Disabled row sums in tuple\n        'hl': False,  # Disabled log component\n        'hr': 1,     # Reduced scaling factor\n        'wMax': 8    # Maintained wait limit\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    best_h = float('inf')\n    op_count = 0\n    max_ops = 2 * n * n  # Prevent infinite loops\n    \n    while op_count < max_ops:\n        if is_identity(U, n):\n            break\n            \n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val < best_h:\n            best_h = h_val\n            curr_wait = 0\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n                \n        if best is None:\n            break\n            \n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        op_count += 1\n        \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    col_sums = U.sum(axis=0)\n    total_ones = U.sum()\n    w = tuple(sorted(col_sums))\n    h0 = total_ones\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    col_sums = top.sum(axis=0)\n    for j in np.where(col_sums > 1)[0]:\n        for i in np.where(top[:,j] == 1)[0]:\n            if i != j:\n                opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op):\n    op_type, (i, j) = op\n    n = U.shape[1] // 2\n    if op_type == 'CX':\n        F = np.eye(2*n, dtype=int)\n        F[i, j] = 1\n        F[n+j, n+i] = 1\n        return F @ U % 2\n    return U\n\ndef op_list_layers(op_list):\n    layers = []\n    for op in op_list:\n        if not layers:\n            layers.append([op])\n            continue\n        added = False\n        for layer in layers:\n            if not any(qubit in [op[1][0], op[1][1]] for gate in layer \n                       for qubit in [gate[1][0], gate[1][1]]):\n                layer.append(op)\n                added = True\n                break\n        if not added:\n            layers.append([op])\n    return layers\n\ndef count_entangling(op_list):\n    count = 0\n    for op in op_list:\n        if op[0] in ['CX', 'CZ', 'SWAP']:\n            count += 1\n    return count\n\ndef op_list_to_string(op_list, sep=' '):\n    s = []\n    for op in op_list:\n        if op[0] == 'CX':\n            s.append(f\"CNOT({op[1][0]},{op[1][1]})\")\n    return sep.join(s)\n\ndef sym_cnot(U):\n    return U\n\ndef bin_mat_inv(A):\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    A_aug = np.hstack((A, I))\n    for j in range(n):\n        pivot = -1\n        for i in range(j, n):\n            if A_aug[i, j] == 1:\n                pivot = i\n                break\n        if pivot == -1:\n            return None\n        if pivot != j:\n            A_aug[[j, pivot]] = A_aug[[pivot, j]]\n        for i in range(n):\n            if i != j and A_aug[i, j] == 1:\n                A_aug[i] = (A_aug[i] + A_aug[j]) % 2\n    return A_aug[:, n:]\n\ndef sym_r2(U):\n    return U\n\ndef perm_mat_to_ix(P):\n    return np.where(P == 1)[1]\n\ndef ix_rev(ix):\n    return ix\n\ndef Fmat(U, i, j):\n    n = U.shape[1] // 2\n    F = np.eye(2*n, dtype=int)\n    F[i, j] = 1\n    F[n+j, n+i] = 1\n    return F\n\ndef SQC2str(A):\n    return str(A)\n\ndef CList2opList(CList):\n    op_list = []\n    for C in CList:\n        op_list.append(('S', C[0]))\n        op_list.append(('C', C[1]))\n    return op_list\n\ndef mat2SQC(UC):\n    return []\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        if op[0] == 'CX':\n            i, j = op[1]\n            F = np.eye(2*n, dtype=int)\n            F[i, j] = 1\n            F[n+j, n+i] = 1\n            U = F @ U % 2\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    V = op_list2sym(ops, n)\n    return np.array_equal(U, V)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-reasoner",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 54,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 4
    }
  },
  {
    "id": 70,
    "parent_id": 28,
    "solution": "\nimport numpy as np\nimport time\nimport math\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',  # Now supports 'greedy', 'beam', or 'hybrid'\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,  # More aggressive heuristic weighting\n        'wMax': 12,\n        'beam_width': 3,  # For beam search\n        'restart_threshold': 5,  # Local minima detection\n        'max_restarts': 2\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    \n    # Try multiple methods with fallback\n    methods = [params['method']]\n    if params['method'] != 'greedy':\n        methods.append('greedy')\n        \n    best_result = None\n    for method in methods:\n        current_params = params.copy()\n        current_params['method'] = method\n        op_list, UC = csynth_optimized(U, current_params)\n        if op_list:\n            if best_result is None or len(op_list) < len(best_result[0]):\n                best_result = (op_list, UC)\n    \n    if best_result is None:\n        return n, 0, 0, time.time()-start, False, \"\"\n    \n    op_list, UC = best_result\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_optimized(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    restarts = 0\n    stagnation = 0\n    \n    while True:\n        h_val, h_tuple = enhanced_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        if h_val < best_h - 1e-5:\n            best_h = h_val\n            stagnation = 0\n        else:\n            stagnation += 1\n            \n        if stagnation > params['wMax']:\n            if restarts < params['max_restarts']:\n                U = A.copy()\n                op_list = []\n                best_h = float('inf')\n                stagnation = 0\n                restarts += 1\n                continue\n            return [], A\n            \n        if params['method'] == 'greedy':\n            best_op, best_U = greedy_step(U, params)\n        elif params['method'] == 'beam':\n            best_op, best_U = beam_step(U, params)\n        else:  # hybrid\n            if len(op_list) < n*2:\n                best_op, best_U = greedy_step(U, params)\n            else:\n                best_op, best_U = beam_step(U, params)\n                \n        if best_op is None:\n            return [], A\n            \n        U = best_U\n        op_list.append(best_op)\n        \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef enhanced_heuristic(U, params):\n    n = U.shape[1] // 2\n    GL = U[:n, :n]\n    GR = U[:n, n:]\n    \n    # Column/row sums\n    col_sums = U.sum(axis=0)\n    row_sums = U.sum(axis=1)\n    sA = np.concatenate([col_sums, row_sums])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    # Log sum heuristic\n    log_sum = sum(math.log(x) if x > 0 else 0 for x in sA)\n    h0 = log_sum / len(sA)\n    \n    # Matrix norm heuristic\n    h1 = np.linalg.norm(GL, 'fro') + np.linalg.norm(GR, 'fro')\n    \n    # Column completion heuristic\n    complete_cols = sum(1 for x in col_sums[:n] if x == 1)\n    h2 = (n - complete_cols) / n\n    \n    # Combined heuristic\n    combined = params['hr'] * (0.5*h0 + 0.3*h1 + 0.2*h2)\n    \n    # Consider inverse/transpose if enabled\n    if params['hi'] or params['ht']:\n        min_h = combined\n        if params['hi']:\n            inv_h, _ = enhanced_heuristic(bin_mat_inv(U.T), params)\n            min_h = min(min_h, inv_h)\n        if params['ht']:\n            trans_h, _ = enhanced_heuristic(U.T, params)\n            min_h = min(min_h, trans_h)\n        combined = min_h\n    \n    return combined, w\n\ndef greedy_step(U, params):\n    best_op = None\n    best_U = None\n    best_h = float('inf')\n    \n    for op in extended_gl_options(U):\n        B = apply_op(U, op)\n        hB_val, _ = enhanced_heuristic(B, params)\n        if hB_val < best_h:\n            best_h = hB_val\n            best_op = op\n            best_U = B\n    \n    return best_op, best_U\n\ndef beam_step(U, params):\n    beam = deque()\n    beam.append((U, [], 0))\n    \n    for _ in range(params['beam_width']):\n        if not beam:\n            break\n            \n        current_U, current_ops, current_h = beam.popleft()\n        \n        for op in extended_gl_options(current_U):\n            B = apply_op(current_U, op)\n            hB_val, _ = enhanced_heuristic(B, params)\n            new_ops = current_ops + [op]\n            beam.append((B, new_ops, hB_val))\n        \n        beam = deque(sorted(beam, key=lambda x: x[2])[:params['beam_width']])\n    \n    if beam:\n        best_U, best_ops, _ = beam[0]\n        return best_ops[0], best_U\n    return None, None\n\ndef extended_gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n            opts.append(('CX', (j, i)))  # Also consider reverse CNOT\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: maximum recursion depth exceeded",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 67,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 71,
    "parent_id": 58,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappush, heappop\nfrom collections import deque\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    matrices = [\n        (U, 'original'),\n        (U.T, 'transpose'),\n        (bin_mat_inv(U), 'inverse'),\n        (bin_mat_inv(U).T, 'inverse_transpose')\n    ]\n    \n    best_result = None\n    best_gates = float('inf')\n    \n    for mat, desc in matrices:\n        try:\n            sym = np.zeros((2*n, 2*n), dtype=int)\n            sym[:n, :n] = mat % 2\n            sym[n:, n:] = bin_mat_inv(mat.T) % 2\n            \n            op_list = hybrid_search(sym, n)\n            if not is_identity(apply_operations(sym.copy(), op_list)):\n                continue\n                \n            gate_count = count_entangling(op_list)\n            if gate_count < best_gates:\n                best_gates = gate_count\n                best_result = (n, gate_count, len(op_list_layers(op_list)), \n                              time.time() - start, True, op_list_to_string(op_list))\n                if time.time() - start > 15:\n                    break\n        except:\n            continue\n    \n    if best_result is None:\n        return (n, 0, 0, time.time()-start, False, \"\")\n    return best_result\n\ndef hybrid_search(U, n):\n    greedy_ops = greedy_search(U.copy(), n)\n    beam_ops = beam_search(U.copy(), n, beam_width=5)\n    \n    if len(greedy_ops) <= len(beam_ops):\n        return greedy_ops\n    return beam_ops\n\ndef greedy_search(U, n):\n    ops = []\n    current = U.copy()\n    \n    while not is_identity(current):\n        best_move = None\n        best_h = float('inf')\n        \n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    for ctrl, targ in [(i,j), (j,i)]:\n                        new_U = apply_cnot(current, ctrl, targ)\n                        h = advanced_heuristic(new_U, n)\n                        if h < best_h:\n                            best_h = h\n                            best_move = ('CX', (ctrl, targ))\n                            temp_U = new_U\n        \n        if best_move is None:\n            break\n            \n        ops.append(best_move)\n        current = temp_U\n        \n        if len(ops) > 3*n:\n            break\n    \n    return ops\n\ndef beam_search(U, n, beam_width=5, max_depth=None):\n    if max_depth is None:\n        max_depth = 3*n\n    beam = [(advanced_heuristic(U, n), [], U.copy())]\n    \n    for _ in range(max_depth):\n        new_beam = []\n        \n        for _, ops, current in beam:\n            if is_identity(current):\n                return ops\n                \n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        for ctrl, targ in [(i,j), (j,i)]:\n                            new_U = apply_cnot(current, ctrl, targ)\n                            new_ops = ops + [('CX', (ctrl, targ))]\n                            h = advanced_heuristic(new_U, n)\n                            heappush(new_beam, (h, new_ops, new_U))\n                            \n                            if len(new_beam) > beam_width * 10:\n                                new_beam = new_beam[:beam_width]\n        \n        if not new_beam:\n            break\n            \n        beam = new_beam[:beam_width]\n    \n    if beam:\n        return beam[0][1]\n    return []\n\ndef advanced_heuristic(U, n):\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    col_sums_top = top.sum(axis=0)\n    row_sums_top = top.sum(axis=1)\n    col_sums_bottom = bottom.sum(axis=0)\n    row_sums_bottom = bottom.sum(axis=1)\n    \n    h_top = col_sums_top.sum() + row_sums_top.sum()\n    h_bottom = col_sums_bottom.sum() + row_sums_bottom.sum()\n    \n    log_penalty = sum(np.log2(x + 1) for x in col_sums_top if x > 0)\n    \n    return h_top + h_bottom + log_penalty\n\ndef is_identity(U):\n    n = U.shape[0] // 2\n    return np.array_equal(U[:n, :n], np.eye(n)) and np.array_equal(U[n:, n:], np.eye(n))\n\ndef apply_cnot(U, ctrl, targ):\n    n = U.shape[0] // 2\n    U_new = U.copy()\n    U_new[:, targ] ^= U_new[:, ctrl]\n    U_new[:, n + ctrl] ^= U_new[:, n + targ]\n    return U_new\n\ndef apply_operations(U, op_list):\n    current = U.copy()\n    for typ, (ctrl, targ) in op_list:\n        current = apply_cnot(current, ctrl, targ)\n    return current\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q)\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f'{typ}:{q[0]},{q[1]}' for typ, q in op_list)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 72,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 72,
    "parent_id": 61,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    if U is None or not hasattr(U, 'shape'):\n        n = 0\n        return n, 0, 0, 0.0, False, \"\"\n    \n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 5\n    }\n    \n    try:\n        n = U.shape[1] // 2\n        if not isinstance(U, np.ndarray) or U.shape != (2*n, 2*n):\n            return n, 0, 0, 0.0, False, \"\"\n        \n        start = time.time()\n        op_list, UC = csynth_greedy(U, params)\n        sqc_ops = mat2SQC(UC)\n        full_ops = sqc_ops + op_list\n        depth = len(op_list_layers(full_ops))\n        gate_count = count_entangling(full_ops)\n        proc_time = time.time() - start\n        circ = op_list_to_string(full_ops)\n        check = sym_test(U, full_ops)\n        return n, gate_count, depth, proc_time, check, circ\n    except:\n        n = U.shape[1] // 2 if hasattr(U, 'shape') else 0\n        return n, 0, 0, 0.0, False, \"\"\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5 or len(op_list) > 4*n:\n            break\n            \n        candidates = []\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            candidates.append((key, hB_val, op, B))\n        \n        if not candidates:\n            break\n            \n        candidates.sort()\n        best_key, best_h_val, best_op, best_B = candidates[0]\n        \n        if best_h_val >= h_val and curr_wait > params['wMax']:\n            break\n            \n        U = best_B\n        op_list.append(best_op)\n        \n        if best_h_val < best_h:\n            best_h = best_h_val\n            curr_wait = 0\n        else:\n            curr_wait += 1\n            \n        if curr_wait > params['wMax']:\n            break\n\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    \n    matrices = [top, bot]\n    if params['ht']:\n        matrices.extend([top.T, bot.T])\n    if params['hi']:\n        matrices.extend([bin_mat_inv(top), bin_mat_inv(bot)])\n    \n    col_heuristics = []\n    for M in matrices:\n        col_sums = M.sum(axis=0)\n        col_nonzero = (M != 0).sum(axis=0)\n        col_heuristic = np.log(col_sums + 1e-6) - 0.5 * np.log(col_nonzero + 1e-6)\n        col_heuristics.append(col_heuristic)\n    \n    h_col = np.mean(col_heuristics)\n    h_sum = U.sum() / (2 * n * n) - 1\n    h_total = params['hr'] * (0.6 * h_col + 0.4 * h_sum)\n    \n    sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    return h_total, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    options = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                options.append(('cnot', i, j))\n                options.append(('cnot', j, i))\n    return options\n\ndef apply_op(U, op):\n    op_type, i, j = op\n    n = U.shape[1] // 2\n    if op_type == 'cnot':\n        F = np.eye(2*n)\n        F[i,j] = 1\n        return F @ U\n    return U\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            can_add = True\n            for existing_op in current_layer:\n                if (op[1] == existing_op[1] or op[1] == existing_op[2] or \n                    op[2] == existing_op[1] or op[2] == existing_op[2]):\n                    can_add = False\n                    break\n            if can_add:\n                current_layer.append(op)\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'cnot'])\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join([f\"{op[0]}_{op[1]}_{op[2]}\" for op in op_list])\n\ndef bin_mat_inv(A):\n    try:\n        return np.linalg.inv(A).astype(int) % 2\n    except:\n        return A\n\ndef sym_test(U, ops):\n    try:\n        n = U.shape[1] // 2\n        reconstructed = op_list2sym(ops, n)\n        return np.array_equal(U, reconstructed)\n    except:\n        return False\n\ndef op_list2sym(op_list, n):\n    mat = np.eye(2*n)\n    for op in op_list:\n        if op[0] == 'cnot':\n            i, j = op[1], op[2]\n            mat[i,j] = 1\n    return mat\n\ndef mat2SQC(UC):\n    n = UC.shape[1] // 2\n    ops = []\n    for i in range(n):\n        if UC[i,i] == 0:\n            for j in range(n):\n                if UC[j,i] == 1:\n                    ops.append(('cnot', j, i))\n                    break\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 71,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 73,
    "parent_id": 11,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Self-contained CNOT circuit synthesis using GL greedy heuristic.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': False,  # Disabled to save time\n        'ht': False,  # Disabled to save time\n        'hl': True,\n        'hr': 1,  # Reduced from 2\n        'wMax': 5  # Reduced from 8\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    # prepend single-qubit Clifford and permutation layer\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5 or np.array_equal(U[:n, :n], np.eye(n)):\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or hB_val < h_min:\n            curr_wait = 0\n            h_min = hB_val\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    sA = U.sum(axis=0)\n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    \n    log_sums = np.log(np.maximum(sA, 1))\n    h0 = log_sums.sum() / Ls\n    \n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n# Single-qubit Clifford layer extraction\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": -2.200000000000003,
      "additional_data": {
        "score": "-2.200000",
        "total_compute_time": "4.189653",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 70,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 74,
    "parent_id": 55,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappop, heappush\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    try:\n        if not isinstance(U, np.ndarray) or U.shape[0] != U.shape[1]:\n            return (n, 0, 0, time.time()-start, False, \"\")\n        \n        # Consider both original and transpose\n        matrices = [U, U.T]\n        best_result = None\n        best_gates = float('inf')\n        \n        for mat in matrices:\n            path = greedy_search(mat)\n            if path is None:\n                continue\n                \n            gate_count = len(path)\n            if gate_count < best_gates:\n                depth = calculate_depth(path)\n                best_gates = gate_count\n                best_result = (\n                    n, gate_count, depth,\n                    time.time() - start, True,\n                    path_to_string(path)\n                )\n                \n                # Early exit if perfect solution found\n                if best_gates == n:\n                    break\n        \n        if best_result is None:\n            return (n, 0, 0, time.time()-start, False, \"\")\n        return best_result\n    except:\n        return (n, 0, 0, time.time()-start, False, \"\")\n\ndef greedy_search(U):\n    n = U.shape[0]\n    current = U.copy()\n    path = []\n    \n    for col in range(n):\n        # Find target row\n        target_row = col\n        \n        # If column already correct, skip\n        if current[target_row, col] == 1 and sum(current[:, col]) == 1:\n            continue\n            \n        # Find best row to XOR to fix this column\n        best_row = None\n        for row in range(n):\n            if row != target_row and current[row, col] == 1:\n                best_row = row\n                break\n                \n        if best_row is not None:\n            path.append((best_row, target_row))\n            current[:, target_row] ^= current[:, best_row]\n            \n    # Verify solution\n    if np.array_equal(current, np.eye(n)):\n        return path\n    return None\n\ndef calculate_depth(path):\n    if not path:\n        return 0\n    layers = []\n    for (i,j) in path:\n        found_layer = False\n        for layer in layers:\n            if i not in layer and j not in layer:\n                layer.add(i)\n                layer.add(j)\n                found_layer = True\n                break\n        if not found_layer:\n            layers.append({i,j})\n    return len(layers)\n\ndef path_to_string(path):\n    return ' '.join(f'CNOT:{i},{j}' for (i,j) in path)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 75,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 75,
    "parent_id": 27,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 5\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = float('inf')\n    curr_wait = 0\n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U, params):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if hB_val < h_min:\n            curr_wait = 0\n            h_min = hB_val\n        else:\n            curr_wait += 1\n            if params['wMax'] > 0 and curr_wait > params['wMax']:\n                break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    h_col = (col_sums.sum() - n) / n\n    h_row = (row_sums.sum() - n) / n\n    w = tuple(sorted(int(x) for x in col_sums))\n    \n    if params['hi']:\n        inv = bin_mat_inv(top)\n        inv_col_sums = inv.sum(axis=0)\n        h_inv = (inv_col_sums.sum() - n) / n\n        h_col = min(h_col, h_inv)\n    \n    if params['ht']:\n        trans_col_sums = top.T.sum(axis=0)\n        h_trans = (trans_col_sums.sum() - n) / n\n        h_col = min(h_col, h_trans)\n    \n    h_total = h_col + 0.5 * h_row\n    return params['hr'] * h_total, w\n\ndef gl_options(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    max_col = np.argmax(col_sums)\n    max_row = np.argmax(row_sums)\n    opts = []\n    \n    for j in range(n):\n        if j != max_col and top[max_col, j]:\n            opts.append(('CX', (max_col, j)))\n    \n    if params['hl']:\n        for i in range(n):\n            if i != max_row and top[i, max_row]:\n                opts.append(('CX', (i, max_row)))\n    \n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 73,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 76,
    "parent_id": 32,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,\n        'wMax': 15,\n        'beam_width': 5,\n        'lookahead': 2\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], 0)])\n    \n    for _ in range(params['wMax'] * 2):\n        new_beam = []\n        for state in beam:\n            U, ops, wait = state\n            if np.array_equal(U[:n,:n], np.eye(n, dtype=int)):\n                return ops, U\n            \n            h_val = gl_heuristic(U)\n            candidates = []\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        op = ('CX', (i, j))\n                        B = apply_op(U.copy(), op)\n                        hB = gl_heuristic(B)\n                        candidates.append((hB, B, op))\n            \n            candidates.sort()\n            for hB, B, op in candidates[:params['beam_width']]:\n                new_ops = ops + [op]\n                if hB < h_val:\n                    new_beam.append((B, new_ops, 0))\n                else:\n                    new_beam.append((B, new_ops, wait + 1))\n        \n        if not new_beam:\n            break\n            \n        new_beam.sort(key=lambda x: (gl_heuristic(x[0]), len(x[1])))\n        beam = deque(new_beam[:params['beam_width']])\n    \n    best_state = min(beam, key=lambda x: (gl_heuristic(x[0]), len(x[1])))\n    return best_state[1], best_state[0]\n\ndef gl_heuristic(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_sums = np.sum(top, axis=0)\n    return np.sum(col_sums) + np.sum(np.log(col_sums + 1))\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    CList = [np.eye(2, dtype=int) for _ in range(n)]\n    ops = []\n    for i, M in enumerate(CList):\n        if not np.array_equal(M, np.eye(2, dtype=int)):\n            ops.append(('S', (i,)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()",
        "execution_method": "single_subprocess"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 74,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 3
    }
  },
  {
    "id": 77,
    "parent_id": 25,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    if U is None or not isinstance(U, np.ndarray):\n        return (0, 0, 0, 0, False, \"\")\n    \n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,\n        'wMax': 10,\n        'max_iters': 1000\n    }\n    try:\n        n = U.shape[1] // 2\n        sym = sym_cnot(U)\n        start = time.time()\n        \n        # Try multiple search strategies\n        results = []\n        for method in ['greedy', 'best_first']:\n            params['method'] = method\n            op_list, UC = csynth_search(sym, params)\n            if op_list:\n                sqc_ops = mat2SQC(UC)\n                full_ops = sqc_ops + op_list\n                depth = len(op_list_layers(full_ops))\n                gate_count = count_entangling(full_ops)\n                check = sym_test(sym, full_ops)\n                results.append((gate_count, depth, time.time()-start, check, full_ops))\n        \n        if not results:\n            return (n, 0, 0, time.time()-start, False, \"\")\n        \n        # Select best result (minimum gates)\n        best = min(results, key=lambda x: x[0])\n        circ = op_list_to_string(best[4])\n        return n, best[0], best[1], best[2], best[3], circ\n    except:\n        return (U.shape[1]//2 if U is not None else 0, 0, 0, 0, False, \"\")\n\ndef csynth_search(A, params):\n    if A is None:\n        return [], None\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    no_improve = 0\n    \n    for _ in range(params['max_iters']):\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        \n        if h_val < best_h:\n            best_h = h_val\n            no_improve = 0\n        else:\n            no_improve += 1\n            if no_improve > params['wMax']:\n                break\n\n        candidates = []\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            candidates.append((key, op, B))\n        \n        if not candidates:\n            break\n            \n        if params['method'] == 'greedy':\n            best = min(candidates, key=lambda x: x[0])\n        else:  # best_first\n            best = candidates[0]\n        \n        op_chosen = best[1]\n        U = best[2]\n        op_list.append(op_chosen)\n    \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    A = U[:n,:n]\n    sA = A.sum(axis=0)\n    sA_rows = A.sum(axis=1)\n    \n    if params['ht']:\n        sA = np.concatenate([sA, sA_rows])\n    \n    w = tuple(sorted(int(x) for x in sA))\n    h_components = []\n    \n    if params['hl']:\n        col_heuristic = np.log(sA + 1).sum()\n        row_heuristic = np.log(sA_rows + 1).sum()\n        h_components.append((col_heuristic + row_heuristic) / (2*n))\n    \n    if params['hi']:\n        try:\n            inv_A = bin_mat_inv(A.T % 2)\n            h_components.append(inv_A.sum() / n**2)\n        except:\n            pass\n    \n    h0 = sum(h_components) / len(h_components) if h_components else 0\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    A = U[:n,:n]\n    opts = []\n    \n    # Column operations\n    col_sums = A.sum(axis=0)\n    for j in np.where(col_sums > 0)[0]:\n        for i in np.where(A[:,j] == 1)[0]:\n            if i != j:\n                opts.append(('CX', (i, j)))\n    \n    # Row operations\n    row_sums = A.sum(axis=1)\n    for i in np.where(row_sums > 0)[0]:\n        for j in np.where(A[i,:] == 1)[0]:\n            if i != j:\n                opts.append(('CX', (i, j)))\n    \n    # Additional options based on matrix properties\n    prod = A.T @ A\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j and ('CX', (i, j)) not in opts:\n            opts.append(('CX', (i, j)))\n    \n    return opts\n\ndef apply_op(U, op):\n    if U is None or op is None:\n        return None\n    n = U.shape[1] // 2\n    V = U.copy()\n    if op[0] == 'CX':\n        i, j = op[1]\n        V[:n,j] = (V[:n,j] + V[:n,i]) % 2\n        V[n:,i] = (V[n:,i] + V[n:,j]) % 2\n    return V\n\ndef op_list_layers(op_list):\n    if not op_list:\n        return []\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            can_add = True\n            for existing_op in current_layer:\n                if (op[1][0] in existing_op[1] or \n                    op[1][1] in existing_op[1]):\n                    can_add = False\n                    break\n            if can_add:\n                current_layer.append(op)\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for op in op_list if op[0] == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f\"{op[0]}{op[1][0]}{op[1][1]}\" for op in op_list) if op_list else \"\"\n\ndef sym_cnot(U):\n    if U is None:\n        return None\n    n = U.shape[1] // 2\n    return np.vstack([np.hstack([U[:n,:n], np.zeros((n,n))]), \n                     np.hstack([U[n:,:n], U[:n,:n].T % 2])])\n\ndef bin_mat_inv(A):\n    if A is None:\n        return None\n    n = A.shape[0]\n    inv = np.eye(n, dtype=int)\n    for j in range(n):\n        if A[j,j] == 0:\n            for i in range(j+1, n):\n                if A[i,j] == 1:\n                    A[[j,i]] = A[[i,j]]\n                    inv[[j,i]] = inv[[i,j]]\n                    break\n        for i in range(n):\n            if i != j and A[i,j] == 1:\n                A[i] = (A[i] + A[j]) % 2\n                inv[i] = (inv[i] + inv[j]) % 2\n    return inv\n\ndef sym_test(U, ops):\n    if U is None or not ops:\n        return False\n    n = U.shape[1] // 2\n    reconstructed = op_list2sym(ops, n)\n    return np.array_equal(U, reconstructed)\n\ndef op_list2sym(op_list, n):\n    if not op_list:\n        return np.eye(2*n, dtype=int)\n    U = np.eye(2*n, dtype=int)\n    for op in reversed(op_list):\n        U = apply_op(U, op)\n    return U\n\ndef mat2SQC(UC):\n    if UC is None:\n        return []\n    n = UC.shape[1] // 2\n    A = UC[:n,:n]\n    ops = []\n    for j in range(n):\n        for i in range(j+1, n):\n            if A[i,j] == 1:\n                ops.append(('CX', (i, j)))\n                A[i] = (A[i] + A[j]) % 2\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 76,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 78,
    "parent_id": 30,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappush, heappop\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    # Consider original, transpose and inverse\n    matrices = [(U, 'original'), (U.T, 'transpose'), (bin_mat_inv(U), 'inverse')]\n    \n    best_result = None\n    best_gates = float('inf')\n    \n    for mat, desc in matrices:\n        try:\n            sym = np.zeros((2*n, 2*n), dtype=int)\n            sym[:n, :n] = mat % 2\n            sym[n:, n:] = bin_mat_inv(mat.T) % 2\n            \n            op_list, UC = beam_search(sym, beam_width=10, max_depth=50)\n            if not is_identity(UC):\n                continue\n                \n            gate_count = len([op for op in op_list if op[0] == 'CX'])\n            if gate_count < best_gates:\n                best_gates = gate_count\n                depth = len(op_list_layers(op_list))\n                best_result = (n, gate_count, depth, time.time() - start, True, op_list_to_string(op_list))\n        except:\n            continue\n    \n    if best_result is None:\n        return (n, 0, 0, time.time()-start, False, \"\")\n    return best_result\n\ndef beam_search(U, beam_width=10, max_depth=50):\n    n = U.shape[0] // 2\n    beam = [(heuristic(U), [], U.copy())]\n    \n    for _ in range(max_depth):\n        new_beam = []\n        \n        for _, ops, current in beam:\n            if is_identity(current):\n                return ops, current\n                \n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        for ctrl, targ in [(i,j), (j,i)]:\n                            new_U = apply_cnot(current, ctrl, targ)\n                            new_ops = ops + [('CX', (ctrl, targ))]\n                            h = heuristic(new_U)\n                            heappush(new_beam, (h, new_ops, new_U))\n                            \n                            if len(new_beam) > beam_width * 20:\n                                new_beam = new_beam[:beam_width]\n        \n        if not new_beam:\n            break\n            \n        beam = sorted(new_beam, key=lambda x: x[0])[:beam_width]\n    \n    if beam:\n        return beam[0][1], beam[0][2]\n    return [], U\n\ndef heuristic(U):\n    n = U.shape[0] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    log_heuristic = sum(np.log2(c + 1) for c in col_sums)\n    return log_heuristic + (col_sums.max() + row_sums.max())\n\ndef is_identity(U):\n    n = U.shape[0] // 2\n    return np.array_equal(U[:n, :n], np.eye(n)) and np.array_equal(U[n:, n:], np.eye(n))\n\ndef apply_cnot(U, ctrl, targ):\n    n = U.shape[0] // 2\n    U_new = U.copy()\n    U_new[:, targ] ^= U_new[:, ctrl]\n    U_new[:, n + ctrl] ^= U_new[:, n + targ]\n    return U_new\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:] % 2\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q)\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f'{typ}:{q[0]},{q[1]}' for typ, q in op_list)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 80,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 4
    }
  },
  {
    "id": 79,
    "parent_id": 17,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved search.py with enhanced heuristic and search strategy.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    # Optimized parameters\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': False,  # Disabled inverse handling\n        'ht': True,\n        'hl': True,\n        'hr': 5,  # Adjusted heuristic weight\n        'wMax': 6  # Balanced patience\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        best = None\n        best_dh = None\n        best_B = None\n        \n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n                \n        if best is None:\n            break\n            \n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        \n        if h_min is None or hB_val < h_min[1]:\n            curr_wait = 0\n            h_min = (h_tuple, hB_val)\n        else:\n            curr_wait += 1\n            \n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            break\n            \n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    if params['ht']:\n        sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    else:\n        sA = U.sum(axis=0)\n        \n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    \n    # Enhanced heuristic with better weighted components\n    h_components = []\n    if params['hl']:\n        h_components.append(0.6 * np.log(sA + 1e-6).sum() / Ls)\n    h_components.append(0.4 * (U.sum() / len(U) - 1))\n    \n    if params['ht']:\n        col_var = np.var(U.sum(axis=0))\n        row_var = np.var(U.sum(axis=1))\n        h_components.append(-0.05 * (col_var + row_var))\n        \n    h0 = sum(h_components)\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 1.6425223827362032,
      "additional_data": {
        "score": "1.642522",
        "total_compute_time": "13.157478",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 77,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 3
    }
  },
  {
    "id": 80,
    "parent_id": 13,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\nfrom collections import defaultdict\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': False,\n        'hr': 3,\n        'wMax': 10,\n        'max_iters': 100,\n        'early_term': 0.001\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    no_improve = 0\n    \n    for _ in range(params['max_iters']):\n        h_val = simple_heuristic(U)\n        if h_val <= params['early_term']:\n            break\n            \n        best_op = None\n        best_delta = float('inf')\n        best_U = None\n        \n        for op in targeted_gl_options(U):\n            new_U = apply_op(U, op)\n            new_h = simple_heuristic(new_U)\n            delta = new_h - h_val\n            \n            if delta < best_delta:\n                best_delta = delta\n                best_op = op\n                best_U = new_U\n        \n        if best_op is None:\n            break\n            \n        op_list.append(best_op)\n        U = best_U\n        \n        if h_val < best_h:\n            best_h = h_val\n            no_improve = 0\n        else:\n            no_improve += 1\n            if no_improve > params['wMax']:\n                break\n    \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef simple_heuristic(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    return sum(1/x for x in col_sums if x > 0) / n\n\ndef targeted_gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    options = []\n    \n    for i in range(n):\n        for j in range(n):\n            if i != j and top[i,j] == 1:\n                options.append(('CX', (i, j)))\n    \n    return options\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 78,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 81,
    "parent_id": 28,
    "solution": "\nimport numpy as np\nimport time\nimport math\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',  # Now supports 'greedy', 'beam', or 'hybrid'\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,  # More aggressive heuristic weighting\n        'wMax': 12,\n        'beam_width': 3,  # For beam search\n        'restart_threshold': 5,  # Local minima detection\n        'max_restarts': 2\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    \n    # Try multiple methods with fallback\n    methods = [params['method']]\n    if params['method'] != 'greedy':\n        methods.append('greedy')\n        \n    best_result = None\n    for method in methods:\n        current_params = params.copy()\n        current_params['method'] = method\n        op_list, UC = csynth_optimized(U, current_params)\n        if op_list:\n            if best_result is None or len(op_list) < len(best_result[0]):\n                best_result = (op_list, UC)\n    \n    if best_result is None:\n        return n, 0, 0, time.time()-start, False, \"\"\n    \n    op_list, UC = best_result\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_optimized(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    restarts = 0\n    stagnation = 0\n    \n    while True:\n        h_val, h_tuple = enhanced_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        if h_val < best_h - 1e-5:\n            best_h = h_val\n            stagnation = 0\n        else:\n            stagnation += 1\n            \n        if stagnation > params['wMax']:\n            if restarts < params['max_restarts']:\n                U = A.copy()\n                op_list = []\n                best_h = float('inf')\n                stagnation = 0\n                restarts += 1\n                continue\n            return [], A\n            \n        if params['method'] == 'greedy':\n            best_op, best_U = greedy_step(U, params)\n        elif params['method'] == 'beam':\n            best_op, best_U = beam_step(U, params)\n        else:  # hybrid\n            if len(op_list) < n*2:\n                best_op, best_U = greedy_step(U, params)\n            else:\n                best_op, best_U = beam_step(U, params)\n                \n        if best_op is None:\n            return [], A\n            \n        U = best_U\n        op_list.append(best_op)\n        \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef enhanced_heuristic(U, params):\n    n = U.shape[1] // 2\n    GL = U[:n, :n]\n    GR = U[:n, n:]\n    \n    # Column/row sums\n    col_sums = U.sum(axis=0)\n    row_sums = U.sum(axis=1)\n    sA = np.concatenate([col_sums, row_sums])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    # Log sum heuristic\n    log_sum = sum(math.log(x) if x > 0 else 0 for x in sA)\n    h0 = log_sum / len(sA)\n    \n    # Matrix norm heuristic\n    h1 = np.linalg.norm(GL, 'fro') + np.linalg.norm(GR, 'fro')\n    \n    # Column completion heuristic\n    complete_cols = sum(1 for x in col_sums[:n] if x == 1)\n    h2 = (n - complete_cols) / n\n    \n    # Combined heuristic\n    combined = params['hr'] * (0.5*h0 + 0.3*h1 + 0.2*h2)\n    \n    # Consider inverse/transpose if enabled\n    if params['hi'] or params['ht']:\n        min_h = combined\n        if params['hi']:\n            inv_h, _ = enhanced_heuristic(bin_mat_inv(U.T), params)\n            min_h = min(min_h, inv_h)\n        if params['ht']:\n            trans_h, _ = enhanced_heuristic(U.T, params)\n            min_h = min(min_h, trans_h)\n        combined = min_h\n    \n    return combined, w\n\ndef greedy_step(U, params):\n    best_op = None\n    best_U = None\n    best_h = float('inf')\n    \n    for op in extended_gl_options(U):\n        B = apply_op(U, op)\n        hB_val, _ = enhanced_heuristic(B, params)\n        if hB_val < best_h:\n            best_h = hB_val\n            best_op = op\n            best_U = B\n    \n    return best_op, best_U\n\ndef beam_step(U, params):\n    beam = deque()\n    beam.append((U, [], 0))\n    \n    for _ in range(params['beam_width']):\n        if not beam:\n            break\n            \n        current_U, current_ops, current_h = beam.popleft()\n        \n        for op in extended_gl_options(current_U):\n            B = apply_op(current_U, op)\n            hB_val, _ = enhanced_heuristic(B, params)\n            new_ops = current_ops + [op]\n            beam.append((B, new_ops, hB_val))\n        \n        beam = deque(sorted(beam, key=lambda x: x[2])[:params['beam_width']])\n    \n    if beam:\n        best_U, best_ops, _ = beam[0]\n        return best_ops[0], best_U\n    return None, None\n\ndef extended_gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n            opts.append(('CX', (j, i)))  # Also consider reverse CNOT\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: maximum recursion depth exceeded",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 79,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 3
    }
  },
  {
    "id": 82,
    "parent_id": 25,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\n\ndef search(U):\n    if U is None or not isinstance(U, np.ndarray):\n        return (0, 0, 0, 0, False, \"\")\n    \n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 5,\n        'wMax': 8\n    }\n    try:\n        n = U.shape[1] // 2\n        sym = np.vstack([np.hstack([U[:n,:n], np.zeros((n,n))]), \n                        np.hstack([U[n:,:n], U[:n,:n].T % 2])])\n        return synth_main(sym, params)\n    except:\n        return (U.shape[1]//2 if U is not None else 0, 0, 0, 0, False, \"\")\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    if not op_list:\n        return (n, 0, 0, time.time()-start, False, \"\")\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    if A is None:\n        return [], None\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    curr_wait = 0\n    best_h = float('inf')\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        if h_val < best_h:\n            best_h = h_val\n            curr_wait = 0\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    sA = U.sum(axis=0)\n    if params['ht']:\n        sA = np.concatenate([sA, U.sum(axis=1)])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    h_components = []\n    if params['hl']:\n        col_sums = U[:n,:n].sum(axis=0)\n        h_components.append(np.sum(np.log(col_sums + 1)))\n    if params['hi']:\n        try:\n            inv_U = bin_mat_inv(U[:n,:n].T % 2)\n            h_components.append(inv_U.sum() / n)\n        except:\n            h_components.append(n)\n    \n    h0 = sum(h_components) / len(h_components) if h_components else 0\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    opts = []\n    for j in range(n):\n        for i in range(n):\n            if i != j and top[i,j] == 1:\n                opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op):\n    if U is None or op is None:\n        return None\n    n = U.shape[1] // 2\n    V = U.copy()\n    if op[0] == 'CX':\n        i, j = op[1]\n        V[:n,j] = (V[:n,j] + V[:n,i]) % 2\n        V[n:,i] = (V[n:,i] + V[n:,j]) % 2\n    return V\n\ndef op_list_layers(op_list):\n    if not op_list:\n        return []\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            can_add = True\n            for existing_op in current_layer:\n                if op[1][0] == existing_op[1][0] or op[1][1] == existing_op[1][1] or op[1][0] == existing_op[1][1] or op[1][1] == existing_op[1][0]:\n                    can_add = False\n                    break\n            if can_add:\n                current_layer.append(op)\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    if not op_list:\n        return 0\n    return sum(1 for op in op_list if op[0] == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    if not op_list:\n        return \"\"\n    return sep.join(f\"{op[0]}{op[1][0]}{op[1][1]}\" for op in op_list)\n\ndef bin_mat_inv(A):\n    if A is None:\n        return None\n    n = A.shape[0]\n    identity = np.eye(n, dtype=int)\n    inv = np.eye(n, dtype=int)\n    for j in range(n):\n        pivot = A[j,j]\n        if pivot == 0:\n            for i in range(j+1, n):\n                if A[i,j] == 1:\n                    A[[j,i]] = A[[i,j]]\n                    inv[[j,i]] = inv[[i,j]]\n                    break\n        for i in range(n):\n            if i != j and A[i,j] == 1:\n                A[i] = (A[i] + A[j]) % 2\n                inv[i] = (inv[i] + inv[j]) % 2\n    return inv\n\ndef sym_test(U, ops):\n    if U is None or not ops:\n        return False\n    n = U.shape[1] // 2\n    reconstructed = op_list2sym(ops, n)\n    return np.array_equal(U, reconstructed)\n\ndef op_list2sym(op_list, n):\n    if not op_list:\n        return None\n    U = np.eye(2*n, dtype=int)\n    for op in reversed(op_list):\n        U = apply_op(U, op)\n    return U\n\ndef mat2SQC(UC):\n    if UC is None:\n        return []\n    n = UC.shape[1] // 2\n    A = UC[:n,:n]\n    ops = []\n    for j in range(n):\n        for i in range(j+1, n):\n            if A[i,j] == 1:\n                ops.append(('CX', (i, j)))\n                A[i] = (A[i] + A[j]) % 2\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 82,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 83,
    "parent_id": 58,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappush, heappop\nfrom collections import deque\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    matrices = [\n        (U, 'original'),\n        (U.T, 'transpose'),\n        (bin_mat_inv(U), 'inverse'),\n        (bin_mat_inv(U).T, 'inverse_transpose')\n    ]\n    \n    best_result = None\n    best_gates = float('inf')\n    \n    for mat, desc in matrices:\n        try:\n            sym = np.zeros((2*n, 2*n), dtype=int)\n            sym[:n, :n] = mat % 2\n            sym[n:, n:] = bin_mat_inv(mat.T) % 2\n            \n            op_list = hybrid_search(sym, n)\n            if not is_identity(apply_operations(sym.copy(), op_list, n)):\n                continue\n                \n            gate_count = count_entangling(op_list)\n            if gate_count < best_gates:\n                best_gates = gate_count\n                best_result = (n, gate_count, len(op_list_layers(op_list)), \n                              time.time() - start, True, op_list_to_string(op_list))\n                if time.time() - start > 15:\n                    break\n        except:\n            continue\n    \n    if best_result is None:\n        return (n, 0, 0, time.time()-start, False, \"\")\n    return best_result\n\ndef hybrid_search(U, n):\n    greedy_ops = greedy_search(U.copy(), n)\n    beam_ops = beam_search(U.copy(), n, beam_width=5, max_depth=3*n)\n    \n    if len(greedy_ops) <= len(beam_ops):\n        return greedy_ops\n    return beam_ops\n\ndef greedy_search(U, n):\n    ops = []\n    current = U.copy()\n    \n    while not is_identity(current):\n        best_move = None\n        best_h = float('inf')\n        \n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    for ctrl, targ in [(i,j), (j,i)]:\n                        new_U = apply_cnot(current, ctrl, targ, n)\n                        h = advanced_heuristic(new_U, n)\n                        if h < best_h:\n                            best_h = h\n                            best_move = ('CX', (ctrl, targ))\n                            temp_U = new_U\n        \n        if best_move is None:\n            break\n            \n        ops.append(best_move)\n        current = temp_U\n        \n        if len(ops) > 3*n:\n            break\n    \n    return ops\n\ndef beam_search(U, n, beam_width=5, max_depth=30):\n    beam = [(advanced_heuristic(U, n), [], U.copy())]\n    \n    for _ in range(max_depth):\n        new_beam = []\n        \n        for _, ops, current in beam:\n            if is_identity(current):\n                return ops\n                \n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        for ctrl, targ in [(i,j), (j,i)]:\n                            new_U = apply_cnot(current, ctrl, targ, n)\n                            new_ops = ops + [('CX', (ctrl, targ))]\n                            h = advanced_heuristic(new_U, n)\n                            heappush(new_beam, (h, new_ops, new_U))\n                            \n                            if len(new_beam) > beam_width * 10:\n                                new_beam = new_beam[:beam_width]\n        \n        if not new_beam:\n            break\n            \n        beam = new_beam[:beam_width]\n    \n    if beam:\n        return beam[0][1]\n    return []\n\ndef advanced_heuristic(U, n):\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    col_sums_top = top.sum(axis=0)\n    row_sums_top = top.sum(axis=1)\n    col_sums_bottom = bottom.sum(axis=0)\n    row_sums_bottom = bottom.sum(axis=1)\n    \n    h_top = (col_sums_top.sum() + row_sums_top.sum()) / (2*n)\n    h_bottom = (col_sums_bottom.sum() + row_sums_bottom.sum()) / (2*n)\n    \n    log_penalty = sum(np.log2(x + 1) for x in col_sums_top if x > 0)\n    \n    return h_top + h_bottom + log_penalty\n\ndef is_identity(U):\n    n = U.shape[0] // 2\n    return np.array_equal(U[:n, :n], np.eye(n)) and np.array_equal(U[n:, n:], np.eye(n))\n\ndef apply_cnot(U, ctrl, targ, n):\n    U_new = U.copy()\n    U_new[:, targ] ^= U_new[:, ctrl]\n    U_new[:, n + ctrl] ^= U_new[:, n + targ]\n    return U_new\n\ndef apply_operations(U, op_list, n):\n    current = U.copy()\n    for typ, (ctrl, targ) in op_list:\n        current = apply_cnot(current, ctrl, targ, n)\n    return current\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q)\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f'{typ}:{q[0]},{q[1]}' for typ, q in op_list)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 84,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 84,
    "parent_id": 39,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    n = U.shape[0]\n    start_time = time.time()\n    \n    # Preprocess matrix\n    U = U % 2\n    if np.array_equal(U, np.eye(n)):\n        return n, 0, 0, time.time()-start_time, True, \"\"\n    \n    # Try both original and transposed versions\n    best_circuit = None\n    best_gates = float('inf')\n    \n    for matrix in [U, U.T]:\n        current_circuit = []\n        remaining = matrix.copy()\n        \n        # Gaussian elimination approach\n        for col in range(n):\n            # Find pivot row\n            pivot = -1\n            for row in range(col, n):\n                if remaining[row, col] == 1:\n                    pivot = row\n                    break\n            \n            if pivot == -1:\n                continue\n                \n            # Swap rows if needed\n            if pivot != col:\n                current_circuit.append(('SWAP', (pivot, col)))\n                remaining[[pivot, col]] = remaining[[col, pivot]]\n            \n            # Eliminate other rows\n            for row in range(n):\n                if row != col and remaining[row, col] == 1:\n                    current_circuit.append(('CX', (col, row)))\n                    remaining[row] ^= remaining[col]\n    \n    # Optimize gate sequence\n    optimized = []\n    last_gate = None\n    for gate in current_circuit:\n        typ, qubits = gate\n        if last_gate and typ == 'CX' and last_gate[0] == 'CX':\n            # Check for gate cancellation\n            if qubits == last_gate[1]:\n                optimized.pop()\n                continue\n        optimized.append(gate)\n        last_gate = gate\n    \n    gate_count = len(optimized)\n    depth = len(set((i,j) if typ=='CX' else (i,j) for typ, (i,j) in optimized))\n    proc_time = time.time() - start_time\n    circ_str = ' '.join(f\"{typ}:{i},{j}\" if isinstance(j, int) else f\"{typ}:{i}\" for typ, (i,j) in optimized)\n    \n    # Verify correctness\n    test_matrix = np.eye(n)\n    for gate in optimized:\n        typ, (i, j) = gate\n        if typ == 'CX':\n            test_matrix[j] ^= test_matrix[i]\n        elif typ == 'SWAP':\n            test_matrix[[i, j]] = test_matrix[[j, i]]\n    \n    check = np.array_equal(test_matrix, U)\n    \n    return n, gate_count, depth, proc_time, check, circ_str\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: ufunc 'bitwise_xor' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''",
        "execution_method": "single_subprocess"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 85,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 3
    }
  },
  {
    "id": 85,
    "parent_id": 43,
    "solution": "\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n    \"\"\"\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': False,\n        'hl': True,\n        'hr': 4,\n        'wMax': 8\n    }\n    try:\n        sym = sym_cnot(U)\n        return synth_main(sym, params)\n    except:\n        n = U.shape[0]\n        return n, 0, 0, 0, False, \"\"\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    try:\n        op_list, UC = csynth_greedy(U, params)\n        sqc_ops = mat2SQC(UC)\n        full_ops = sqc_ops + op_list\n        depth = len(op_list_layers(full_ops))\n        gate_count = count_entangling(full_ops)\n        proc_time = time.time() - start\n        circ = op_list_to_string(full_ops)\n        check = sym_test(U, full_ops)\n        return n, gate_count, depth, proc_time, check, circ\n    except:\n        return n, 0, 0, proc_time, False, \"\"\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        best = None\n        best_dh = None\n        best_B = None\n        \n        if params['hi'] and np.random.rand() < 0.1:\n            try:\n                inv_U = bin_mat_inv(U[:n,:n].T)\n                inv_h, inv_tuple = gl_heuristic(inv_U, params)\n                if inv_h < h_val:\n                    U = inv_U\n                    op_list.append(('INV', (0,)))\n                    continue\n            except:\n                pass\n                \n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n                \n        if best is None:\n            break\n            \n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        \n        if h_min is None or hB_val < h_min[1]:\n            curr_wait = 0\n            h_min = (h_tuple, hB_val)\n        else:\n            curr_wait += 1\n            \n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            break\n            \n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    if n == 0:\n        return float('inf'), ()\n    sA = U[:n,:n].sum(axis=0)\n        \n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    \n    h_components = []\n    if params['hl']:\n        h_components.append(np.log(sA + 1e-6).sum() / Ls)\n    h_components.append((U[:n,:n].sum() / (n*n) - 1))\n    \n    h0 = sum(h_components) / len(h_components)\n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    if n == 0:\n        return []\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    try:\n        inv = bin_mat_inv(U.T % 2)\n        S[n:, n:] = inv % 2\n    except:\n        S[n:, n:] = np.eye(n, dtype=int)\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 83,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 86,
    "parent_id": 56,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nsearch.py - Optimized CNOT circuit synthesis with reduced search complexity.\n\"\"\"\n\nimport numpy as np\nimport time\n\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': False,  # Disabled inverse heuristic\n        'ht': False,  # Disabled transpose sum\n        'hl': True,   # Keep log heuristic\n        'hr': 1,      # Reduced heuristic weight\n        'wMax': 5      # Reduced max wait\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, n, params)\n        if h_val <= 1e-5:\n            break\n            \n        best = None\n        best_dh = None\n        best_B = None\n        \n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, _ = gl_heuristic(B, n, params)\n            dh = hB_val\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = op\n                best_B = B\n                \n        if best is None:\n            break\n            \n        U = best_B\n        op_list.append(best)\n        \n        if h_min is None or hB_val < h_min:\n            curr_wait = 0\n            h_min = hB_val\n        else:\n            curr_wait += 1\n            \n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            return [], A\n            \n    op_list = list(reversed(op_list))\n    return op_list, U\n\n\ndef gl_heuristic(U, n, params):\n    sA = U.sum(axis=0)\n    w = tuple(sorted(int(x) for x in sA))\n    \n    if params['hl']:\n        h0 = np.log(sA + 1e-10).sum() / len(sA)\n    else:\n        h0 = U.sum() / len(U) - 1\n        \n    return params['hr'] * h0, w\n\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    rows, cols = np.nonzero(top)\n    opts = []\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = []\n    for i, M in enumerate(CList):\n        key = ''.join(str(int(x)) for x in M.ravel())\n        if key in ['0110', '1101', '1011', '1110', '0111']:\n            ops.append((key[0], (i,)))\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 88,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 87,
    "parent_id": 12,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\nimport math\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 6,\n        'wMax': 12,\n        'beam_width': 3,\n        'max_iter': 200,\n        'stall_limit': 15\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], 0, float('inf'))], maxlen=params['beam_width'])\n    best_h = float('inf')\n    best_state = None\n    stall_count = 0\n    \n    for _ in range(params['max_iter']):\n        new_beam = []\n        for U, ops, steps, _ in beam:\n            if steps >= params['max_iter']:\n                continue\n                \n            h_val, h_tuple = gl_heuristic(U, params)\n            if h_val <= 1e-5:\n                return ops, U\n                \n            if h_val < best_h - 1e-5:\n                best_h = h_val\n                best_state = (U, ops, steps, h_val)\n                stall_count = 0\n            else:\n                stall_count += 1\n                \n            if stall_count > params['stall_limit']:\n                return best_state[1], best_state[0]\n                \n            candidates = []\n            for op in gl_options(U):\n                B = apply_op(U, op)\n                hB_val, hB_tuple = gl_heuristic(B, params)\n                new_ops = ops + [op]\n                candidates.append((B, new_ops, steps+1, hB_val))\n                \n            candidates.sort(key=lambda x: x[3])\n            new_beam.extend(candidates[:params['beam_width']])\n            \n        if not new_beam:\n            break\n            \n        beam = deque(sorted(new_beam, key=lambda x: x[3])[:params['beam_width']], \n                    maxlen=params['beam_width'])\n    \n    return best_state[1], best_state[0]\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    col_sums = U.sum(axis=0)\n    row_sums = U.sum(axis=1)\n    sA = np.concatenate([col_sums, row_sums])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    # Base heuristic: sum of logs\n    log_sum = sum(math.log(x) if x > 0 else 0 for x in sA)\n    h0 = log_sum / len(sA)\n    \n    # Column/row sum variance\n    col_var = np.var(col_sums[:n])\n    row_var = np.var(row_sums[n:])\n    h1 = (col_var + row_var) / (2*n)\n    \n    # Consider inverse and transpose\n    U_inv = bin_mat_inv(U[:n,:n].T) % 2\n    U_trans = U[:n,:n].T\n    \n    h_inv = sum(math.log(x) if x > 0 else 0 for x in U_inv.sum(axis=0))\n    h_trans = sum(math.log(x) if x > 0 else 0 for x in U_trans.sum(axis=0))\n    \n    # Combined heuristic\n    h_combined = (params['hr'] * h0 + 2*h1 + 0.5*(h_inv + h_trans)) / (params['hr'] + 3)\n    \n    return h_combined, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 87,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 4
    }
  },
  {
    "id": 88,
    "parent_id": 67,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2.0,\n        'wMax': 3\n    }\n    n = U.shape[0]\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops, n)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    \n    if np.array_equal(U, np.eye(2*n, dtype=int)):\n        return op_list, U\n        \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        best = None\n        best_dh = None\n        best_B = None\n        options = gl_options(U)\n        options.sort(key=lambda op: gl_heuristic(apply_op(U, op), params)[0])\n        for op in options[:min(5, len(options))]:\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        if h_min is None or hB_val < h_min[1]:\n            curr_wait = 0\n            h_min = (h_tuple, hB_val)\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    sA = U.sum(axis=0)\n    if params['ht']:\n        sA = np.concatenate([sA, U.sum(axis=1)])\n    if params['hi']:\n        inv_U = bin_mat_inv(U[:n,:n].T % 2)\n        sA_inv = inv_U.sum(axis=0)\n        if params['ht']:\n            sA_inv = np.concatenate([sA_inv, inv_U.sum(axis=1)])\n        sA = np.minimum(sA, sA_inv)\n    \n    w = tuple(sorted(int(x) for x in sA))\n    Ls = len(sA)\n    if params['hl']:\n        h0 = np.log(np.maximum(sA, 1)).sum() / Ls\n    else:\n        h0 = (U.sum() / len(U) - 1)\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_test(U, ops, n):\n    synthesized = op_list2sym(ops, n)\n    return np.array_equal(U, synthesized)\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: operands could not be broadcast together with shapes (64,) (32,) ",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 89,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 89,
    "parent_id": 83,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappush, heappop\n\ndef search(U):\n    n = U.shape[0]\n    start_time = time.time()\n    \n    def time_remaining():\n        return 15 - (time.time() - start_time)\n    \n    best_result = None\n    best_gates = float('inf')\n    \n    matrices = [\n        (U, 'original'),\n        (U.T, 'transpose'),\n        (np.linalg.inv(U).astype(int) % 2, 'inverse'),\n        (np.linalg.inv(U).T.astype(int) % 2, 'inverse_transpose')\n    ]\n    \n    for mat, desc in matrices:\n        if time_remaining() <= 0:\n            break\n            \n        sym = np.zeros((2*n, 2*n), dtype=int)\n        sym[:n, :n] = mat\n        sym[n:, n:] = np.linalg.inv(mat.T).astype(int) % 2\n        \n        ops = a_star_search(sym, n, time_remaining)\n        if ops is None:\n            continue\n            \n        gate_count = len(ops)\n        if gate_count < best_gates:\n            best_gates = gate_count\n            depth = len(op_list_layers(ops))\n            circ = op_list_to_string(ops)\n            best_result = (n, gate_count, depth, time.time()-start_time, True, circ)\n    \n    if best_result is None:\n        return (n, 0, 0, time.time()-start_time, False, \"\")\n    return best_result\n\ndef a_star_search(U, n, time_remaining):\n    open_set = []\n    heappush(open_set, (0, [], U.copy()))\n    \n    closed_set = set()\n    \n    while open_set and time_remaining() > 0:\n        _, ops, current = heappop(open_set)\n        \n        if is_identity(current):\n            return ops\n            \n        state_hash = hash(current.tobytes())\n        if state_hash in closed_set:\n            continue\n        closed_set.add(state_hash)\n        \n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    for ctrl, targ in [(i,j), (j,i)]:\n                        new_U = apply_cnot(current, ctrl, targ, n)\n                        new_ops = ops + [('CX', (ctrl, targ))]\n                        h = heuristic(new_U, n)\n                        g = len(new_ops)\n                        f = g + h\n                        heappush(open_set, (f, new_ops, new_U))\n    \n    return None\n\ndef heuristic(U, n):\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    # Column-based metrics\n    col_sums_top = top.sum(axis=0)\n    col_sums_bottom = bottom.sum(axis=0)\n    \n    # Row-based metrics\n    row_sums_top = top.sum(axis=1)\n    row_sums_bottom = bottom.sum(axis=1)\n    \n    # Weighted combination of factors\n    h_col = sum(np.log2(x + 1) for x in col_sums_top) + sum(np.log2(x + 1) for x in col_sums_bottom)\n    h_row = sum(np.log2(x + 1) for x in row_sums_top) + sum(np.log2(x + 1) for x in row_sums_bottom)\n    h_diag = sum(1 for i in range(n) if top[i,i] != 1) + sum(1 for i in range(n) if bottom[i,i] != 1)\n    \n    return h_col + h_row + h_diag\n\ndef is_identity(U):\n    n = U.shape[0] // 2\n    return np.array_equal(U[:n, :n], np.eye(n)) and np.array_equal(U[n:, n:], np.eye(n))\n\ndef apply_cnot(U, ctrl, targ, n):\n    U_new = U.copy()\n    U_new[:, targ] ^= U_new[:, ctrl]\n    U_new[:, n + ctrl] ^= U_new[:, n + targ]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q)\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f'{typ}:{q[0]},{q[1]}' for typ, q in op_list)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 90,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 90,
    "parent_id": 78,
    "solution": "\nimport numpy as np\nimport time\nfrom heapq import heappush, heappop\n\ndef search(U):\n    n = U.shape[0]\n    start = time.time()\n    \n    # Consider original, transpose and inverse\n    matrices = [(U, 'original'), (U.T, 'transpose'), (bin_mat_inv(U), 'inverse')]\n    \n    best_result = None\n    best_gates = float('inf')\n    \n    for mat, desc in matrices:\n        try:\n            sym = np.zeros((2*n, 2*n), dtype=int)\n            sym[:n, :n] = mat % 2\n            sym[n:, n:] = bin_mat_inv(mat.T) % 2\n            \n            op_list = astar_search(sym)\n            if not op_list or not is_identity(apply_operations(np.eye(2*n, dtype=int), op_list)):\n                continue\n                \n            gate_count = len(op_list)\n            if gate_count < best_gates:\n                best_gates = gate_count\n                depth = calculate_depth(op_list, n)\n                best_result = (n, gate_count, depth, time.time() - start, True, op_list_to_string(op_list))\n        except:\n            continue\n    \n    if best_result is None:\n        return (n, 0, 0, time.time()-start, False, \"\")\n    return best_result\n\ndef astar_search(target):\n    n = target.shape[0] // 2\n    start = np.eye(2*n, dtype=int)\n    visited = set()\n    heap = []\n    \n    # Priority queue: (heuristic + path length, path length, current matrix, path)\n    heappush(heap, (advanced_heuristic(start, target), 0, start, []))\n    \n    while heap:\n        _, path_len, current, path = heappop(heap)\n        \n        if is_identity(current):\n            return path\n            \n        if path_len > 3*n:  # Reasonable upper bound\n            continue\n            \n        state_key = tuple(current.flatten())\n        if state_key in visited:\n            continue\n        visited.add(state_key)\n        \n        # Generate neighbors in optimized order\n        for i in range(n):\n            for j in range(n):\n                if i != j:\n                    for ctrl, targ in [(i,j), (j,i)]:\n                        new_matrix = apply_cnot(current, ctrl, targ)\n                        new_path = path + [('CX', (ctrl, targ))]\n                        new_len = path_len + 1\n                        h = advanced_heuristic(new_matrix, target)\n                        heappush(heap, (h + new_len, new_len, new_matrix, new_path))\n    \n    return None\n\ndef advanced_heuristic(current, target):\n    n = current.shape[0] // 2\n    diff = (current[:n,:n] != target[:n,:n]).sum()\n    col_diff = (current[:n,:n] != target[:n,:n]).sum(axis=0)\n    row_diff = (current[:n,:n] != target[:n,:n]).sum(axis=1)\n    return diff + max(col_diff) + max(row_diff)\n\ndef is_identity(U):\n    n = U.shape[0] // 2\n    return np.array_equal(U[:n, :n], np.eye(n)) and np.array_equal(U[n:, n:], np.eye(n))\n\ndef apply_cnot(U, ctrl, targ):\n    n = U.shape[0] // 2\n    U_new = U.copy()\n    U_new[:, targ] ^= U_new[:, ctrl]\n    U_new[:, n + ctrl] ^= U_new[:, n + targ]\n    return U_new\n\ndef apply_operations(start, ops):\n    current = start.copy()\n    for op in ops:\n        current = apply_cnot(current, op[1][0], op[1][1])\n    return current\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:] % 2\n\ndef calculate_depth(op_list, n):\n    layers = []\n    for op in op_list:\n        ctrl, targ = op[1]\n        placed = False\n        for layer in layers:\n            if ctrl not in layer and targ not in layer:\n                layer.add(ctrl)\n                layer.add(targ)\n                placed = True\n                break\n        if not placed:\n            layers.append({ctrl, targ})\n    return len(layers)\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f'{typ}:{q[0]},{q[1]}' for typ, q in op_list)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 92,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 91,
    "parent_id": 21,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hl': True,\n        'hr': 1,\n        'wMax': 10\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params, n)\n        if h_val <= 1e-5:\n            break\n            \n        best = None\n        best_dh = None\n        best_B = None\n        \n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params, n)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n                \n        if best is None:\n            break\n            \n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        \n        if h_min is None or hB_val < h_min[1]:\n            curr_wait = 0\n            h_min = (h_tuple, hB_val)\n        else:\n            curr_wait += 1\n            \n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            break\n            \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params, n):\n    sA = U.sum(axis=0)\n    w = tuple(sorted(int(x) for x in sA))\n    \n    if params['hl']:\n        h0 = np.log(sA + 1e-10).sum() / len(sA)\n    else:\n        h0 = (U.sum() / len(U) - 1)\n        \n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    opts = []\n    for i in range(n):\n        for j in range(n):\n            if i != j and top[i,j] == 1:\n                opts.append(('CX', (i,j)))\n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'SWAP':\n        i, j = q\n        U_new[:, [i, j]] = U_new[:, [j, i]]\n        U_new[:, [n+i, n+j]] = U_new[:, [n+j, n+i]]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ in ['CX', 'SWAP'])\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 1,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 91,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 92,
    "parent_id": 2,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    n = U.shape[0]\n    start_time = time.time()\n    \n    # Try both original and transposed matrices\n    best_circuit = None\n    best_gates = float('inf')\n    \n    for matrix in [U, U.T]:\n        current_circuit = []\n        current_matrix = matrix.copy()\n        \n        # Beam search with width 3\n        beam = deque([(current_matrix, current_circuit, 0)], maxlen=3)\n        \n        while beam:\n            current_matrix, current_circuit, _ = beam.popleft()\n            \n            if np.sum(current_matrix) == n:  # Identity reached\n                if len(current_circuit) < best_gates:\n                    best_gates = len(current_circuit)\n                    best_circuit = current_circuit\n                break\n            \n            # Generate and evaluate possible CNOT operations\n            candidates = []\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        new_matrix = apply_cnot(current_matrix, i, j)\n                        h = fast_heuristic(new_matrix)\n                        candidates.append((new_matrix, current_circuit + [(i,j)], h))\n            \n            # Keep only the best candidates\n            candidates.sort(key=lambda x: x[2])\n            for candidate in candidates[:3]:\n                beam.append(candidate)\n            \n            # Timeout check\n            if time.time() - start_time > 10:\n                break\n    \n    proc_time = time.time() - start_time\n    gate_count = len(best_circuit) if best_circuit else 0\n    depth = calculate_depth(best_circuit) if best_circuit else 0\n    check = verify_circuit(U, best_circuit) if best_circuit else False\n    \n    # Format circuit string\n    circ_str = ' '.join(f'CX:{c[0]},{c[1]}' for c in best_circuit) if best_circuit else ''\n    \n    return n, gate_count, depth, proc_time, check, circ_str\n\ndef apply_cnot(matrix, control, target):\n    new_matrix = matrix.copy()\n    new_matrix[target] ^= new_matrix[control]\n    return new_matrix\n\ndef fast_heuristic(matrix):\n    col_sums = np.sum(matrix, axis=0)\n    row_sums = np.sum(matrix, axis=1)\n    return np.sum(np.log(col_sums + 1)) + np.sum(np.log(row_sums + 1))\n\ndef calculate_depth(circuit):\n    if not circuit:\n        return 0\n    layers = []\n    for gate in circuit:\n        c, t = gate\n        placed = False\n        for layer in layers:\n            if c not in layer and t not in layer:\n                layer.update([c, t])\n                placed = True\n                break\n        if not placed:\n            layers.append({c, t})\n    return len(layers)\n\ndef verify_circuit(target, circuit):\n    if not circuit:\n        return False\n    n = target.shape[0]\n    current = np.eye(n, dtype=int)\n    for gate in circuit:\n        c, t = gate\n        current[t] ^= current[c]\n    return np.array_equal(current, target)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 94,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  },
  {
    "id": 93,
    "parent_id": 53,
    "solution": "\nimport numpy as np\nimport time\nimport math\nfrom collections import deque\nimport random\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': False,\n        'ht': False,\n        'hl': False,\n        'hr': 2,\n        'wMax': 5,\n        'beam_width': 1,\n        'restart_threshold': 3,\n        'max_restarts': 1,\n        'random_perturb': 0.05,\n        'max_steps': 100\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    \n    op_list, UC = csynth_optimized(U, params)\n    if not op_list:\n        return n, 0, 0, time.time()-start, False, \"\"\n    \n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_optimized(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    stagnation = 0\n    \n    for step in range(params['max_steps']):\n        h_val = simple_heuristic(U)\n        if h_val <= 1e-5:\n            break\n            \n        if h_val < best_h - 1e-5:\n            best_h = h_val\n            stagnation = 0\n        else:\n            stagnation += 1\n            \n        if stagnation > params['wMax']:\n            if params['max_restarts'] > 0:\n                U = A.copy()\n                op_list = []\n                best_h = float('inf')\n                stagnation = 0\n                params['max_restarts'] -= 1\n                continue\n            return [], A\n            \n        best_op = None\n        best_U = None\n        best_h_new = float('inf')\n        \n        for op in limited_gl_options(U):\n            B = apply_op(U, op)\n            hB_val = simple_heuristic(B)\n            if hB_val < best_h_new:\n                best_h_new = hB_val\n                best_op = op\n                best_U = B\n        \n        if best_op is None:\n            if random.random() < params['random_perturb']:\n                best_op = random.choice(limited_gl_options(U))\n                best_U = apply_op(U, best_op)\n            else:\n                return [], A\n            \n        U = best_U\n        op_list.append(best_op)\n        \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef simple_heuristic(U):\n    n = U.shape[1] // 2\n    return np.sum(U[:n, :n]) + np.sum(U[:n, n:])\n\ndef limited_gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    opts = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if top[i,j] or top[j,i]:\n                opts.append(('CX', (i, j)))\n                opts.append(('CX', (j, i)))\n                break\n    return opts if opts else [('CX', (0, 1))]\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    ops = []\n    if ixR != list(range(n)):\n        ops.append(('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 93,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 94,
    "parent_id": 7,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 12\n    }\n    try:\n        sym = U.copy()  # Skip sym_cnot transformation which was problematic\n        return synth_main(sym, params)\n    except Exception as e:\n        n = U.shape[1] // 2\n        return n, 0, 0, 0, False, \"\"\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    best_h = float('inf')\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        if h_val < best_h:\n            best_h = h_val\n            curr_wait = 0\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    sA = top.sum(axis=0)\n    if params['ht']:\n        sA = np.concatenate([sA, top.sum(axis=1)])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    h_components = []\n    if params['hl']:\n        h_components.append(np.log(sA + 1).sum() / len(sA))\n    if params['hi']:\n        inv_U = np.linalg.inv(top) % 2\n        h_components.append((inv_U.sum() / n**2))\n    \n    h0 = sum(h_components) / len(h_components) if h_components else 0\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    opts = []\n    for i in range(n):\n        for j in range(n):\n            if i != j and top[i,j] == 1:\n                opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op):\n    n = U.shape[1] // 2\n    V = U.copy()\n    if op[0] == 'CX':\n        c, t = op[1]\n        V[:n,t] ^= V[:n,c]\n        V[n:,c] ^= V[n:,t]\n    return V\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            can_add = True\n            for existing_op in current_layer:\n                if (op[1][0] in existing_op[1] or \n                    op[1][1] in existing_op[1]):\n                    can_add = False\n                    break\n            if can_add:\n                current_layer.append(op)\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'CX'])\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f\"{op[0]}_{op[1][0]}_{op[1][1]}\" for op in op_list)\n\ndef mat2SQC(UC):\n    n = UC.shape[1] // 2\n    top = UC[:n, :n]\n    ops = []\n    for i in range(n):\n        for j in range(n):\n            if i != j and top[i,j] == 1:\n                ops.append(('CX', (i, j)))\n    return ops\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    test = np.eye(2*n, dtype=int)\n    for op in ops:\n        test = apply_op(test, op)\n    return np.array_equal(U, test)\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 95,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 5
    }
  },
  {
    "id": 95,
    "parent_id": 76,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,\n        'wMax': 20,\n        'beam_width': 8,\n        'lookahead': 1\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], 0)])\n    \n    for _ in range(params['wMax']):\n        new_beam = []\n        for state in beam:\n            U, ops, wait = state\n            if np.array_equal(U[:n,:n], np.eye(n, dtype=int)):\n                return ops, U\n            \n            h_val = gl_heuristic(U)\n            candidates = []\n            for i in range(n):\n                for j in range(n):\n                    if i != j:\n                        op = ('CX', (i, j))\n                        B = apply_op(U.copy(), op)\n                        hB = gl_heuristic(B)\n                        candidates.append((hB, B, op))\n            \n            candidates.sort()\n            for hB, B, op in candidates[:params['beam_width']]:\n                new_ops = ops + [op]\n                if hB < h_val:\n                    new_beam.append((B, new_ops, 0))\n                else:\n                    new_beam.append((B, new_ops, wait + 1))\n        \n        if not new_beam:\n            break\n            \n        new_beam.sort(key=lambda x: (gl_heuristic(x[0]), len(x[1])))\n        beam = deque(new_beam[:params['beam_width']])\n    \n    best_state = min(beam, key=lambda x: (gl_heuristic(x[0]), len(x[1])))\n    return best_state[1], best_state[0]\n\ndef gl_heuristic(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_sums = np.sum(top, axis=0)\n    return np.sum(col_sums) + np.sum(np.log2(col_sums + 1))\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    CList = [np.eye(2, dtype=int) for _ in range(n)]\n    ops = []\n    for i, M in enumerate(CList):\n        if not np.array_equal(M, np.eye(2, dtype=int)):\n            ops.append(('S', (i,)))\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: The truth value of an array with more than one element is ambiguous. Use a.any() or a.all()",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 97,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 96,
    "parent_id": 47,
    "solution": "\n#!/usr/bin/env python3\n\"\"\"\nImproved CNOT circuit synthesis using multi-representation beam search.\n\"\"\"\n\nimport numpy as np\nimport time\nimport math\nfrom collections import deque\n\ndef search(U):\n    \"\"\"\n    Synthesize a CNOT circuit for an n\u00d7n invertible binary matrix U.\n    Returns:\n        n (int): number of qubits,\n        gate_count (int): number of CNOT gates,\n        depth (int): circuit depth,\n        proc_time (float): synthesis time in seconds,\n        check (bool): verification of correctness,\n        circ (str): circuit operations string.\n    \"\"\"\n    params = {\n        'mode': 'GL',\n        'method': 'beam',\n        'beam_width': 5,\n        'max_stagnation': 15,\n        'consider_inverse': True,\n        'consider_transpose': True,\n        'timeout': 15.0\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_beam(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_beam(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    beam = deque([(A.copy(), [], 0)])\n    best_h = float('inf')\n    best_state = None\n    stagnation = 0\n    start_time = time.time()\n    \n    while beam and (time.time() - start_time) < params['timeout']:\n        current_states = []\n        for U, ops, _ in beam:\n            h_val = multi_heuristic(U, params)\n            if h_val < 1e-5:\n                return ops, U\n            if h_val < best_h - 1e-5:\n                best_h = h_val\n                best_state = (U, ops)\n                stagnation = 0\n            else:\n                stagnation += 1\n                \n            if stagnation > params['max_stagnation']:\n                return best_state[1], best_state[0]\n                \n            for op in expanded_options(U, params):\n                new_U = apply_op(U, op)\n                new_ops = ops + [op]\n                new_h = multi_heuristic(new_U, params)\n                current_states.append((new_U, new_ops, new_h))\n        \n        current_states.sort(key=lambda x: x[2])\n        beam = deque(current_states[:params['beam_width']])\n    \n    return best_state[1], best_state[0] if best_state else ([], A)\n\ndef multi_heuristic(U, params):\n    n = U.shape[1] // 2\n    representations = [U]\n    \n    if params['consider_inverse']:\n        try:\n            inv = bin_mat_inv(U[:n,:n].T)\n            S_inv = sym_cnot(inv)\n            representations.append(S_inv)\n        except:\n            pass\n            \n    if params['consider_transpose']:\n        S_trans = sym_cnot(U[:n,:n].T)\n        representations.append(S_trans)\n    \n    min_h = float('inf')\n    for rep in representations:\n        h = advanced_heuristic(rep)\n        if h < min_h:\n            min_h = h\n    return min_h\n\ndef advanced_heuristic(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    # Column metrics\n    col_sums_top = top.sum(axis=0)\n    col_sums_bottom = bottom.sum(axis=0)\n    \n    # Row metrics\n    row_sums_top = top.sum(axis=1)\n    row_sums_bottom = bottom.sum(axis=1)\n    \n    # Combined metrics\n    col_metric = sum(math.log(x + 1) for x in col_sums_top) + sum(math.log(x + 1) for x in col_sums_bottom)\n    row_metric = sum(math.log(x + 1) for x in row_sums_top) + sum(math.log(x + 1) for x in row_sums_bottom)\n    \n    # Off-diagonal penalty\n    off_diag = np.sum(top * (1 - np.eye(n))) + np.sum(bottom * (1 - np.eye(n)))\n    \n    return 0.4*col_metric + 0.4*row_metric + 0.2*off_diag\n\ndef expanded_options(U, params):\n    n = U.shape[1] // 2\n    options = set()\n    \n    # Standard CNOT options\n    top = U[:n, :n]\n    bottom = U[n:, n:]\n    \n    # Forward CNOTs\n    prod_top = (top.T @ top) % 2\n    rows, cols = np.nonzero(prod_top)\n    for i, j in zip(rows, cols):\n        if i != j:\n            options.add(('CX', (i, j)))\n    \n    # Reverse CNOTs\n    prod_bottom = (bottom.T @ bottom) % 2\n    rows, cols = np.nonzero(prod_bottom)\n    for i, j in zip(rows, cols):\n        if i != j:\n            options.add(('CX', (j, i)))\n    \n    # Permutation options\n    if len(options) < 5:  # Add permutations if few options\n        for i in range(n):\n            for j in range(i+1, n):\n                options.add(('SWAP', (i, j)))\n    \n    return list(options)\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'SWAP':\n        i, j = q\n        U_new[:, [i, j]] = U_new[:, [j, i]]\n        U_new[:, n + [i, j]] = U_new[:, n + [j, i]]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ in ['CX', 'SWAP'])\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 96,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 97,
    "parent_id": 7,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\n\ndef search(U):\n    if U is None or not isinstance(U, np.ndarray):\n        n = 0\n        return n, 0, 0, 0.0, False, \"\"\n    \n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 3,  # Increased for better heuristic balance\n        'wMax': 10  # Increased for better exploration\n    }\n    sym = sym_cnot(U)\n    if sym is None:\n        n = U.shape[1] // 2 if U is not None else 0\n        return n, 0, 0, 0.0, False, \"\"\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    if not op_list:\n        return n, 0, 0, time.time()-start, False, \"\"\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    best_h = float('inf')\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n        if h_val < best_h:\n            best_h = h_val\n            curr_wait = 0\n        else:\n            curr_wait += 1\n            if curr_wait > params['wMax']:\n                break\n\n        best = None\n        best_dh = None\n        best_B = None\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (0, key)\n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n        if best is None:\n            break\n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    sA = U.sum(axis=0)\n    if params['ht']:\n        sA = np.concatenate([sA, U.sum(axis=1)])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    h_components = []\n    if params['hl']:\n        h_components.append(np.log(sA + 1e-10).sum())\n    if params['hi']:\n        try:\n            inv_U = bin_mat_inv(U[:n,:n].T % 2)\n            h_components.append(inv_U.sum())\n        except:\n            h_components.append(n**2)\n    \n    h0 = sum(h_components) / (n**2) if h_components else 0\n    return params['hr'] * h0, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    prod = top.T @ top\n    opts = []\n    rows, cols = np.nonzero(prod)\n    for i, j in zip(rows, cols):\n        if i != j:\n            opts.append(('CX', (i, j)))\n    col_sums = top.sum(axis=0)\n    for j in np.where(col_sums > 1)[0]:\n        for i in np.where(top[:,j] == 1)[0]:\n            if i != j:\n                opts.append(('CX', (i, j)))\n    return opts\n\ndef apply_op(U, op): \n    n = U.shape[1] // 2\n    V = U.copy()\n    if op[0] == 'CX':\n        c, t = op[1]\n        V[:n,t] ^= V[:n,c]\n        V[n:,c] ^= V[n:,t]\n    return V\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer or all(o[1][1] != op[1][1] for o in current_layer):\n            current_layer.append(op)\n        else:\n            layers.append(current_layer)\n            current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for op in op_list if op[0] == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join(f\"{op[0]}{op[1][0]}{op[1][1]}\" for op in op_list)\n\ndef sym_cnot(U):\n    n = U.shape[1] // 2\n    return np.block([[U[:n,:n], np.zeros((n,n))], [U[n:,:n], U[:n,:n].T % 2]])\n\ndef bin_mat_inv(A):\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    A = np.hstack((A, I))\n    for i in range(n):\n        if A[i,i] == 0:\n            for j in range(i+1, n):\n                if A[j,i] == 1:\n                    A[[i,j]] = A[[j,i]]\n                    break\n        for j in range(n):\n            if i != j and A[j,i] == 1:\n                A[j] ^= A[i]\n    return A[:,n:]\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    S = op_list2sym(ops, n)\n    return np.array_equal(U, S)\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in reversed(op_list):\n        U = apply_op(U, op)\n    return U\n\ndef mat2SQC(UC):\n    n = UC.shape[1] // 2\n    A = UC[:n,:n]\n    C = UC[n:,:n]\n    op_list = []\n    for i in range(n):\n        for j in range(n):\n            if C[i,j] == 1:\n                op_list.append(('CX', (j, i)))\n    return op_list\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.0",
        "total_compute_time": "0.0",
        "validity": "error",
        "error": "Evaluation failed: ufunc 'bitwise_xor' not supported for the input types, and the inputs could not be safely coerced to any supported types according to the casting rule ''safe''",
        "execution_method": "single_subprocess"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 98,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 6
    }
  },
  {
    "id": 98,
    "parent_id": 84,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    n = U.shape[0]\n    start_time = time.time()\n    \n    # Convert to binary matrix with integer type\n    U = (U % 2).astype(int)\n    if np.array_equal(U, np.eye(n, dtype=int)):\n        return n, 0, 0, time.time()-start_time, True, \"\"\n    \n    best_circuit = []\n    best_gates = float('inf')\n    \n    for matrix in [U, U.T]:\n        current_circuit = []\n        remaining = matrix.copy()\n        \n        # Gaussian elimination approach\n        for col in range(n):\n            # Find pivot row\n            pivot = -1\n            for row in range(col, n):\n                if remaining[row, col] == 1:\n                    pivot = row\n                    break\n            \n            if pivot == -1:\n                continue\n                \n            # Swap rows if needed\n            if pivot != col:\n                current_circuit.append(('SWAP', (pivot, col)))\n                remaining[[pivot, col]] = remaining[[col, pivot]]\n            \n            # Eliminate other rows\n            for row in range(n):\n                if row != col and remaining[row, col] == 1:\n                    current_circuit.append(('CX', (col, row)))\n                    remaining[row] = (remaining[row] + remaining[col]) % 2\n        \n        # Optimize gate sequence\n        optimized = []\n        last_gate = None\n        for gate in current_circuit:\n            typ, qubits = gate\n            if last_gate and typ == 'CX' and last_gate[0] == 'CX':\n                # Check for gate cancellation\n                if qubits == last_gate[1]:\n                    optimized.pop()\n                    continue\n            optimized.append(gate)\n            last_gate = gate\n        \n        if len(optimized) < best_gates:\n            best_gates = len(optimized)\n            best_circuit = optimized\n    \n    gate_count = len(best_circuit)\n    depth = len(set((i,j) if typ=='CX' else (i,j) for typ, (i,j) in best_circuit))\n    proc_time = time.time() - start_time\n    circ_str = ' '.join(f\"{typ}:{i},{j}\" for typ, (i,j) in best_circuit)\n    \n    # Verify correctness\n    test_matrix = np.eye(n, dtype=int)\n    for gate in best_circuit:\n        typ, (i, j) = gate\n        if typ == 'CX':\n            test_matrix[j] = (test_matrix[j] + test_matrix[i]) % 2\n        elif typ == 'SWAP':\n            test_matrix[[i, j]] = test_matrix[[j, i]]\n    \n    check = np.array_equal(test_matrix, U)\n    \n    return n, gate_count, depth, proc_time, check, circ_str\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 100,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 99,
    "parent_id": 46,
    "solution": "\nimport numpy as np\nimport time\nfrom collections import defaultdict\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': False,\n        'ht': False,\n        'hl': True,\n        'hr': 1,\n        'wMax': 20,\n        'max_iter': 200,\n        'early_term': 0.001\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    best_U = None\n    best_ops = []\n    curr_wait = 0\n    prev_h = float('inf')\n    \n    for iteration in range(params['max_iter']):\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5:\n            break\n            \n        if h_val < best_h:\n            best_h = h_val\n            best_U = U.copy()\n            best_ops = op_list.copy()\n            curr_wait = 0\n        else:\n            curr_wait += 1\n            \n        if curr_wait > params['wMax']:\n            U = best_U\n            op_list = best_ops\n            break\n            \n        if iteration > 5 and abs(prev_h - h_val) / (prev_h + 1e-9) < params['early_term']:\n            break\n        prev_h = h_val\n        \n        best_op = None\n        best_dh = float('inf')\n        best_B = None\n        \n        for op in gl_options(U, params):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            dh = hB_val - h_val\n            \n            if dh < best_dh:\n                best_dh = dh\n                best_op = op\n                best_B = B\n                \n        if best_op is None:\n            break\n            \n        U = best_B\n        op_list.append(best_op)\n        \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    col_sums = top.sum(axis=0)\n    row_sums = top.sum(axis=1)\n    h_sum = top.sum()\n    h_col = (col_sums * (col_sums - 1)).sum()\n    h_row = (row_sums * (row_sums - 1)).sum()\n    h0 = h_sum + 0.5 * (h_col + h_row)\n    w = (tuple(sorted(col_sums)), tuple(sorted(row_sums)))\n    return h0, w\n\ndef gl_options(U, params):\n    n = U.shape[1] // 2\n    opts = []\n    \n    # Generate all possible CNOTs\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                opts.append(('CX', (i, j)))\n    \n    # Generate all possible swaps (as QPerm)\n    for i in range(n):\n        for j in range(i+1, n):\n            perm = list(range(n))\n            perm[i] = j\n            perm[j] = i\n            opts.append(('QPerm', tuple(perm)))\n    \n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    \n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    \n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ == 'CX')\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-reasoner",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 81,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 100,
    "parent_id": 91,
    "solution": "\n#!/usr/bin/env python3\nimport numpy as np\nimport time\nfrom collections import deque\n\ndef search(U):\n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hl': True,\n        'hr': 0.5,\n        'wMax': 20,\n        'max_iters': 1000,\n        'timeout': 15\n    }\n    sym = sym_cnot(U)\n    return synth_main(sym, params)\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    \n    # Try original, inverse and transpose versions\n    best_result = None\n    for transform in [lambda x: x, np.transpose, lambda x: bin_mat_inv(x)]:\n        if time.time() - start > params['timeout']:\n            break\n            \n        try:\n            U_trans = transform(U)\n            op_list, UC = csynth_greedy(U_trans, params, start)\n            sqc_ops = mat2SQC(UC)\n            full_ops = sqc_ops + op_list\n            gate_count = count_entangling(full_ops)\n            \n            if best_result is None or gate_count < best_result[1]:\n                depth = len(op_list_layers(full_ops))\n                proc_time = time.time() - start\n                circ = op_list_to_string(full_ops)\n                check = sym_test(U, full_ops)\n                best_result = (n, gate_count, depth, proc_time, check, circ)\n                \n                # Early termination if perfect solution found\n                if gate_count <= n * 2:\n                    break\n                    \n        except:\n            continue\n            \n    if best_result is None:\n        return n, 0, 0, 0, False, \"\"\n    return best_result\n\ndef csynth_greedy(A, params, start_time):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    h_min = None\n    curr_wait = 0\n    best_states = deque(maxlen=5)\n    \n    for _ in range(params['max_iters']):\n        if time.time() - start_time > params['timeout']:\n            break\n            \n        h_val, h_tuple = gl_heuristic(U, params, n)\n        if h_val <= 1e-5:\n            break\n            \n        best = None\n        best_dh = None\n        best_B = None\n        \n        for op in gl_options(U, n):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params, n)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            dh = (key[0], hB_val)\n            \n            if best_dh is None or dh < best_dh:\n                best_dh = dh\n                best = (hB_tuple, hB_val, op)\n                best_B = B\n                \n        if best is None:\n            break\n            \n        _, hB_val, op_chosen = best\n        U = best_B\n        op_list.append(op_chosen)\n        \n        if h_min is None or hB_val < h_min[1]:\n            curr_wait = 0\n            h_min = (h_tuple, hB_val)\n            best_states.append((U.copy(), list(op_list)))\n        else:\n            curr_wait += 1\n            \n        if params['wMax'] > 0 and curr_wait > params['wMax']:\n            # Backtrack to best state\n            if best_states:\n                U, op_list = best_states.pop()\n            break\n            \n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params, n):\n    top = U[:n, :n]\n    sA = top.sum(axis=0)\n    col_weights = tuple(sorted(int(x) for x in sA))\n    row_weights = tuple(sorted(int(x) for x in top.sum(axis=1)))\n    \n    # Combined heuristic\n    h_sum = U.sum() / (2*n*n)\n    h_log = np.log(sA + 1e-10).sum() / n\n    h_col = sum(1 for x in sA if x == 1) / n\n    h_row = sum(1 for x in top.sum(axis=1) if x == 1) / n\n    \n    h_combined = (h_sum + h_log + h_col + h_row) / 4\n    return params['hr'] * h_combined, (col_weights, row_weights)\n\ndef gl_options(U, n):\n    top = U[:n, :n]\n    opts = []\n    \n    # CNOT options\n    for i in range(n):\n        for j in range(n):\n            if i != j and top[i,j] == 1:\n                opts.append(('CX', (i,j)))\n                \n    # SWAP options\n    for i in range(n):\n        for j in range(i+1, n):\n            if top[i,j] != top[j,i]:\n                opts.append(('SWAP', (i,j)))\n    \n    return opts\n\ndef apply_op(U, op):\n    typ, q = op\n    U_new = U.copy()\n    n = U.shape[1] // 2\n    if typ == 'CX':\n        i, j = q\n        U_new[:, j] ^= U_new[:, i]\n        U_new[:, n + i] ^= U_new[:, n + j]\n    elif typ == 'SWAP':\n        i, j = q\n        U_new[:, [i, j]] = U_new[:, [j, i]]\n        U_new[:, [n+i, n+j]] = U_new[:, [n+j, n+i]]\n    elif typ == 'QPerm':\n        ix = list(q)\n        perm = ix + [p + len(ix) for p in ix]\n        U_new = U_new[:, perm]\n    return U_new\n\ndef op_list_layers(op_list):\n    layers = []\n    for typ, q in op_list:\n        qubits = set(q) if isinstance(q, tuple) else {q}\n        for layer in layers:\n            if qubits.isdisjoint(layer):\n                layer.update(qubits)\n                break\n        else:\n            layers.append(set(qubits))\n    return layers\n\ndef count_entangling(op_list):\n    return sum(1 for typ, q in op_list if typ in ['CX', 'SWAP'])\n\ndef op_list_to_string(op_list, sep=' '):\n    parts = []\n    for typ, q in op_list:\n        if isinstance(q, tuple):\n            parts.append(f'{typ}:{q[0]},{q[1]}')\n        else:\n            parts.append(f'{typ}:{q}')\n    return sep.join(parts)\n\ndef sym_cnot(U):\n    n = U.shape[0]\n    S = np.zeros((2*n, 2*n), dtype=int)\n    S[:n, :n] = U % 2\n    inv = bin_mat_inv(U.T % 2)\n    S[n:, n:] = inv % 2\n    return S\n\ndef bin_mat_inv(A):\n    A = A.copy() % 2\n    n = A.shape[0]\n    I = np.eye(n, dtype=int)\n    aug = np.concatenate([A, I], axis=1)\n    for i in range(n):\n        if aug[i, i] == 0:\n            for j in range(i+1, n):\n                if aug[j, i] == 1:\n                    aug[[i, j]] = aug[[j, i]]\n                    break\n            else:\n                raise ValueError(\"Matrix is singular and cannot be inverted.\")\n        for j in range(n):\n            if j != i and aug[j, i] == 1:\n                aug[j] ^= aug[i]\n    return aug[:, n:]\n\nSQC_tostr = {\n    '1001': 'I', '0110': 'H',\n    '1101': 'S', '1011': 'HSH',\n    '1110': 'HS', '0111': 'SH'\n}\n\ndef sym_r2(U):\n    n = U.shape[0] // 2\n    R2 = np.zeros((n, n), dtype=int)\n    for i in range(n):\n        for j in range(n):\n            F = np.array([[U[i, j], U[i, j+n]],\n                          [U[i+n, j], U[i+n, j+n]]], dtype=int)\n            det = (F[0,0]*F[1,1] + F[0,1]*F[1,0]) % 2\n            if det == 1:\n                R2[i,j] = 1\n    return R2\n\ndef perm_mat_to_ix(P):\n    if (P.sum(axis=0) != 1).any() or (P.sum(axis=1) != 1).any():\n        return None\n    return [int(np.where(P[i])[0][0]) for i in range(P.shape[0])]\n\ndef ix_rev(ix):\n    r = [0]*len(ix)\n    for i, j in enumerate(ix):\n        r[j] = i\n    return r\n\ndef Fmat(U, i, j):\n    n = U.shape[0] // 2\n    return np.array([[U[i, j], U[i, j+n]],\n                     [U[i+n, j], U[i+n, j+n]]], dtype=int)\n\ndef SQC2str(A):\n    key = ''.join(str(int(x)) for x in A.ravel())\n    return SQC_tostr.get(key, 'I')\n\ndef CList2opList(CList):\n    ops = []\n    for i, M in enumerate(CList):\n        c = SQC2str(M)\n        if c != 'I':\n            ops.append((c, (i,)))\n    return ops\n\ndef mat2SQC(UC):\n    n = UC.shape[0] // 2\n    UR2 = sym_r2(UC)\n    ix = perm_mat_to_ix(UR2)\n    if ix is None:\n        ix = list(range(n))\n    ixR = ix_rev(ix)\n    CList = [Fmat(UC, i, ix[i]) for i in ixR]\n    ops = CList2opList(CList)\n    if ixR != list(range(n)):\n        ops.insert(0, ('QPerm', tuple(ixR)))\n    return ops\n\ndef op_list2sym(op_list, n):\n    U = np.eye(2*n, dtype=int)\n    for op in op_list:\n        U = apply_op(U, op)\n    return U\n\ndef sym_test(U, ops):\n    n = U.shape[1] // 2\n    return np.array_equal(U, op_list2sym(ops, n))\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-chat",
      "change_type": "LARGE QUALITATIVE CHANGE",
      "step": 99,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 1
    }
  },
  {
    "id": 101,
    "parent_id": 61,
    "solution": "\nimport numpy as np\nimport time\n\ndef search(U):\n    if U is None:\n        n = 0\n        return n, 0, 0, 0.0, False, \"\"\n    \n    params = {\n        'mode': 'GL',\n        'method': 'greedy',\n        'minDepth': False,\n        'hv': True,\n        'hi': True,\n        'ht': True,\n        'hl': True,\n        'hr': 2,\n        'wMax': 8\n    }\n    \n    try:\n        sym = sym_cnot(U)\n        if sym is None:\n            n = U.shape[1] // 2 if hasattr(U, 'shape') else 0\n            return n, 0, 0, 0.0, False, \"\"\n        return synth_main(sym, params)\n    except:\n        n = U.shape[1] // 2 if hasattr(U, 'shape') else 0\n        return n, 0, 0, 0.0, False, \"\"\n\ndef synth_main(U, params):\n    n = U.shape[1] // 2\n    start = time.time()\n    op_list, UC = csynth_greedy(U, params)\n    sqc_ops = mat2SQC(UC)\n    full_ops = sqc_ops + op_list\n    depth = len(op_list_layers(full_ops))\n    gate_count = count_entangling(full_ops)\n    proc_time = time.time() - start\n    circ = op_list_to_string(full_ops)\n    check = sym_test(U, full_ops)\n    return n, gate_count, depth, proc_time, check, circ\n\ndef csynth_greedy(A, params):\n    n2 = A.shape[1]\n    n = n2 // 2\n    U = A.copy()\n    op_list = []\n    best_h = float('inf')\n    curr_wait = 0\n    \n    while True:\n        h_val, h_tuple = gl_heuristic(U, params)\n        if h_val <= 1e-5 or len(op_list) > 3*n:\n            break\n            \n        candidates = []\n        for op in gl_options(U):\n            B = apply_op(U, op)\n            hB_val, hB_tuple = gl_heuristic(B, params)\n            key = (hB_tuple, hB_val) if params['hv'] else (hB_val, hB_tuple)\n            candidates.append((key, hB_val, op, B))\n        \n        if not candidates:\n            break\n            \n        candidates.sort()\n        best_key, best_h_val, best_op, best_B = candidates[0]\n        \n        if best_h_val >= h_val and curr_wait > params['wMax']//2:\n            break\n            \n        U = best_B\n        op_list.append(best_op)\n        \n        if best_h_val < best_h:\n            best_h = best_h_val\n            curr_wait = 0\n        else:\n            curr_wait += 1\n            \n        if curr_wait > params['wMax']:\n            break\n\n    op_list = list(reversed(op_list))\n    return op_list, U\n\ndef gl_heuristic(U, params):\n    n = U.shape[1] // 2\n    top = U[:n, :n]\n    bot = U[n:, n:]\n    \n    matrices = [top]\n    if params['ht']:\n        matrices.append(top.T)\n    if params['hi']:\n        matrices.append(bin_mat_inv(top))\n    \n    col_heuristics = []\n    for M in matrices:\n        col_sums = M.sum(axis=0)\n        col_nonzero = (M != 0).sum(axis=0)\n        col_heuristic = np.log(col_sums + 1e-6) - 0.5 * np.log(col_nonzero + 1e-6)\n        col_heuristics.append(col_heuristic)\n    \n    h_col = np.mean(col_heuristics)\n    h_sum = U.sum() / (2 * n * n) - 1\n    h_total = params['hr'] * (0.7 * h_col + 0.3 * h_sum)\n    \n    sA = np.concatenate([U.sum(axis=0), U.sum(axis=1)])\n    w = tuple(sorted(int(x) for x in sA))\n    \n    return h_total, w\n\ndef gl_options(U):\n    n = U.shape[1] // 2\n    options = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                options.append(('cnot', i, j))\n                options.append(('cnot', j, i))\n    return options\n\ndef apply_op(U, op):\n    op_type, i, j = op\n    n = U.shape[1] // 2\n    if op_type == 'cnot':\n        V = U.copy()\n        V[j, :n] = (V[j, :n] + V[i, :n]) % 2\n        V[i, n:] = (V[i, n:] + V[j, n:]) % 2\n        return V\n    return U\n\ndef op_list_layers(op_list):\n    layers = []\n    current_layer = []\n    for op in op_list:\n        if not current_layer:\n            current_layer.append(op)\n        else:\n            can_add = True\n            for existing_op in current_layer:\n                if (op[1] == existing_op[1] or op[1] == existing_op[2] or \n                    op[2] == existing_op[1] or op[2] == existing_op[2]):\n                    can_add = False\n                    break\n            if can_add:\n                current_layer.append(op)\n            else:\n                layers.append(current_layer)\n                current_layer = [op]\n    if current_layer:\n        layers.append(current_layer)\n    return layers\n\ndef count_entangling(op_list):\n    return len([op for op in op_list if op[0] == 'cnot'])\n\ndef op_list_to_string(op_list, sep=' '):\n    return sep.join([f\"{op[0]}_{op[1]}_{op[2]}\" for op in op_list])\n\ndef sym_cnot(U):\n    if U is None:\n        return None\n    try:\n        n = U.shape[1] // 2\n        S = np.zeros((2*n, 2*n), dtype=int)\n        S[:n, :n] = U[:n, :n]\n        S[n:, n:] = U[n:, n:]\n        return S\n    except:\n        return None\n\ndef bin_mat_inv(A):\n    try:\n        return np.linalg.inv(A).astype(int) % 2\n    except:\n        return A\n\ndef sym_test(U, ops):\n    try:\n        n = U.shape[1] // 2\n        reconstructed = op_list2sym(ops, n)\n        return np.array_equal(U, reconstructed)\n    except:\n        return False\n\ndef op_list2sym(op_list, n):\n    mat = np.eye(2*n, dtype=int)\n    for op in op_list:\n        mat = apply_op(mat, op)\n    return mat\n\ndef mat2SQC(UC):\n    n = UC.shape[1] // 2\n    ops = []\n    for i in range(n):\n        if UC[i,i] == 0:\n            for j in range(n):\n                if UC[j,i] == 1:\n                    ops.append(('cnot', j, i))\n                    break\n    return ops\n",
    "evaluation": {
      "fitness": 0.0,
      "additional_data": {
        "score": "0.000000",
        "total_compute_time": "0.000000",
        "validity": "valid",
        "execution_method": "single_subprocess",
        "function_name": "search"
      }
    },
    "children": 0,
    "creation_info": {
      "model": "deepseek:deepseek-reasoner",
      "change_type": "SMALL ITERATIVE IMPROVEMENT",
      "step": 86,
      "is_reasoning": true,
      "big_changes_rate": 0.4,
      "child_number": 2
    }
  }
]